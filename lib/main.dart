import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:math' as math;
import 'dart:typed_data';
import 'dart:ui' as ui;

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:breakaway365_web/theme.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:video_player/video_player.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import 'package:universal_html/html.dart' as html;
import 'package:file_picker/file_picker.dart';
import 'package:http/http.dart' as http;
import 'package:intl/intl.dart';
import 'pages/aicoach_view.dart';
import 'pages/upload_results_page.dart';
import 'services/gcs_service.dart';
// Conditional import: use web iframe on web, placeholder elsewhere
import 'widgets/embed_view_stub.dart'
    if (dart.library.html) 'widgets/embed_view_web.dart' as embed;
import 'widgets/shimmer_skeleton.dart';
import 'widgets/walkthrough_overlay.dart';
import 'services/walkthrough_service.dart';

import 'firebase_options.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  if (Firebase.apps.isEmpty) {
    await Firebase.initializeApp(
        options: DefaultFirebaseOptions.currentPlatform);
  }
  runApp(const MyApp());
}

// Helper: robust file download on Web (works better inside iframes)
void _triggerWebDownload(Uint8List bytes, String fileName, String mimeType) {
  // Create a Blob URL
  final blob = html.Blob([bytes], mimeType);
  final url = html.Url.createObjectUrlFromBlob(blob);

  // Create a hidden anchor to trigger download
  final anchor = html.AnchorElement(href: url)
    ..download = fileName
    ..style.display = 'none';

  html.document.body?.append(anchor);
  anchor.click();
  anchor.remove();

  // Fallback for sandboxed iframe environments: open in a new tab as well
  try {
    final isFramed = html.window.self != html.window.top;
    if (isFramed) {
      html.window.open(url, '_blank');
    }
  } catch (_) {
    // Access to window.top may be blocked by browser; ignore
  }

  // Revoke the URL after a short delay to ensure the browser had time to use it
  Future.delayed(const Duration(seconds: 1), () {
    html.Url.revokeObjectUrl(url);
  });
}

class _MessagesHeroBanner extends StatefulWidget {
  const _MessagesHeroBanner({required this.isCompact});

  final bool isCompact;

  @override
  State<_MessagesHeroBanner> createState() => _MessagesHeroBannerState();
}

class _MessagesHeroBannerState extends State<_MessagesHeroBanner> {
  List<_HeroMetric> _metrics = [];
  bool _loading = true;
  final Map<String, bool> _updatingMetrics = {};

  @override
  void initState() {
    super.initState();
    _loadMetrics();
  }

  Future<void> _updateSpecificMetric(String metricLabel) async {
    setState(() {
      _updatingMetrics[metricLabel] = true;
    });

    debugPrint('üîÑ Updating metric: $metricLabel');

    try {
      await _loadMetrics();
      debugPrint('‚úÖ Metric updated: $metricLabel');
    } catch (e) {
      debugPrint('‚ùå Error updating metric $metricLabel: $e');
    } finally {
      if (mounted) {
        setState(() {
          _updatingMetrics[metricLabel] = false;
        });
      }
    }
  }

  Future<void> _loadMetrics() async {
    try {
      final firestore = FirebaseFirestore.instance;
      final now = DateTime.now();
      final todayStart = DateTime(now.year, now.month, now.day);
      final lastWeekStart = todayStart.subtract(const Duration(days: 7));

      // Get conversations count for today
      final todayConversationsSnapshot = await firestore
          .collection('conversations')
          .where('createdAt',
              isGreaterThanOrEqualTo: Timestamp.fromDate(todayStart))
          .get();
      final conversationsToday = todayConversationsSnapshot.docs.length;

      // Calculate average response time from messages
      final messagesSnapshot = await firestore
          .collection('messages')
          .orderBy('sentAt', descending: true)
          .limit(100)
          .get();

      final thisWeekMessages = await firestore
          .collection('messages')
          .where('sentAt',
              isGreaterThanOrEqualTo: Timestamp.fromDate(lastWeekStart))
          .where('sentAt', isLessThan: Timestamp.fromDate(todayStart))
          .orderBy('sentAt')
          .limit(100)
          .get();

      // Group messages by conversation and calculate response times
      Map<String, List<DateTime>> conversationMessages = {};
      List<int> responseTimesSeconds = [];
      List<int> lastWeekResponseTimesSeconds = [];

      // Process recent messages for current average
      for (final doc in messagesSnapshot.docs) {
        final data = doc.data();
        final conversationId = data['conversationId'] as String? ?? '';
        final sentAt = (data['sentAt'] as Timestamp?)?.toDate();
        final senderId = data['senderId'] as String? ?? '';

        if (conversationId.isNotEmpty && sentAt != null) {
          conversationMessages.putIfAbsent(conversationId, () => []);
          conversationMessages[conversationId]!.add(sentAt);
        }
      }

      // Calculate response times between consecutive messages
      for (final messages in conversationMessages.values) {
        if (messages.length >= 2) {
          messages.sort();
          for (int i = 1; i < messages.length; i++) {
            final responseTime =
                messages[i].difference(messages[i - 1]).inSeconds;
            // Only count response times less than 1 hour (3600s) to avoid outliers
            if (responseTime > 0 && responseTime < 3600) {
              responseTimesSeconds.add(responseTime);
            }
          }
        }
      }

      // Process last week's messages for trend comparison
      Map<String, List<DateTime>> lastWeekConversationMessages = {};
      for (final doc in thisWeekMessages.docs) {
        final data = doc.data();
        final conversationId = data['conversationId'] as String? ?? '';
        final sentAt = (data['sentAt'] as Timestamp?)?.toDate();

        if (conversationId.isNotEmpty && sentAt != null) {
          lastWeekConversationMessages.putIfAbsent(conversationId, () => []);
          lastWeekConversationMessages[conversationId]!.add(sentAt);
        }
      }

      for (final messages in lastWeekConversationMessages.values) {
        if (messages.length >= 2) {
          messages.sort();
          for (int i = 1; i < messages.length; i++) {
            final responseTime =
                messages[i].difference(messages[i - 1]).inSeconds;
            if (responseTime > 0 && responseTime < 3600) {
              lastWeekResponseTimesSeconds.add(responseTime);
            }
          }
        }
      }

      // Calculate averages
      final avgResponseTime = responseTimesSeconds.isEmpty
          ? 0
          : responseTimesSeconds.reduce((a, b) => a + b) ~/
              responseTimesSeconds.length;

      final lastWeekAvgResponseTime = lastWeekResponseTimesSeconds.isEmpty
          ? 0
          : lastWeekResponseTimesSeconds.reduce((a, b) => a + b) ~/
              lastWeekResponseTimesSeconds.length;

      // Format response time
      String avgResponseTimeText;
      if (avgResponseTime == 0) {
        avgResponseTimeText = 'No data';
      } else if (avgResponseTime < 60) {
        avgResponseTimeText = '${avgResponseTime}s';
      } else if (avgResponseTime < 3600) {
        final minutes = avgResponseTime ~/ 60;
        final seconds = avgResponseTime % 60;
        avgResponseTimeText = '${minutes}m ${seconds}s';
      } else {
        final hours = avgResponseTime ~/ 3600;
        final minutes = (avgResponseTime % 3600) ~/ 60;
        avgResponseTimeText = '${hours}h ${minutes}m';
      }

      // Calculate trend
      String trendText;
      if (avgResponseTime == 0 || lastWeekAvgResponseTime == 0) {
        trendText = 'Not enough data';
      } else {
        final percentChange = ((lastWeekAvgResponseTime - avgResponseTime) /
                lastWeekAvgResponseTime *
                100)
            .round();
        if (percentChange > 0) {
          trendText = '+$percentChange% faster this week';
        } else if (percentChange < 0) {
          trendText = '${percentChange.abs()}% slower this week';
        } else {
          trendText = 'Same as last week';
        }
      }

      debugPrint(
          'üìä Avg response time: $avgResponseTimeText (${responseTimesSeconds.length} samples)');
      debugPrint(
          'üìä Last week avg: ${lastWeekAvgResponseTime}s (${lastWeekResponseTimesSeconds.length} samples)');
      debugPrint('üìä Trend: $trendText');

      // Find most active member (by total session duration or message activity)
      final membersSnapshot = await firestore
          .collection('users')
          .where('role', isEqualTo: 'Member')
          .get();

      String? mostActiveMember;
      int maxMemberDuration = 0;

      for (final doc in membersSnapshot.docs) {
        final data = doc.data();
        // Try multiple fields to determine activity
        int sessionDuration = data['totalSessionDuration'] as int? ??
            data['sessionDuration'] as int? ??
            data['activityDuration'] as int? ??
            0;

        // If no duration field, use message count or activity count as fallback
        if (sessionDuration == 0) {
          final messageCount = data['messageCount'] as int? ?? 0;
          final activityCount = data['activityCount'] as int? ?? 0;
          sessionDuration = (messageCount + activityCount) *
              60; // Convert to seconds estimate
        }

        if (sessionDuration > maxMemberDuration) {
          maxMemberDuration = sessionDuration;
          mostActiveMember =
              data['name'] as String? ?? data['email'] as String? ?? 'Member';
        }
      }

      // Find most active coach (by total session duration or message activity)
      final coachesSnapshot = await firestore
          .collection('users')
          .where('role', isEqualTo: 'Coach')
          .get();

      String? mostActiveCoach;
      int maxCoachDuration = 0;

      for (final doc in coachesSnapshot.docs) {
        final data = doc.data();
        // Try multiple fields to determine activity
        int sessionDuration = data['totalSessionDuration'] as int? ??
            data['sessionDuration'] as int? ??
            data['activityDuration'] as int? ??
            0;

        // If no duration field, use message count or activity count as fallback
        if (sessionDuration == 0) {
          final messageCount = data['messageCount'] as int? ?? 0;
          final activityCount = data['activityCount'] as int? ?? 0;
          sessionDuration = (messageCount + activityCount) *
              60; // Convert to seconds estimate
        }

        if (sessionDuration > maxCoachDuration) {
          maxCoachDuration = sessionDuration;
          mostActiveCoach =
              data['name'] as String? ?? data['email'] as String? ?? 'Coach';
        }
      }

      final String memberDurationText = maxMemberDuration > 0
          ? '${(maxMemberDuration / 3600).toStringAsFixed(1)}h total'
          : 'No activity yet';
      final String coachDurationText = maxCoachDuration > 0
          ? '${(maxCoachDuration / 3600).toStringAsFixed(1)}h total'
          : 'No activity yet';

      debugPrint(
          'üìä Messages Metrics: Conversations today: $conversationsToday');
      debugPrint(
          'üìä Most active member: $mostActiveMember ($memberDurationText)');
      debugPrint('üìä Most active coach: $mostActiveCoach ($coachDurationText)');

      if (mounted) {
        setState(() {
          _metrics = [
            _HeroMetric(
              icon: Icons.speed_outlined,
              label: 'Avg. response time',
              value: avgResponseTimeText,
              trend: trendText,
              onUpdate: () => _updateSpecificMetric('Avg. response time'),
              isUpdating: _updatingMetrics['Avg. response time'] ?? false,
            ),
            _HeroMetric(
              icon: Icons.schedule_outlined,
              label: 'Conversations today',
              value: '$conversationsToday',
              trend: '6 in the last hour',
              onUpdate: () => _updateSpecificMetric('Conversations today'),
              isUpdating: _updatingMetrics['Conversations today'] ?? false,
            ),
            _HeroMetric(
              icon: Icons.person_outlined,
              label: 'Most Active (Member)',
              value: mostActiveMember ?? 'No members',
              trend: memberDurationText,
              onUpdate: () => _updateSpecificMetric('Most Active (Member)'),
              isUpdating: _updatingMetrics['Most Active (Member)'] ?? false,
            ),
            _HeroMetric(
              icon: Icons.badge_outlined,
              label: 'Most Active (Coach)',
              value: mostActiveCoach ?? 'No coaches',
              trend: coachDurationText,
              onUpdate: () => _updateSpecificMetric('Most Active (Coach)'),
              isUpdating: _updatingMetrics['Most Active (Coach)'] ?? false,
            ),
          ];
          _loading = false;
        });
      }
    } catch (e) {
      debugPrint('‚ùå Error loading metrics: $e');
      if (mounted) {
        setState(() {
          _metrics = [
            _HeroMetric(
              icon: Icons.speed_outlined,
              label: 'Avg. response time',
              value: 'Error loading',
              trend: null,
              onUpdate: () => _updateSpecificMetric('Avg. response time'),
              isUpdating: _updatingMetrics['Avg. response time'] ?? false,
            ),
            _HeroMetric(
              icon: Icons.schedule_outlined,
              label: 'Conversations today',
              value: 'Error loading',
              trend: null,
              onUpdate: () => _updateSpecificMetric('Conversations today'),
              isUpdating: _updatingMetrics['Conversations today'] ?? false,
            ),
            _HeroMetric(
              icon: Icons.person_outlined,
              label: 'Most Active (Member)',
              value: 'Error loading',
              trend: null,
              onUpdate: () => _updateSpecificMetric('Most Active (Member)'),
              isUpdating: _updatingMetrics['Most Active (Member)'] ?? false,
            ),
            _HeroMetric(
              icon: Icons.badge_outlined,
              label: 'Most Active (Coach)',
              value: 'Error loading',
              trend: null,
              onUpdate: () => _updateSpecificMetric('Most Active (Coach)'),
              isUpdating: _updatingMetrics['Most Active (Coach)'] ?? false,
            ),
          ];
          _loading = false;
        });
      }
    }
  }

  static const List<_HeroSuggestionChip> _suggestions = [
    _HeroSuggestionChip(icon: Icons.edit_outlined, label: 'Compose message'),
    _HeroSuggestionChip(
        icon: Icons.bolt_outlined, label: 'Launch quick broadcast'),
    _HeroSuggestionChip(
        icon: Icons.timeline_outlined, label: 'View engagement trends'),
  ];

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(28),
        gradient: const LinearGradient(
          colors: [Color(0xFF2563EB), Color(0xFF6366F1)],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.12),
            blurRadius: 28,
            offset: const Offset(0, 20),
          ),
        ],
      ),
      padding: EdgeInsets.all(widget.isCompact ? 24 : 32),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          widget.isCompact
              ? _compactHeader()
              : Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Expanded(child: _headline()),
                    const SizedBox(width: 32),
                    Flexible(
                      flex: 0,
                      child: _loading
                          ? const SizedBox(
                              width: 200,
                              height: 100,
                              child: Center(
                                child: CircularProgressIndicator(
                                    color: Colors.white),
                              ),
                            )
                          : Wrap(
                              spacing: 16,
                              runSpacing: 16,
                              children: _metrics,
                            ),
                    ),
                  ],
                ),
          if (widget.isCompact) const SizedBox(height: 20),
          if (widget.isCompact)
            _loading
                ? const SizedBox(
                    height: 100,
                    child: Center(
                      child: CircularProgressIndicator(color: Colors.white),
                    ),
                  )
                : SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      children: _metrics
                          .map((metric) => Padding(
                                padding: const EdgeInsets.only(right: 16),
                                child: metric,
                              ))
                          .toList(),
                    ),
                  ),
        ],
      ),
    );
  }

  Widget _headline() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: const [
        Text(
          'Messages',
          style: TextStyle(
            color: Colors.white,
            fontSize: 28,
            fontWeight: FontWeight.w800,
            letterSpacing: -0.4,
          ),
        ),
        SizedBox(height: 12),
        Text(
          'Coordinate with members, coaches, and groups in an inbox that feels effortless.',
          style: TextStyle(
              color: Colors.white70,
              fontSize: 15,
              height: 1.4,
              fontWeight: FontWeight.w500),
        ),
      ],
    );
  }

  Widget _compactHeader() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _headline(),
        const SizedBox(height: 20),
      ],
    );
  }
}

class _CreateForumDialog extends StatefulWidget {
  const _CreateForumDialog();

  @override
  State<_CreateForumDialog> createState() => _CreateForumDialogState();
}

class _CreateForumDialogState extends State<_CreateForumDialog> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  final _bodyController = TextEditingController();

  PlatformFile? _selectedImage;
  Uint8List? _imageBytes;
  bool _submitting = false;
  String? _errorText;

  @override
  void dispose() {
    _titleController.dispose();
    _bodyController.dispose();
    super.dispose();
  }

  Future<void> _pickImage() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        allowMultiple: false,
        withData: true,
      );
      if (result == null || result.files.isEmpty) return;

      final file = result.files.single;
      if (file.bytes == null) {
        // Some platforms may not return bytes; attempt to read as bytes via path not required here
        setState(() {
          _errorText = 'Unable to read image bytes. Please try another image.';
        });
        return;
      }

      setState(() {
        _selectedImage = file;
        _imageBytes = file.bytes;
        _errorText = null;
      });
    } catch (e) {
      setState(() => _errorText = 'Image selection failed: $e');
    }
  }

  Future<void> _submit() async {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      setState(() => _errorText = 'You must be signed in to create a forum.');
      return;
    }
    if (!(_formKey.currentState?.validate() ?? false)) return;

    setState(() {
      _submitting = true;
      _errorText = null;
    });

    String? imageUrl;

    // Try to upload image if provided, but don't fail forum creation if upload fails
    if (_imageBytes != null && _selectedImage != null) {
      try {
        final timestamp = DateTime.now().millisecondsSinceEpoch;
        final safeName = _selectedImage!.name.replaceAll(' ', '_');
        final storagePath = 'forums/${currentUser.uid}/${timestamp}_$safeName';
        final ref = FirebaseStorage.instance.ref().child(storagePath);
        final metadata = SettableMetadata(
            contentType: _selectedImage!.extension == null
                ? 'image/*'
                : 'image/${_selectedImage!.extension!.toLowerCase()}');
        final task = await ref.putData(_imageBytes!, metadata);
        imageUrl = await task.ref.getDownloadURL();
      } catch (uploadError) {
        debugPrint('Image upload failed: $uploadError');
        // Continue without image - don't fail forum creation
      }
    }

    try {
      await FirebaseFirestore.instance.collection('forums').add({
        'title': _titleController.text.trim(),
        'body': _bodyController.text.trim(),
        'imageUrl': imageUrl,
        'createdBy': currentUser.uid,
        'creatorName': currentUser.displayName ?? currentUser.email ?? 'User',
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
        'membersCount': 0,
        'commentsCount': 0,
      });

      if (!mounted) return;
      Navigator.of(context).pop(true);
    } catch (e) {
      setState(() {
        _submitting = false;
        _errorText = 'Failed to create forum: $e';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final inputBorder = OutlineInputBorder(
      borderRadius: BorderRadius.circular(16),
      borderSide: const BorderSide(color: DiscussionForumPage._borderColor),
    );
    final focusedBorder = OutlineInputBorder(
      borderRadius: BorderRadius.circular(16),
      borderSide:
          const BorderSide(color: DiscussionForumPage._primaryBlue, width: 1.4),
    );

    return Dialog(
      insetPadding: const EdgeInsets.symmetric(horizontal: 24, vertical: 24),
      backgroundColor: Colors.white,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: 720),
        child: Padding(
          padding: const EdgeInsets.fromLTRB(24, 24, 24, 20),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  const Icon(Icons.forum_outlined,
                      color: DiscussionForumPage._primaryBlue),
                  const SizedBox(width: 10),
                  const Text(
                    'Create Forum',
                    style: TextStyle(
                      color: DiscussionForumPage._titleColor,
                      fontSize: 18,
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  const Spacer(),
                  IconButton(
                    icon: const Icon(Icons.close,
                        color: DiscussionForumPage._mutedColor),
                    onPressed: _submitting
                        ? null
                        : () => Navigator.of(context).pop(false),
                  ),
                ],
              ),
              const SizedBox(height: 4),
              const Text(
                'Start a new conversation your community can join. Keep it clear and engaging.',
                style: TextStyle(
                    color: DiscussionForumPage._mutedColor, fontSize: 14),
              ),
              const SizedBox(height: 18),
              Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    TextFormField(
                      controller: _titleController,
                      enabled: !_submitting,
                      decoration: InputDecoration(
                        labelText: 'Title',
                        hintText: 'Give your forum a clear title',
                        filled: true,
                        fillColor: Colors.white,
                        contentPadding: const EdgeInsets.symmetric(
                            horizontal: 16, vertical: 16),
                        enabledBorder: inputBorder,
                        focusedBorder: focusedBorder,
                      ),
                      validator: (v) => (v == null || v.trim().isEmpty)
                          ? 'Title is required'
                          : null,
                    ),
                    const SizedBox(height: 14),
                    TextFormField(
                      controller: _bodyController,
                      enabled: !_submitting,
                      maxLines: 6,
                      decoration: InputDecoration(
                        labelText: 'Body',
                        hintText: 'Write the opening message for your forum',
                        filled: true,
                        fillColor: Colors.white,
                        contentPadding: const EdgeInsets.symmetric(
                            horizontal: 16, vertical: 16),
                        enabledBorder: inputBorder,
                        focusedBorder: focusedBorder,
                        alignLabelWithHint: true,
                      ),
                      validator: (v) => (v == null || v.trim().isEmpty)
                          ? 'Body text is required'
                          : null,
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'Image (optional)',
                      style: TextStyle(
                        color: DiscussionForumPage._mutedColor
                            .withValues(alpha: 0.9),
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 8),
                    InkWell(
                      onTap: _submitting ? null : _pickImage,
                      borderRadius: BorderRadius.circular(16),
                      child: Ink(
                        decoration: BoxDecoration(
                          color: const Color(0xFFF9FAFB),
                          borderRadius: BorderRadius.circular(16),
                          border: Border.all(
                              color: DiscussionForumPage._borderColor),
                        ),
                        child: Padding(
                          padding: const EdgeInsets.all(14),
                          child: Row(
                            crossAxisAlignment: CrossAxisAlignment.center,
                            children: [
                              Container(
                                width: 64,
                                height: 64,
                                decoration: BoxDecoration(
                                  color: Colors.white,
                                  border: Border.all(
                                      color: DiscussionForumPage._borderColor),
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: _imageBytes == null
                                    ? const Icon(Icons.image_outlined,
                                        color: DiscussionForumPage._mutedColor)
                                    : ClipRRect(
                                        borderRadius: BorderRadius.circular(12),
                                        child: Image.memory(_imageBytes!,
                                            fit: BoxFit.cover),
                                      ),
                              ),
                              const SizedBox(width: 14),
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      _selectedImage?.name ??
                                          'Click to upload an image',
                                      maxLines: 1,
                                      overflow: TextOverflow.ellipsis,
                                      style: const TextStyle(
                                        color: DiscussionForumPage._titleColor,
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                    const SizedBox(height: 6),
                                    const Text(
                                      'JPG, PNG or GIF ‚Ä¢ up to ~5MB',
                                      style: TextStyle(
                                          color:
                                              DiscussionForumPage._mutedColor,
                                          fontSize: 12),
                                    ),
                                  ],
                                ),
                              ),
                              const SizedBox(width: 12),
                              Container(
                                padding: const EdgeInsets.symmetric(
                                    horizontal: 14, vertical: 10),
                                decoration: BoxDecoration(
                                  color: DiscussionForumPage._primaryBlue,
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: const Row(
                                  mainAxisSize: MainAxisSize.min,
                                  children: [
                                    Icon(Icons.upload_rounded,
                                        size: 18, color: Colors.white),
                                    SizedBox(width: 8),
                                    Text('Upload',
                                        style: TextStyle(
                                            color: Colors.white,
                                            fontWeight: FontWeight.w700)),
                                  ],
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                    if (_errorText != null) ...[
                      const SizedBox(height: 12),
                      Container(
                        width: double.infinity,
                        padding: const EdgeInsets.symmetric(
                            horizontal: 12, vertical: 10),
                        decoration: BoxDecoration(
                          color: const Color(0xFFFFF1F2),
                          borderRadius: BorderRadius.circular(12),
                          border: Border.all(color: const Color(0xFFFCA5A5)),
                        ),
                        child: Row(
                          children: [
                            const Icon(Icons.error_outline, color: Colors.red),
                            const SizedBox(width: 8),
                            Expanded(
                              child: Text(
                                _errorText!,
                                style: const TextStyle(
                                    color: Colors.red, fontSize: 13),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                    const SizedBox(height: 18),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        TextButton(
                          onPressed: _submitting
                              ? null
                              : () => Navigator.of(context).pop(false),
                          child: const Text('Cancel'),
                        ),
                        const SizedBox(width: 8),
                        ElevatedButton.icon(
                          style: ElevatedButton.styleFrom(
                            backgroundColor: DiscussionForumPage._primaryBlue,
                            foregroundColor: Colors.white,
                            shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(14)),
                            elevation: 0,
                            padding: const EdgeInsets.symmetric(
                                horizontal: 16, vertical: 14),
                          ),
                          onPressed: _submitting ? null : _submit,
                          icon: _submitting
                              ? const SizedBox(
                                  width: 16,
                                  height: 16,
                                  child: CircularProgressIndicator(
                                      strokeWidth: 2, color: Colors.white),
                                )
                              : const Icon(Icons.check_circle_outline),
                          label: Text(
                            _submitting ? 'Creating...' : 'Create Forum',
                            style: const TextStyle(fontWeight: FontWeight.w700),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _HeroMetric extends StatelessWidget {
  const _HeroMetric({
    required this.icon,
    required this.label,
    required this.value,
    this.trend,
    this.onUpdate,
    this.isUpdating = false,
  });

  final IconData icon;
  final String label;
  final String value;
  final String? trend;
  final VoidCallback? onUpdate;
  final bool isUpdating;

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 200,
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.14),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: Colors.white.withOpacity(0.18)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(18),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Container(
                  width: 36,
                  height: 36,
                  decoration: BoxDecoration(
                    color: Colors.white.withOpacity(0.18),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: isUpdating
                      ? const Padding(
                          padding: EdgeInsets.all(8),
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            valueColor:
                                AlwaysStoppedAnimation<Color>(Colors.white),
                          ),
                        )
                      : Icon(icon, color: Colors.white, size: 20),
                ),
                const SizedBox(height: 12),
                Text(
                  value,
                  style: const TextStyle(
                      color: Colors.white,
                      fontSize: 20,
                      fontWeight: FontWeight.w800),
                ),
                const SizedBox(height: 4),
                Text(
                  label,
                  style: const TextStyle(
                      color: Colors.white70,
                      fontSize: 12,
                      fontWeight: FontWeight.w600),
                ),
                if (trend != null) ...[
                  const SizedBox(height: 8),
                  Text(
                    trend!,
                    style: const TextStyle(
                        color: Color(0xFFC7D2FE),
                        fontSize: 11,
                        fontWeight: FontWeight.w600),
                  ),
                ],
              ],
            ),
          ),
          if (onUpdate != null)
            Material(
              color: Colors.white.withOpacity(0.08),
              borderRadius:
                  const BorderRadius.vertical(bottom: Radius.circular(20)),
              child: InkWell(
                onTap: isUpdating ? null : onUpdate,
                borderRadius:
                    const BorderRadius.vertical(bottom: Radius.circular(20)),
                child: Container(
                  width: double.infinity,
                  padding:
                      const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.refresh,
                        color: Colors.white.withOpacity(0.9),
                        size: 16,
                      ),
                      const SizedBox(width: 6),
                      Text(
                        'Update Metric',
                        style: TextStyle(
                          color: Colors.white.withOpacity(0.9),
                          fontSize: 12,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }
}

class _HeroSuggestionChip extends StatelessWidget {
  const _HeroSuggestionChip({required this.icon, required this.label});

  final IconData icon;
  final String label;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: () {},
      borderRadius: BorderRadius.circular(18),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 12),
        decoration: BoxDecoration(
          color: Colors.white.withOpacity(0.14),
          borderRadius: BorderRadius.circular(18),
          border: Border.all(color: Colors.white.withOpacity(0.18)),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, color: Colors.white, size: 18),
            const SizedBox(width: 8),
            Text(
              label,
              style: const TextStyle(
                  color: Colors.white,
                  fontSize: 13,
                  fontWeight: FontWeight.w600),
            ),
          ],
        ),
      ),
    );
  }
}

class _MessageSearchAndActions extends StatelessWidget {
  const _MessageSearchAndActions(
      {required this.isCompact, required this.onNewConversation});

  final bool isCompact;
  final VoidCallback onNewConversation;

  @override
  Widget build(BuildContext context) {
    final Widget searchField = SizedBox(
      height: 56,
      child: TextField(
        decoration: InputDecoration(
          hintText: 'Search members, conversations, or keywords',
          hintStyle:
              const TextStyle(color: MessagesPage._mutedColor, fontSize: 14),
          prefixIcon: const Icon(Icons.search, color: MessagesPage._mutedColor),
          suffixIcon: IconButton(
            tooltip: 'Save search',
            onPressed: () {},
            icon: const Icon(Icons.bookmark_outline,
                color: MessagesPage._mutedColor),
          ),
          filled: true,
          fillColor: Colors.white,
          contentPadding:
              const EdgeInsets.symmetric(horizontal: 18, vertical: 18),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(18),
            borderSide: const BorderSide(color: MessagesPage._borderColor),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(18),
            borderSide:
                const BorderSide(color: MessagesPage._focusColor, width: 1.6),
          ),
        ),
      ),
    );

    final List<Widget> quickActions = [
      const _MessageQuickActionButton(icon: Icons.tune, label: 'Filters'),
      const _MessageQuickActionButton(
          icon: Icons.inbox_outlined, label: 'Archive'),
      ElevatedButton.icon(
        onPressed: onNewConversation,
        icon: const Icon(Icons.add_comment_outlined),
        label: const Text('New conversation'),
        style: ElevatedButton.styleFrom(
          backgroundColor: MessagesPage._focusColor,
          foregroundColor: Colors.white,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
          textStyle: const TextStyle(fontWeight: FontWeight.w700, fontSize: 14),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(18)),
          elevation: 0,
        ),
      ),
    ];

    if (isCompact) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          searchField,
          const SizedBox(height: 16),
          Wrap(
            spacing: 12,
            runSpacing: 12,
            children: quickActions,
          ),
        ],
      );
    }

    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Expanded(child: searchField),
        const SizedBox(width: 24),
        Wrap(
          spacing: 12,
          runSpacing: 12,
          alignment: WrapAlignment.end,
          children: quickActions,
        ),
      ],
    );
  }
}

class _MessageQuickActionButton extends StatelessWidget {
  const _MessageQuickActionButton({
    required this.icon,
    required this.label,
    this.isHighlighted = false,
  });

  final IconData icon;
  final String label;
  final bool isHighlighted;

  @override
  Widget build(BuildContext context) {
    final Color foreground =
        isHighlighted ? MessagesPage._focusColor : MessagesPage._titleColor;
    return InkWell(
      onTap: () {},
      borderRadius: BorderRadius.circular(18),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
        decoration: BoxDecoration(
          color: isHighlighted
              ? MessagesPage._focusColor.withOpacity(0.08)
              : Colors.white,
          borderRadius: BorderRadius.circular(18),
          border: Border.all(
              color: isHighlighted
                  ? MessagesPage._focusColor.withOpacity(0.32)
                  : MessagesPage._borderColor),
          boxShadow: isHighlighted
              ? [
                  BoxShadow(
                    color: MessagesPage._focusColor.withOpacity(0.14),
                    blurRadius: 16,
                    offset: const Offset(0, 10),
                  ),
                ]
              : null,
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, color: foreground, size: 18),
            const SizedBox(width: 8),
            Text(
              label,
              style: TextStyle(
                color: foreground,
                fontSize: 13,
                fontWeight: FontWeight.w700,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _FriendProfile {
  const _FriendProfile(
      {required this.id,
      required this.name,
      required this.email,
      this.photoUrl});

  final String id;
  final String name;
  final String email;
  final String? photoUrl;
}

class _FriendRequestRecord {
  const _FriendRequestRecord(
      {required this.requesterId,
      required this.displayName,
      required this.email});

  final String requesterId;
  final String displayName;
  final String email;
}

String _displayNameFromUserDocument(Map<String, dynamic> data) {
  final firstName =
      data['first_name'] as String? ?? data['firstName'] as String? ?? '';
  final lastName =
      data['last_name'] as String? ?? data['lastName'] as String? ?? '';
  final username = data['username'] as String? ?? '';
  final displayName = data['displayName'] as String? ?? '';
  final email = data['email'] as String? ?? '';
  if (firstName.isNotEmpty || lastName.isNotEmpty) {
    return '$firstName $lastName'.trim();
  }
  if (displayName.isNotEmpty) return displayName;
  if (username.isNotEmpty) return username;
  if (email.isNotEmpty) return email.split('@').first;
  return 'Member';
}

Future<List<_FriendProfile>> _fetchProfilesByIds(List<String> ids) async {
  if (ids.isEmpty) return const [];
  final List<_FriendProfile> results = [];
  const int chunkSize = 10;
  for (var i = 0; i < ids.length; i += chunkSize) {
    final chunk = ids.sublist(i, math.min(i + chunkSize, ids.length));
    final query = await FirebaseFirestore.instance
        .collection('users')
        .where(FieldPath.documentId, whereIn: chunk)
        .get();
    for (final doc in query.docs) {
      final data = doc.data();
      results.add(
        _FriendProfile(
          id: doc.id,
          name: _displayNameFromUserDocument(data),
          email: (data['email'] as String?) ?? '',
          photoUrl: data['photoUrl'] as String?,
        ),
      );
    }
  }
  results.sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));
  return results;
}

Future<List<_FriendProfile>> _fetchFriendsForUser(String userId) async {
  final userDoc =
      await FirebaseFirestore.instance.collection('users').doc(userId).get();
  final data = userDoc.data() ?? <String, dynamic>{};
  final rawFriends = data['friends'];
  final List<String> friendIds =
      rawFriends is List ? rawFriends.whereType<String>().toList() : const [];
  return _fetchProfilesByIds(friendIds);
}

class NewConversationSheet extends StatefulWidget {
  const NewConversationSheet(
      {super.key, required this.onChatOpened, required this.onCreateGroup});

  final ValueChanged<String> onChatOpened;
  final Future<String?> Function() onCreateGroup;

  @override
  State<NewConversationSheet> createState() => _NewConversationSheetState();
}

class _NewConversationSheetState extends State<NewConversationSheet> {
  final ValueNotifier<bool> _isLoading = ValueNotifier<bool>(true);
  final ValueNotifier<bool> _isStartingConversation =
      ValueNotifier<bool>(false);
  List<_FriendProfile> _friends = const [];
  String? _error;

  @override
  void initState() {
    super.initState();
    unawaited(_loadFriends());
  }

  Future<void> _loadFriends() async {
    try {
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) {
        setState(() {
          _error = 'You need to be signed in to start a conversation.';
          _friends = const [];
        });
        return;
      }

      final friends = await _fetchFriendsForUser(currentUser.uid);
      setState(() {
        _friends = friends;
      });
    } catch (e) {
      setState(() {
        _error = 'Unable to load friends right now. Please try again.';
      });
    } finally {
      _isLoading.value = false;
    }
  }

  Future<void> _handleFriendTap(_FriendProfile friend) async {
    if (_isStartingConversation.value) return;
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content: Text('Please sign in to start a conversation.')),
      );
      return;
    }

    _isStartingConversation.value = true;
    try {
      final chatId = await _getOrCreateDirectChat(currentUser.uid, friend);
      widget.onChatOpened(chatId);
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to start conversation: $e')),
        );
      }
    } finally {
      _isStartingConversation.value = false;
    }
  }

  Future<String> _getOrCreateDirectChat(
      String currentUserId, _FriendProfile friend) async {
    final sortedMembers = [currentUserId, friend.id]..sort();
    final memberHash = sortedMembers.join('_');

    final existing = await FirebaseFirestore.instance
        .collection('chats')
        .where('memberHash', isEqualTo: memberHash)
        .limit(1)
        .get();

    if (existing.docs.isNotEmpty) {
      return existing.docs.first.id;
    }

    final currentUserDoc = await FirebaseFirestore.instance
        .collection('users')
        .doc(currentUserId)
        .get();
    final currentData = currentUserDoc.data() ?? <String, dynamic>{};
    final currentName = _displayNameFromUserDocument(currentData);

    final docRef = FirebaseFirestore.instance.collection('chats').doc();
    final now = FieldValue.serverTimestamp();
    final participantLabels = {
      currentUserId: friend.name,
      friend.id: currentName,
    };

    await docRef.set({
      'title': friend.name,
      'isGroup': false,
      'type': 'direct',
      'members': sortedMembers,
      'memberHash': memberHash,
      'createdBy': currentUserId,
      'createdAt': now,
      'updatedAt': now,
      'unreadCount': 0,
      'memberPrivileges': {
        currentUserId: 'owner',
        friend.id: 'member',
      },
      'participantLabels': participantLabels,
    });

    return docRef.id;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Align(
        alignment: Alignment.bottomCenter,
        child: Material(
          color: Colors.white,
          borderRadius: BorderRadius.circular(28),
          elevation: 12,
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 640, maxHeight: 620),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(28),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    width: double.infinity,
                    padding: const EdgeInsets.fromLTRB(24, 24, 24, 16),
                    decoration: const BoxDecoration(
                      gradient: LinearGradient(
                        colors: [Color(0xFF1E3A8A), Color(0xFF2563EB)],
                        begin: Alignment.topLeft,
                        end: Alignment.bottomRight,
                      ),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            const Icon(Icons.chat_bubble_outline,
                                color: Colors.white, size: 24),
                            const SizedBox(width: 12),
                            Text(
                              'Start a New Conversation',
                              style: theme.textTheme.titleLarge?.copyWith(
                                  color: Colors.white,
                                  fontWeight: FontWeight.w800),
                            ),
                          ],
                        ),
                        const SizedBox(height: 8),
                        const Text(
                          'Choose a friend to open a direct chat or spin up an inspiring group.',
                          style: TextStyle(color: Colors.white70, fontSize: 13),
                        ),
                        const SizedBox(height: 16),
                        ElevatedButton.icon(
                          onPressed: () async {
                            final result = await widget.onCreateGroup();
                            if (result != null) {
                              widget.onChatOpened(result);
                            }
                          },
                          icon: const Icon(Icons.group_add_outlined),
                          label: const Text('New Group'),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.white,
                            foregroundColor: const Color(0xFF1E3A8A),
                            shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(16)),
                            padding: const EdgeInsets.symmetric(
                                horizontal: 20, vertical: 14),
                            textStyle: const TextStyle(
                                fontWeight: FontWeight.w700, fontSize: 14),
                            elevation: 0,
                          ),
                        ),
                      ],
                    ),
                  ),
                  Expanded(
                    child: ValueListenableBuilder<bool>(
                      valueListenable: _isLoading,
                      builder: (context, isLoading, _) {
                        if (isLoading) {
                          return const Center(
                            child: Padding(
                              padding: EdgeInsets.all(40),
                              child: CircularProgressIndicator(),
                            ),
                          );
                        }

                        if (_error != null) {
                          return _buildMessageState(
                            icon: Icons.error_outline,
                            headline: 'Something went wrong',
                            subtitle: _error!,
                          );
                        }

                        if (_friends.isEmpty) {
                          return _buildMessageState(
                            icon: Icons.person_add_alt,
                            headline: 'No friends yet',
                            subtitle:
                                'Send a few friend requests to start conversations.',
                          );
                        }

                        return ValueListenableBuilder<bool>(
                          valueListenable: _isStartingConversation,
                          builder: (context, isStarting, _) {
                            return ListView.separated(
                              padding:
                                  const EdgeInsets.fromLTRB(24, 24, 24, 32),
                              itemCount: _friends.length,
                              separatorBuilder: (_, __) =>
                                  const SizedBox(height: 12),
                              itemBuilder: (context, index) {
                                final friend = _friends[index];
                                return _FriendCard(
                                  friend: friend,
                                  isBusy: isStarting,
                                  onTap: () => _handleFriendTap(friend),
                                );
                              },
                            );
                          },
                        );
                      },
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildMessageState(
      {required IconData icon,
      required String headline,
      required String subtitle}) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, color: MessagesPage._focusColor, size: 36),
            const SizedBox(height: 16),
            Text(
              headline,
              style: const TextStyle(
                color: MessagesPage._titleColor,
                fontSize: 18,
                fontWeight: FontWeight.w800,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              subtitle,
              style: const TextStyle(
                  color: MessagesPage._mutedColor, fontSize: 13),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    _isLoading.dispose();
    _isStartingConversation.dispose();
    super.dispose();
  }
}

class _FriendCard extends StatelessWidget {
  const _FriendCard(
      {required this.friend, required this.onTap, required this.isBusy});

  final _FriendProfile friend;
  final VoidCallback onTap;
  final bool isBusy;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: isBusy ? null : onTap,
      borderRadius: BorderRadius.circular(18),
      child: Container(
        padding: const EdgeInsets.all(18),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(18),
          border: Border.all(color: MessagesPage._borderColor),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.04),
              blurRadius: 12,
              offset: const Offset(0, 8),
            ),
          ],
        ),
        child: Row(
          children: [
            _FriendAvatar(name: friend.name, photoUrl: friend.photoUrl),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    friend.name,
                    style: const TextStyle(
                      color: MessagesPage._titleColor,
                      fontWeight: FontWeight.w800,
                      fontSize: 15,
                    ),
                  ),
                  if (friend.email.isNotEmpty) ...[
                    const SizedBox(height: 4),
                    Text(
                      friend.email,
                      style: const TextStyle(
                          color: MessagesPage._mutedColor, fontSize: 12),
                    ),
                  ],
                ],
              ),
            ),
            if (isBusy)
              const SizedBox(
                width: 22,
                height: 22,
                child: CircularProgressIndicator(strokeWidth: 2.5),
              )
            else
              Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
                decoration: BoxDecoration(
                  color: MessagesPage._focusColor.withOpacity(0.08),
                  borderRadius: BorderRadius.circular(999),
                  border: Border.all(
                      color: MessagesPage._focusColor.withOpacity(0.3)),
                ),
                child: const Text(
                  'Message',
                  style: TextStyle(
                      color: MessagesPage._focusColor,
                      fontWeight: FontWeight.w700,
                      fontSize: 12),
                ),
              ),
          ],
        ),
      ),
    );
  }
}

class _FriendAvatar extends StatelessWidget {
  const _FriendAvatar({required this.name, this.photoUrl});

  final String name;
  final String? photoUrl;

  @override
  Widget build(BuildContext context) {
    if (photoUrl != null && photoUrl!.isNotEmpty) {
      return ClipRRect(
        borderRadius: BorderRadius.circular(16),
        child: Image.network(
          photoUrl!,
          width: 48,
          height: 48,
          fit: BoxFit.cover,
        ),
      );
    }

    final initials = name.trim().isEmpty
        ? '?'
        : name
            .trim()
            .split(RegExp(r'\s+'))
            .take(2)
            .map((p) => p.isNotEmpty ? p[0] : '')
            .join()
            .toUpperCase();

    return Container(
      width: 48,
      height: 48,
      decoration: BoxDecoration(
        gradient: const LinearGradient(
          colors: [Color(0xFF2563EB), Color(0xFF1E3A8A)],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(16),
      ),
      alignment: Alignment.center,
      child: Text(
        initials,
        style:
            const TextStyle(color: Colors.white, fontWeight: FontWeight.w800),
      ),
    );
  }
}

class _MessageSectionCard extends StatelessWidget {
  const _MessageSectionCard({
    super.key,
    required this.icon,
    required this.title,
    required this.child,
    this.subtitle,
  });

  final IconData icon;
  final String title;
  final String? subtitle;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.fromLTRB(28, 24, 28, 24),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(22),
        border: Border.all(color: MessagesPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 18,
            offset: const Offset(0, 12),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                width: 42,
                height: 42,
                decoration: BoxDecoration(
                  color: MessagesPage._focusColor.withOpacity(0.08),
                  borderRadius: BorderRadius.circular(14),
                ),
                child: Icon(icon, color: MessagesPage._focusColor, size: 22),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: const TextStyle(
                        color: MessagesPage._titleColor,
                        fontSize: 18,
                        fontWeight: FontWeight.w800,
                        letterSpacing: -0.2,
                      ),
                    ),
                    if (subtitle != null) ...[
                      const SizedBox(height: 6),
                      Text(
                        subtitle!,
                        style: const TextStyle(
                            color: MessagesPage._mutedColor,
                            fontSize: 13,
                            height: 1.4,
                            fontWeight: FontWeight.w500),
                      ),
                    ],
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 22),
          child,
        ],
      ),
    );
  }
}

class ConversationPanel extends StatelessWidget {
  const ConversationPanel({super.key, required this.chatId});

  final String? chatId;

  @override
  Widget build(BuildContext context) {
    if (chatId == null) {
      return const SizedBox.shrink();
    }

    return StreamBuilder<DocumentSnapshot<Map<String, dynamic>>>(
      stream: FirebaseFirestore.instance
          .collection('chats')
          .doc(chatId)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const _ConversationLoading();
        }

        if (!snapshot.hasData || !snapshot.data!.exists) {
          return const _ConversationPlaceholder(
            headline: 'Conversation not found',
            subtitle: 'It may have been removed or you no longer have access.',
            showChips: false,
          );
        }

        final data = snapshot.data!.data() ?? <String, dynamic>{};
        return _ConversationDetail(chatId: snapshot.data!.id, data: data);
      },
    );
  }
}

class _ConversationLoading extends StatelessWidget {
  const _ConversationLoading();

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      constraints: const BoxConstraints(minHeight: 320),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: MessagesPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 18,
            offset: const Offset(0, 14),
          ),
        ],
      ),
      alignment: Alignment.center,
      padding: const EdgeInsets.all(48),
      child: const CircularProgressIndicator(),
    );
  }
}

class _ConversationPlaceholder extends StatelessWidget {
  const _ConversationPlaceholder(
      {this.headline, this.subtitle, this.showChips = true});

  final String? headline;
  final String? subtitle;
  final bool showChips;

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      constraints: const BoxConstraints(minHeight: 300),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: MessagesPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 16,
            offset: const Offset(0, 12),
          ),
        ],
      ),
      padding: const EdgeInsets.fromLTRB(28, 26, 28, 26),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Container(
            width: 72,
            height: 72,
            decoration: BoxDecoration(
              color: MessagesPage._focusColor.withOpacity(0.08),
              borderRadius: BorderRadius.circular(22),
              border: Border.all(color: MessagesPage._borderColor),
            ),
            child: const Icon(Icons.chat_bubble_outline,
                color: MessagesPage._focusColor, size: 30),
          ),
          const SizedBox(height: 16),
          Text(
            headline ?? 'Select a conversation to get started',
            style: const TextStyle(
                color: MessagesPage._titleColor,
                fontSize: 15,
                fontWeight: FontWeight.w700),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 6),
          SizedBox(
            width: 320,
            child: Text(
              subtitle ??
                  'Jump back into ongoing threads or launch a new coach/member touchpoint below.',
              textAlign: TextAlign.center,
              style: const TextStyle(
                  color: MessagesPage._mutedColor, fontSize: 12, height: 1.4),
            ),
          ),
          if (showChips) ...[
            const SizedBox(height: 18),
            Wrap(
              spacing: 10,
              runSpacing: 10,
              alignment: WrapAlignment.center,
              children: const [
                _InboxSparkChip(
                    icon: Icons.play_circle_outline,
                    label: 'Preview onboarding flow'),
                _InboxSparkChip(
                    icon: Icons.calendar_today_outlined,
                    label: 'Schedule check-in'),
                _InboxSparkChip(
                    icon: Icons.lightbulb_outline,
                    label: 'Surface key insights'),
              ],
            ),
          ],
        ],
      ),
    );
  }
}

class _ConversationDetail extends StatefulWidget {
  const _ConversationDetail({required this.chatId, required this.data});

  final String chatId;
  final Map<String, dynamic> data;

  @override
  State<_ConversationDetail> createState() => _ConversationDetailState();
}

class _ConversationDetailState extends State<_ConversationDetail> {
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _messagesController = ScrollController();
  bool _isSending = false;
  int _lastMessageCount = 0;
  String? _cachedDisplayName;
  List<PlatformFile> _selectedFiles = [];
  bool _isUploadingMedia = false;

  List<String> get _members =>
      (widget.data['members'] as List?)?.whereType<String>().toList() ??
      const [];

  bool get _isGroup {
    final flag = widget.data['isGroup'];
    if (flag is bool) return flag;
    if (_members.length > 2) return true;
    return (widget.data['type'] as String?)?.toLowerCase() == 'group';
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) => _markAsRead());
  }

  @override
  void didUpdateWidget(covariant _ConversationDetail oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.chatId != widget.chatId) {
      _messageController.clear();
      _cachedDisplayName = null;
      WidgetsBinding.instance.addPostFrameCallback((_) => _markAsRead());
    }
  }

  @override
  void dispose() {
    _messageController.dispose();
    _messagesController.dispose();
    super.dispose();
  }

  Future<void> _pickMedia() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: [
          'jpg',
          'jpeg',
          'png',
          'gif',
          'mp4',
          'mov',
          'pdf',
          'doc',
          'docx'
        ],
        allowMultiple: true,
        withData: true,
      );
      if (result != null && result.files.isNotEmpty) {
        setState(() {
          _selectedFiles = [
            ..._selectedFiles,
            ...result.files.where((f) => f.bytes != null)
          ];
        });
      }
    } catch (e) {
      debugPrint('Error picking media: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to pick media: $e')),
        );
      }
    }
  }

  void _removeSelectedFile(int index) {
    setState(() {
      _selectedFiles = List.from(_selectedFiles)..removeAt(index);
    });
  }

  String _getMimeType(String extension) {
    switch (extension.toLowerCase()) {
      case 'jpg':
      case 'jpeg':
        return 'image/jpeg';
      case 'png':
        return 'image/png';
      case 'gif':
        return 'image/gif';
      case 'mp4':
        return 'video/mp4';
      case 'mov':
        return 'video/quicktime';
      case 'pdf':
        return 'application/pdf';
      case 'doc':
        return 'application/msword';
      case 'docx':
        return 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
      default:
        return 'application/octet-stream';
    }
  }

  bool _isImageFile(String? url) {
    if (url == null) return false;
    final lower = url.toLowerCase();
    return lower.contains('.jpg') ||
        lower.contains('.jpeg') ||
        lower.contains('.png') ||
        lower.contains('.gif');
  }

  bool _isVideoFile(String? url) {
    if (url == null) return false;
    final lower = url.toLowerCase();
    return lower.contains('.mp4') || lower.contains('.mov');
  }

  Future<void> _markAsRead() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    try {
      await FirebaseFirestore.instance
          .collection('chats')
          .doc(widget.chatId)
          .update({
        'unreadBy': FieldValue.arrayRemove([uid]),
        'unreadCounts.$uid': 0,
        'readReceipts.$uid': FieldValue.serverTimestamp(),
      });
    } catch (_) {
      // Ignore failures; read state is best-effort.
    }
  }

  Future<String> _resolveCurrentUserDisplayName() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      throw StateError('Must be signed in to send messages.');
    }
    if (_cachedDisplayName != null && _cachedDisplayName!.trim().isNotEmpty) {
      return _cachedDisplayName!;
    }
    final userDoc = await FirebaseFirestore.instance
        .collection('users')
        .doc(user.uid)
        .get();
    final data = userDoc.data();
    final displayName =
        data == null ? null : _displayNameFromUserDocument(data);
    final fallback = displayName?.trim().isNotEmpty == true
        ? displayName!
        : user.displayName?.trim().isNotEmpty == true
            ? user.displayName!.trim()
            : user.email?.split('@').first ?? 'Member';
    _cachedDisplayName = fallback;
    return fallback;
  }

  Future<void> _sendMessage() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please sign in to send messages.')),
      );
      return;
    }
    final text = _messageController.text.trim();
    final hasMedia = _selectedFiles.isNotEmpty;
    if (text.isEmpty && !hasMedia || _isSending) return;

    setState(() {
      _isSending = true;
      _isUploadingMedia = hasMedia;
    });
    try {
      final senderName = await _resolveCurrentUserDisplayName();
      final chatRef =
          FirebaseFirestore.instance.collection('chats').doc(widget.chatId);
      final now = FieldValue.serverTimestamp();

      // Upload media files if any
      List<Map<String, String>> mediaUrls = [];
      if (hasMedia) {
        for (final file in _selectedFiles) {
          if (file.bytes == null) continue;
          final ext = file.extension ?? 'bin';
          final fileName =
              'chat_media/${widget.chatId}/${DateTime.now().millisecondsSinceEpoch}_${file.name}';
          final ref = FirebaseStorage.instance.ref().child(fileName);
          final mimeType = _getMimeType(ext);
          await ref.putData(
              file.bytes!, SettableMetadata(contentType: mimeType));
          final url = await ref.getDownloadURL();
          mediaUrls.add({
            'url': url,
            'name': file.name,
            'type': mimeType,
          });
          debugPrint('Uploaded media: $url');
        }
      }

      final messageData = <String, dynamic>{
        'text': text,
        'senderId': user.uid,
        'senderName': senderName,
        'timestamp': now,
      };
      if (mediaUrls.isNotEmpty) {
        messageData['media'] = mediaUrls;
      }

      await chatRef.collection('messages').add(messageData);

      final lastMessageText = mediaUrls.isNotEmpty && text.isEmpty
          ? 'üìé Sent ${mediaUrls.length} attachment${mediaUrls.length > 1 ? 's' : ''}'
          : text;
      final otherMembers = _members.where((id) => id != user.uid).toList();
      final updatePayload = <String, dynamic>{
        'lastMessage': {
          'text': lastMessageText,
          'senderId': user.uid,
          'senderName': senderName,
          'timestamp': now,
        },
        'updatedAt': now,
        'unreadBy': otherMembers.isEmpty
            ? FieldValue.delete()
            : FieldValue.arrayUnion(otherMembers),
        'unreadCounts.${user.uid}': 0,
        'readReceipts.${user.uid}': now,
      };
      for (final member in otherMembers) {
        updatePayload['unreadCounts.$member'] = FieldValue.increment(1);
      }

      await chatRef.set(updatePayload, SetOptions(merge: true));

      _messageController.clear();
      setState(() => _selectedFiles = []);
      _scrollToBottom();
    } catch (e) {
      debugPrint('Error sending message: $e');
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to send message: $e')),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSending = false;
          _isUploadingMedia = false;
        });
      }
    }
  }

  void _scrollToBottom() {
    if (!_messagesController.hasClients) return;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!_messagesController.hasClients) return;
      _messagesController.animateTo(
        _messagesController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 240),
        curve: Curves.easeOut,
      );
    });
  }

  @override
  Widget build(BuildContext context) {
    final rawPhoto = widget.data['groupPhotoUrl'];
    final String? photoUrl = rawPhoto is String && rawPhoto.trim().isNotEmpty
        ? rawPhoto.trim()
        : null;
    final theme = Theme.of(context);
    final members = _members;

    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: MessagesPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 18,
            offset: const Offset(0, 14),
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: double.infinity,
            padding: const EdgeInsets.fromLTRB(28, 26, 28, 20),
            decoration: const BoxDecoration(
              gradient: LinearGradient(
                colors: [Color(0xFF1D4ED8), Color(0xFF1E3A8A)],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
              borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
            ),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _ConversationAvatar(
                  isGroup: _isGroup,
                  title: _resolveTitleForDetail(),
                  photoUrl: photoUrl,
                  memberCount: members.length,
                ),
                const SizedBox(width: 18),
                Expanded(
                  child: FutureBuilder<List<_FriendProfile>>(
                    future: _fetchProfilesByIds(members),
                    builder: (context, snapshot) {
                      final profiles = snapshot.data ?? const [];
                      final secondary = _buildSecondaryLine(profiles);
                      return Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            _resolveTitleForDetail(),
                            style: theme.textTheme.headlineSmall?.copyWith(
                                    color: Colors.white,
                                    fontWeight: FontWeight.w800) ??
                                const TextStyle(
                                    color: Colors.white,
                                    fontSize: 20,
                                    fontWeight: FontWeight.w800),
                          ),
                          const SizedBox(height: 6),
                          Text(
                            secondary,
                            style: const TextStyle(
                                color: Colors.white70, fontSize: 13),
                          ),
                          const SizedBox(height: 12),
                          Wrap(
                            spacing: 10,
                            runSpacing: 10,
                            children: [
                              _ConversationStatChip(
                                icon: Icons.group_outlined,
                                label:
                                    '${members.length} member${members.length == 1 ? '' : 's'}',
                              ),
                              _ConversationStatChip(
                                icon: Icons.schedule_outlined,
                                label: _formatTimestamp(
                                    widget.data['updatedAt'] ??
                                        widget.data['createdAt']),
                              ),
                              if (!_isGroup)
                                _ConversationStatChip(
                                  icon: Icons.shield_outlined,
                                  label: 'Direct message',
                                )
                              else
                                _ConversationStatChip(
                                  icon: Icons.workspace_premium_outlined,
                                  label: 'Group space',
                                ),
                            ],
                          ),
                        ],
                      );
                    },
                  ),
                ),
                const SizedBox(width: 12),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: [
                    ElevatedButton.icon(
                      onPressed: () => _openMembersSheet(context),
                      icon: const Icon(Icons.people_alt_outlined, size: 18),
                      label: const Text('View members'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.white,
                        foregroundColor: const Color(0xFF1E3A8A),
                        elevation: 0,
                        shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(14)),
                        padding: const EdgeInsets.symmetric(
                            horizontal: 18, vertical: 12),
                        textStyle: const TextStyle(
                            fontWeight: FontWeight.w700, fontSize: 13),
                      ),
                    ),
                    const SizedBox(height: 10),
                    OutlinedButton.icon(
                      onPressed: () => _scrollToBottom(),
                      icon: const Icon(Icons.message_outlined, size: 18),
                      label: const Text('Jump to latest'),
                      style: OutlinedButton.styleFrom(
                        foregroundColor: Colors.white,
                        side: const BorderSide(color: Colors.white70),
                        shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(14)),
                        padding: const EdgeInsets.symmetric(
                            horizontal: 18, vertical: 12),
                        textStyle: const TextStyle(
                            fontWeight: FontWeight.w700, fontSize: 13),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
          Padding(
            padding: const EdgeInsets.fromLTRB(28, 24, 28, 28),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(18),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(18),
                    border: Border.all(color: MessagesPage._borderColor),
                  ),
                  child: Column(
                    children: [
                      SizedBox(
                        height: 360,
                        child: ClipRRect(
                          borderRadius: BorderRadius.circular(12),
                          child: _buildMessagesList(),
                        ),
                      ),
                      const SizedBox(height: 16),
                      _buildComposer(),
                    ],
                  ),
                ),
                const SizedBox(height: 24),
                const Text(
                  'Smart Suggestions',
                  style: TextStyle(
                      color: MessagesPage._titleColor,
                      fontSize: 15,
                      fontWeight: FontWeight.w700),
                ),
                const SizedBox(height: 12),
                Wrap(
                  spacing: 10,
                  runSpacing: 10,
                  children: const [
                    _ConversationTaskPill(label: 'Share resources'),
                    _ConversationTaskPill(label: 'Plan next session'),
                    _ConversationTaskPill(label: 'Drop a quick win'),
                  ],
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildComposer() {
    final theme = Theme.of(context);
    final canSend = !_isSending &&
        (_messageController.text.trim().isNotEmpty ||
            _selectedFiles.isNotEmpty);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Selected files preview
        if (_selectedFiles.isNotEmpty) ...[
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: MessagesPage._chipInactive,
              borderRadius: BorderRadius.circular(12),
            ),
            child: Wrap(
              spacing: 8,
              runSpacing: 8,
              children: _selectedFiles.asMap().entries.map((entry) {
                final index = entry.key;
                final file = entry.value;
                final isImage = ['jpg', 'jpeg', 'png', 'gif']
                    .contains(file.extension?.toLowerCase());
                return Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: MessagesPage._borderColor),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      if (isImage && file.bytes != null) ...[
                        ClipRRect(
                          borderRadius: BorderRadius.circular(4),
                          child: Image.memory(file.bytes!,
                              width: 32, height: 32, fit: BoxFit.cover),
                        ),
                        const SizedBox(width: 8),
                      ] else ...[
                        Icon(
                          _getFileIcon(file.extension),
                          size: 18,
                          color: MessagesPage._focusColor,
                        ),
                        const SizedBox(width: 6),
                      ],
                      ConstrainedBox(
                        constraints: const BoxConstraints(maxWidth: 100),
                        child: Text(
                          file.name,
                          style: const TextStyle(
                              fontSize: 12, fontWeight: FontWeight.w500),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                      const SizedBox(width: 6),
                      InkWell(
                        onTap: () => _removeSelectedFile(index),
                        borderRadius: BorderRadius.circular(10),
                        child: const Icon(Icons.close,
                            size: 16, color: Colors.red),
                      ),
                    ],
                  ),
                );
              }).toList(),
            ),
          ),
          const SizedBox(height: 12),
        ],
        if (_isUploadingMedia)
          Padding(
            padding: const EdgeInsets.only(bottom: 8),
            child: Row(
              children: [
                const SizedBox(
                    width: 14,
                    height: 14,
                    child: CircularProgressIndicator(strokeWidth: 2)),
                const SizedBox(width: 8),
                Text('Uploading media...',
                    style: TextStyle(
                        fontSize: 12, color: MessagesPage._mutedColor)),
              ],
            ),
          ),
        Row(
          children: [
            // Attachment button
            Material(
              color: MessagesPage._chipInactive,
              borderRadius: BorderRadius.circular(14),
              child: InkWell(
                onTap: _isSending ? null : _pickMedia,
                borderRadius: BorderRadius.circular(14),
                child: Container(
                  width: 52,
                  height: 52,
                  alignment: Alignment.center,
                  child: Icon(
                    Icons.attach_file_rounded,
                    size: 22,
                    color: _isSending
                        ? MessagesPage._mutedColor
                        : MessagesPage._focusColor,
                  ),
                ),
              ),
            ),
            const SizedBox(width: 10),
            Expanded(
              child: TextField(
                controller: _messageController,
                minLines: 1,
                maxLines: 4,
                decoration: InputDecoration(
                  hintText: 'Write a message...',
                  filled: true,
                  fillColor: MessagesPage._chipInactive,
                  contentPadding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(14),
                    borderSide: BorderSide.none,
                  ),
                ),
                onChanged: (_) => setState(() {}),
                onSubmitted: (_) => _sendMessage(),
              ),
            ),
            const SizedBox(width: 10),
            SizedBox(
              height: 52,
              width: 52,
              child: ElevatedButton(
                onPressed: canSend ? _sendMessage : null,
                style: ElevatedButton.styleFrom(
                  backgroundColor: MessagesPage._focusColor,
                  foregroundColor: Colors.white,
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(14)),
                  padding: EdgeInsets.zero,
                ),
                child: _isSending
                    ? const SizedBox(
                        width: 18,
                        height: 18,
                        child: CircularProgressIndicator(
                            color: Colors.white, strokeWidth: 2),
                      )
                    : const Icon(Icons.send_rounded, size: 22),
              ),
            ),
          ],
        ),
      ],
    );
  }

  IconData _getFileIcon(String? extension) {
    switch (extension?.toLowerCase()) {
      case 'pdf':
        return Icons.picture_as_pdf;
      case 'doc':
      case 'docx':
        return Icons.description;
      case 'mp4':
      case 'mov':
        return Icons.video_file;
      case 'jpg':
      case 'jpeg':
      case 'png':
      case 'gif':
        return Icons.image;
      default:
        return Icons.insert_drive_file;
    }
  }

  Widget _buildMessagesList() {
    final stream = FirebaseFirestore.instance
        .collection('chats')
        .doc(widget.chatId)
        .collection('messages')
        .orderBy('timestamp')
        .snapshots();

    return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
      stream: stream,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }

        if (snapshot.hasError) {
          return Center(
            child: Text(
              'Unable to load messages: ${snapshot.error}',
              style: const TextStyle(color: MessagesPage._mutedColor),
              textAlign: TextAlign.center,
            ),
          );
        }

        final docs = snapshot.data?.docs ?? const [];
        if (_lastMessageCount != docs.length) {
          _lastMessageCount = docs.length;
          WidgetsBinding.instance
              .addPostFrameCallback((_) => _scrollToBottom());
        }

        if (docs.isEmpty) {
          return const Center(
            child: Text(
              'Start the conversation with a friendly hello.',
              style: TextStyle(color: MessagesPage._mutedColor, fontSize: 13),
            ),
          );
        }

        final currentUid = FirebaseAuth.instance.currentUser?.uid;
        return ListView.builder(
          controller: _messagesController,
          padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 8),
          itemCount: docs.length,
          itemBuilder: (context, index) {
            final data = docs[index].data();
            final senderId = data['senderId'] as String?;
            final text = data['text'] as String? ?? '';
            final senderName = data['senderName'] as String?;
            final timestamp = _parseTimestamp(data['timestamp']);
            final media = data['media'] as List<dynamic>?;
            final isMine = senderId != null && senderId == currentUid;
            return Padding(
              padding: const EdgeInsets.symmetric(vertical: 4),
              child: _MessageBubble(
                text: text,
                senderName: senderName,
                timestamp: timestamp,
                isMine: isMine,
                showSender: _isGroup && !isMine,
                media: media,
              ),
            );
          },
        );
      },
    );
  }

  String _resolveTitleForDetail() {
    final participantLabels = widget.data['participantLabels'];
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (participantLabels is Map && uid != null) {
      final label = participantLabels[uid];
      if (label is String && label.trim().isNotEmpty) {
        return label.trim();
      }
    }
    for (final key in const ['groupName', 'title', 'name']) {
      final v = widget.data[key];
      if (v is String && v.trim().isNotEmpty) return v.trim();
    }
    return _isGroup ? 'Group Conversation' : 'Direct Conversation';
  }

  String _buildSecondaryLine(List<_FriendProfile> profiles) {
    if (profiles.isEmpty) {
      return 'Gather the team and kickstart the discussion.';
    }
    if (!_isGroup) {
      final currentUserId = FirebaseAuth.instance.currentUser?.uid;
      final peer = profiles.firstWhere(
        (p) => p.id != currentUserId,
        orElse: () => profiles.first,
      );
      return 'Direct conversation with ${peer.name}';
    }
    return profiles.map((p) => p.name).take(4).join(', ');
  }

  static String _formatTimestamp(dynamic value) {
    final dt = _parseTimestamp(value) ?? DateTime.now();
    final now = DateTime.now();
    final difference = now.difference(dt);
    if (difference.inMinutes < 1) return 'Updated moments ago';
    if (difference.inHours < 1) return 'Active ${difference.inMinutes} min ago';
    if (difference.inDays < 1) return 'Updated ${difference.inHours}h ago';
    if (difference.inDays == 1) return 'Updated yesterday';
    return 'Updated ${difference.inDays}d ago';
  }

  static DateTime? _parseTimestamp(dynamic value) {
    if (value is Timestamp) return value.toDate();
    if (value is DateTime) return value;
    if (value is num) return DateTime.fromMillisecondsSinceEpoch(value.toInt());
    if (value is String) return DateTime.tryParse(value);
    return null;
  }

  Future<void> _openMembersSheet(BuildContext context) async {
    await showModalBottomSheet<void>(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) =>
          _GroupMembersSheet(chatId: widget.chatId, chatData: widget.data),
    );
  }
}

class _ConversationAvatar extends StatelessWidget {
  const _ConversationAvatar(
      {required this.isGroup,
      required this.title,
      this.photoUrl,
      required this.memberCount});

  final bool isGroup;
  final String title;
  final String? photoUrl;
  final int memberCount;

  @override
  Widget build(BuildContext context) {
    final borderRadius = BorderRadius.circular(22);
    if (photoUrl != null && photoUrl!.isNotEmpty) {
      return ClipRRect(
        borderRadius: borderRadius,
        child: Image.network(
          photoUrl!,
          width: 96,
          height: 96,
          fit: BoxFit.cover,
        ),
      );
    }

    final initials = title.trim().isEmpty
        ? (isGroup ? 'GR' : 'DM')
        : title
            .trim()
            .split(RegExp(r'\s+'))
            .take(isGroup ? 2 : 1)
            .map((word) => word.isNotEmpty ? word[0] : '')
            .join()
            .toUpperCase();

    return Container(
      width: 96,
      height: 96,
      decoration: BoxDecoration(
        gradient: isGroup
            ? const LinearGradient(
                colors: [Color(0xFF38BDF8), Color(0xFF2563EB)],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight)
            : const LinearGradient(
                colors: [Color(0xFF6EE7B7), Color(0xFF3B82F6)],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight),
        borderRadius: borderRadius,
      ),
      alignment: Alignment.center,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(
            initials,
            style: const TextStyle(
                color: Colors.white, fontWeight: FontWeight.w800, fontSize: 24),
          ),
          const SizedBox(height: 6),
          Text(
            isGroup ? '$memberCount members' : 'Direct',
            style: const TextStyle(
                color: Colors.white70,
                fontSize: 11,
                fontWeight: FontWeight.w600),
          ),
        ],
      ),
    );
  }
}

class _ConversationStatChip extends StatelessWidget {
  const _ConversationStatChip({required this.icon, required this.label});

  final IconData icon;
  final String label;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.15),
        borderRadius: BorderRadius.circular(999),
        border: Border.all(color: Colors.white24),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, color: Colors.white, size: 16),
          const SizedBox(width: 6),
          Text(
            label,
            style: const TextStyle(
                color: Colors.white, fontWeight: FontWeight.w700, fontSize: 12),
          ),
        ],
      ),
    );
  }
}

class _MessageBubble extends StatelessWidget {
  const _MessageBubble({
    required this.text,
    this.senderName,
    this.timestamp,
    required this.isMine,
    this.showSender = false,
    this.media,
  });

  final String text;
  final String? senderName;
  final DateTime? timestamp;
  final bool isMine;
  final bool showSender;
  final List<dynamic>? media;

  @override
  Widget build(BuildContext context) {
    final alignment = isMine ? Alignment.centerRight : Alignment.centerLeft;
    final bubbleColor =
        isMine ? MessagesPage._focusColor : MessagesPage._chipInactive;
    final textColor = isMine ? Colors.white : MessagesPage._titleColor;
    final metaColor = isMine ? Colors.white70 : MessagesPage._mutedColor;
    final borderRadius = BorderRadius.only(
      topLeft: const Radius.circular(16),
      topRight: const Radius.circular(16),
      bottomLeft: Radius.circular(isMine ? 16 : 6),
      bottomRight: Radius.circular(isMine ? 6 : 16),
    );

    final formattedTime = timestamp == null ? null : _formatTime(timestamp!);
    final hasMedia = media != null && media!.isNotEmpty;
    final hasText = text.trim().isNotEmpty;

    return Align(
      alignment: alignment,
      child: Column(
        crossAxisAlignment:
            isMine ? CrossAxisAlignment.end : CrossAxisAlignment.start,
        children: [
          if (showSender && (senderName?.trim().isNotEmpty ?? false))
            Padding(
              padding: const EdgeInsets.only(bottom: 4, left: 4, right: 4),
              child: Text(
                senderName!,
                style: const TextStyle(
                    color: MessagesPage._mutedColor,
                    fontSize: 12,
                    fontWeight: FontWeight.w600),
              ),
            ),
          Container(
            constraints: const BoxConstraints(maxWidth: 360),
            padding: EdgeInsets.symmetric(
                horizontal: hasMedia ? 8 : 16, vertical: hasMedia ? 8 : 12),
            decoration: BoxDecoration(
              color: bubbleColor,
              borderRadius: borderRadius,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: isMine ? 0.08 : 0.04),
                  blurRadius: 14,
                  offset: const Offset(0, 6),
                ),
              ],
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                if (hasMedia) ...[
                  ...media!.map((m) => _buildMediaItem(context, m, isMine)),
                  if (hasText) const SizedBox(height: 8),
                ],
                if (hasText)
                  Padding(
                    padding: hasMedia
                        ? const EdgeInsets.symmetric(horizontal: 8)
                        : EdgeInsets.zero,
                    child: Text(
                      text,
                      style: TextStyle(
                          color: textColor, fontSize: 14, height: 1.42),
                    ),
                  ),
              ],
            ),
          ),
          if (formattedTime != null)
            Padding(
              padding: const EdgeInsets.only(top: 4, left: 4, right: 4),
              child: Text(
                formattedTime,
                style: TextStyle(
                    color: metaColor,
                    fontSize: 11,
                    fontWeight: FontWeight.w500),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildMediaItem(BuildContext context, dynamic mediaItem, bool isMine) {
    if (mediaItem is! Map) return const SizedBox.shrink();
    final url = mediaItem['url'] as String?;
    final name = mediaItem['name'] as String? ?? 'Attachment';
    final type = mediaItem['type'] as String? ?? '';

    if (url == null || url.isEmpty) return const SizedBox.shrink();

    final isImage = type.startsWith('image/');
    final isVideo = type.startsWith('video/');

    if (isImage) {
      return Padding(
        padding: const EdgeInsets.only(bottom: 4),
        child: GestureDetector(
          onTap: () => _openMediaViewer(context, url, name, isImage: true),
          child: ClipRRect(
            borderRadius: BorderRadius.circular(12),
            child: Image.network(
              url,
              width: 260,
              fit: BoxFit.cover,
              loadingBuilder: (context, child, loadingProgress) {
                if (loadingProgress == null) return child;
                return Container(
                  width: 260,
                  height: 160,
                  decoration: BoxDecoration(
                    color: isMine
                        ? Colors.white.withValues(alpha: 0.2)
                        : Colors.grey.withValues(alpha: 0.2),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  alignment: Alignment.center,
                  child: CircularProgressIndicator(
                    value: loadingProgress.expectedTotalBytes != null
                        ? loadingProgress.cumulativeBytesLoaded /
                            loadingProgress.expectedTotalBytes!
                        : null,
                    strokeWidth: 2,
                    color: isMine ? Colors.white : MessagesPage._focusColor,
                  ),
                );
              },
              errorBuilder: (context, error, stackTrace) => Container(
                width: 260,
                height: 80,
                decoration: BoxDecoration(
                  color: isMine
                      ? Colors.white.withValues(alpha: 0.2)
                      : Colors.grey.withValues(alpha: 0.2),
                  borderRadius: BorderRadius.circular(12),
                ),
                alignment: Alignment.center,
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(Icons.broken_image,
                        color:
                            isMine ? Colors.white70 : MessagesPage._mutedColor),
                    const SizedBox(height: 4),
                    Text('Failed to load image',
                        style: TextStyle(
                            fontSize: 11,
                            color: isMine
                                ? Colors.white70
                                : MessagesPage._mutedColor)),
                  ],
                ),
              ),
            ),
          ),
        ),
      );
    }

    // Non-image files (video, pdf, doc, etc.)
    return Padding(
      padding: const EdgeInsets.only(bottom: 4),
      child: InkWell(
        onTap: () => _openMediaViewer(context, url, name,
            isImage: false, isVideo: isVideo),
        borderRadius: BorderRadius.circular(10),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
          decoration: BoxDecoration(
            color: isMine
                ? Colors.white.withValues(alpha: 0.15)
                : Colors.grey.withValues(alpha: 0.15),
            borderRadius: BorderRadius.circular(10),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                isVideo ? Icons.video_file : _getFileIconForType(type),
                size: 24,
                color: isMine ? Colors.white : MessagesPage._focusColor,
              ),
              const SizedBox(width: 10),
              Flexible(
                child: Text(
                  name,
                  style: TextStyle(
                    color: isMine ? Colors.white : MessagesPage._titleColor,
                    fontSize: 13,
                    fontWeight: FontWeight.w500,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              const SizedBox(width: 8),
              Icon(
                Icons.download_rounded,
                size: 18,
                color: isMine ? Colors.white70 : MessagesPage._mutedColor,
              ),
            ],
          ),
        ),
      ),
    );
  }

  IconData _getFileIconForType(String type) {
    if (type.contains('pdf')) return Icons.picture_as_pdf;
    if (type.contains('word') || type.contains('doc')) return Icons.description;
    if (type.contains('video')) return Icons.video_file;
    return Icons.insert_drive_file;
  }

  void _openMediaViewer(BuildContext context, String url, String name,
      {bool isImage = false, bool isVideo = false}) async {
    if (isImage) {
      showDialog(
        context: context,
        builder: (context) => Dialog(
          backgroundColor: Colors.transparent,
          child: Stack(
            children: [
              InteractiveViewer(
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(16),
                  child: Image.network(url, fit: BoxFit.contain),
                ),
              ),
              Positioned(
                top: 8,
                right: 8,
                child: IconButton(
                  onPressed: () => Navigator.of(context).pop(),
                  icon: const Icon(Icons.close, color: Colors.white),
                  style: IconButton.styleFrom(backgroundColor: Colors.black54),
                ),
              ),
            ],
          ),
        ),
      );
    } else {
      // Open file in new tab/download
      await launchUrl(Uri.parse(url), mode: LaunchMode.externalApplication);
    }
  }

  static String _formatTime(DateTime dt) {
    final hour12 = dt.hour % 12 == 0 ? 12 : dt.hour % 12;
    final minute = dt.minute.toString().padLeft(2, '0');
    final period = dt.hour >= 12 ? 'PM' : 'AM';
    return '$hour12:$minute $period';
  }
}

class _GroupMembersSheet extends StatefulWidget {
  const _GroupMembersSheet({required this.chatId, required this.chatData});

  final String chatId;
  final Map<String, dynamic> chatData;

  @override
  State<_GroupMembersSheet> createState() => _GroupMembersSheetState();
}

class _GroupMembersSheetState extends State<_GroupMembersSheet> {
  late final TextEditingController _nameController;
  bool _isRenaming = false;
  bool _isInviting = false;
  String _lastName = '';
  List<_FriendProfile> _availableFriends = const [];
  Set<String> _pendingInvites = <String>{};
  String _friendsCacheKey = '';
  bool _loadingFriends = false;

  @override
  void initState() {
    super.initState();
    final defaultName = (widget.chatData['groupName'] as String?) ??
        (widget.chatData['title'] as String?) ??
        '';
    _lastName = defaultName;
    _nameController = TextEditingController(text: defaultName);
  }

  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }

  bool _isAdmin(Map<String, dynamic> chatData) {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return false;
    if (chatData['createdBy'] == uid) return true;
    final privileges = chatData['memberPrivileges'];
    if (privileges is Map) {
      final role = privileges[uid];
      if (role is String && (role == 'owner' || role == 'admin')) {
        return true;
      }
    }
    return false;
  }

  Future<void> _renameGroup(String chatId) async {
    final newName = _nameController.text.trim();
    if (newName.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Group name cannot be empty.')),
      );
      return;
    }
    if (newName == _lastName) return;

    setState(() => _isRenaming = true);
    try {
      await FirebaseFirestore.instance.collection('chats').doc(chatId).update({
        'groupName': newName,
        'title': newName,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      if (!mounted) return;
      setState(() {
        _lastName = newName;
      });
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Group renamed to "$newName"')),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to rename group: $e')),
      );
    } finally {
      if (mounted) {
        setState(() => _isRenaming = false);
      }
    }
  }

  void _refreshAvailableFriends(List<String> members) {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    final newKey = '${uid}_${members.join(',')}';
    if (_friendsCacheKey == newKey || _loadingFriends) return;
    _friendsCacheKey = newKey;
    setState(() {
      _loadingFriends = true;
      _pendingInvites =
          _pendingInvites.where((id) => !members.contains(id)).toSet();
    });
    _fetchFriendsForUser(uid).then((friends) {
      if (!mounted) return;
      setState(() {
        _availableFriends =
            friends.where((friend) => !members.contains(friend.id)).toList();
        _loadingFriends = false;
      });
    }).catchError((_) {
      if (!mounted) return;
      setState(() {
        _availableFriends = const [];
        _loadingFriends = false;
      });
    });
  }

  Future<void> _inviteSelectedMembers(String chatId) async {
    if (_pendingInvites.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Select at least one member to add.')),
      );
      return;
    }

    setState(() => _isInviting = true);
    try {
      final invitees = _pendingInvites.toList();
      final docRef = FirebaseFirestore.instance.collection('chats').doc(chatId);
      final privilegeUpdates = {
        for (final id in invitees) 'memberPrivileges.$id': 'member',
      };
      await docRef.update({
        'members': FieldValue.arrayUnion(invitees),
        'updatedAt': FieldValue.serverTimestamp(),
        ...privilegeUpdates,
      });
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
            content: Text(
                'Added ${invitees.length} member${invitees.length == 1 ? '' : 's'} to the group.')),
      );
      setState(() {
        _pendingInvites.clear();
      });
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Unable to add members: $e')),
      );
    } finally {
      if (mounted) {
        setState(() => _isInviting = false);
      }
    }
  }

  Future<void> _updatePrivilege(
      String chatId, String memberId, String role) async {
    try {
      await FirebaseFirestore.instance.collection('chats').doc(chatId).update({
        'memberPrivileges.$memberId': role,
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to update role: $e')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final media = MediaQuery.of(context);
    return FractionallySizedBox(
      heightFactor: media.size.height < 720 ? 0.98 : 0.9,
      child: Padding(
        padding: EdgeInsets.only(
            top: 24, left: 16, right: 16, bottom: media.viewInsets.bottom + 16),
        child: Material(
          color: Colors.white,
          borderRadius: BorderRadius.circular(28),
          child: ClipRRect(
            borderRadius: BorderRadius.circular(28),
            child: StreamBuilder<DocumentSnapshot<Map<String, dynamic>>>(
              stream: FirebaseFirestore.instance
                  .collection('chats')
                  .doc(widget.chatId)
                  .snapshots(),
              builder: (context, docSnap) {
                if (docSnap.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator());
                }

                if (!docSnap.hasData || !docSnap.data!.exists) {
                  return const Center(
                      child: Text('Conversation not available.'));
                }

                final chatData = docSnap.data!.data() ?? <String, dynamic>{};
                final chatId = docSnap.data!.id;
                final members = (chatData['members'] as List?)
                        ?.whereType<String>()
                        .toList() ??
                    const [];
                WidgetsBinding.instance.addPostFrameCallback(
                    (_) => _refreshAvailableFriends(members));
                final privilegesRaw = chatData['memberPrivileges'];
                final Map<String, String> privileges = {}..addAll(
                    privilegesRaw is Map<String, dynamic>
                        ? privilegesRaw.map((key, value) =>
                            MapEntry(key, value?.toString() ?? 'member'))
                        : {});
                final isAdmin = _isAdmin(chatData);

                return Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Container(
                      height: 50,
                      alignment: Alignment.center,
                      child: Container(
                        width: 60,
                        height: 6,
                        decoration: BoxDecoration(
                          color: MessagesPage._borderColor,
                          borderRadius: BorderRadius.circular(999),
                        ),
                      ),
                    ),
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 28),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                '${members.length} member${members.length == 1 ? '' : 's'}',
                                style: const TextStyle(
                                    color: MessagesPage._mutedColor,
                                    fontSize: 12),
                              ),
                              Text(
                                (chatData['groupName'] as String?) ??
                                    (chatData['title'] as String?) ??
                                    'Group',
                                style: const TextStyle(
                                    color: MessagesPage._titleColor,
                                    fontSize: 20,
                                    fontWeight: FontWeight.w800),
                              ),
                            ],
                          ),
                          IconButton(
                            tooltip: 'Close',
                            onPressed: () => Navigator.of(context).pop(),
                            icon: const Icon(Icons.close_rounded),
                          ),
                        ],
                      ),
                    ),
                    Expanded(
                      child: Scrollbar(
                        thumbVisibility: true,
                        child: ListView(
                          padding: const EdgeInsets.fromLTRB(28, 12, 28, 40),
                          children: [
                            if (isAdmin) ...[
                              const SizedBox(height: 12),
                              const Text(
                                'Group Details',
                                style: TextStyle(
                                    color: MessagesPage._titleColor,
                                    fontSize: 15,
                                    fontWeight: FontWeight.w700),
                              ),
                              const SizedBox(height: 12),
                              TextField(
                                controller: _nameController,
                                decoration: InputDecoration(
                                  labelText: 'Group name',
                                  suffixIcon: _isRenaming
                                      ? const Padding(
                                          padding: EdgeInsets.all(12),
                                          child: SizedBox(
                                            width: 16,
                                            height: 16,
                                            child: CircularProgressIndicator(
                                                strokeWidth: 2.2),
                                          ),
                                        )
                                      : IconButton(
                                          icon: const Icon(Icons.save_outlined),
                                          onPressed: () => _renameGroup(chatId),
                                        ),
                                  border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(16)),
                                ),
                                onSubmitted: (_) => _renameGroup(chatId),
                              ),
                              const SizedBox(height: 24),
                            ],
                            const Text(
                              'Members',
                              style: TextStyle(
                                  color: MessagesPage._titleColor,
                                  fontSize: 15,
                                  fontWeight: FontWeight.w700),
                            ),
                            const SizedBox(height: 12),
                            FutureBuilder<List<_FriendProfile>>(
                              future: _fetchProfilesByIds(members),
                              builder: (context, memberSnap) {
                                if (memberSnap.connectionState ==
                                    ConnectionState.waiting) {
                                  return const Padding(
                                    padding: EdgeInsets.all(24),
                                    child: Center(
                                        child: CircularProgressIndicator()),
                                  );
                                }
                                final profiles = memberSnap.data ?? const [];
                                return Column(
                                  children: profiles
                                      .map(
                                        (profile) => _GroupMemberTile(
                                          profile: profile,
                                          role: privileges[profile.id] ??
                                              (profile.id ==
                                                      chatData['createdBy']
                                                  ? 'owner'
                                                  : 'member'),
                                          isAdmin: isAdmin,
                                          onRoleChanged: (role) =>
                                              _updatePrivilege(
                                                  chatId, profile.id, role),
                                          isOwner: profile.id ==
                                              chatData['createdBy'],
                                        ),
                                      )
                                      .toList(),
                                );
                              },
                            ),
                            if (isAdmin) ...[
                              const SizedBox(height: 32),
                              const Text(
                                'Invite Members',
                                style: TextStyle(
                                    color: MessagesPage._titleColor,
                                    fontSize: 15,
                                    fontWeight: FontWeight.w700),
                              ),
                              const SizedBox(height: 12),
                              if (_loadingFriends)
                                const Center(
                                    child: Padding(
                                        padding: EdgeInsets.all(18),
                                        child: CircularProgressIndicator()))
                              else if (_availableFriends.isEmpty)
                                const Text(
                                  'No additional friends available to invite right now.',
                                  style: TextStyle(
                                      color: MessagesPage._mutedColor,
                                      fontSize: 13),
                                )
                              else
                                Wrap(
                                  spacing: 8,
                                  runSpacing: 8,
                                  children: _availableFriends
                                      .map(
                                        (friend) => FilterChip(
                                          selected: _pendingInvites
                                              .contains(friend.id),
                                          label: Text(friend.name),
                                          onSelected: (value) {
                                            setState(() {
                                              if (value) {
                                                _pendingInvites.add(friend.id);
                                              } else {
                                                _pendingInvites
                                                    .remove(friend.id);
                                              }
                                            });
                                          },
                                        ),
                                      )
                                      .toList(),
                                ),
                              const SizedBox(height: 16),
                              ElevatedButton.icon(
                                onPressed: _isInviting
                                    ? null
                                    : () => _inviteSelectedMembers(chatId),
                                icon: _isInviting
                                    ? const SizedBox(
                                        width: 16,
                                        height: 16,
                                        child: CircularProgressIndicator(
                                            strokeWidth: 2,
                                            color: Colors.white))
                                    : const Icon(Icons.person_add_alt_1),
                                label: Text(_isInviting
                                    ? 'Adding members...'
                                    : 'Add selected members'),
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: MessagesPage._focusColor,
                                  foregroundColor: Colors.white,
                                  shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(16)),
                                  padding: const EdgeInsets.symmetric(
                                      horizontal: 22, vertical: 16),
                                ),
                              ),
                            ],
                          ],
                        ),
                      ),
                    ),
                  ],
                );
              },
            ),
          ),
        ),
      ),
    );
  }
}

class _GroupMemberTile extends StatelessWidget {
  const _GroupMemberTile({
    required this.profile,
    required this.role,
    required this.isAdmin,
    required this.onRoleChanged,
    this.isOwner = false,
  });

  final _FriendProfile profile;
  final String role;
  final bool isAdmin;
  final bool isOwner;
  final ValueChanged<String> onRoleChanged;

  static const Map<String, String> roleLabels = {
    'owner': 'Owner',
    'admin': 'Admin',
    'moderator': 'Moderator',
    'member': 'Member',
  };

  List<String> get _roleOptions =>
      const ['owner', 'admin', 'moderator', 'member'];

  @override
  Widget build(BuildContext context) {
    final displayRole = roleLabels[role] ?? role.toUpperCase();
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: MessagesPage._borderColor),
      ),
      child: Row(
        children: [
          _FriendAvatar(name: profile.name, photoUrl: profile.photoUrl),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  profile.name,
                  style: const TextStyle(
                      color: MessagesPage._titleColor,
                      fontWeight: FontWeight.w700,
                      fontSize: 14),
                ),
                if (profile.email.isNotEmpty)
                  Padding(
                    padding: const EdgeInsets.only(top: 4),
                    child: Text(
                      profile.email,
                      style: const TextStyle(
                          color: MessagesPage._mutedColor, fontSize: 12),
                    ),
                  ),
              ],
            ),
          ),
          if (isOwner)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
              decoration: BoxDecoration(
                color: MessagesPage._focusColor.withOpacity(0.12),
                borderRadius: BorderRadius.circular(999),
              ),
              child: const Text(
                'Owner',
                style: TextStyle(
                    color: MessagesPage._focusColor,
                    fontWeight: FontWeight.w700,
                    fontSize: 12),
              ),
            )
          else if (isAdmin)
            DropdownButtonHideUnderline(
              child: DropdownButton<String>(
                value: roleLabels.keys.contains(role) ? role : 'member',
                items: _roleOptions
                    .map(
                      (value) => DropdownMenuItem(
                        value: value,
                        child: Text(roleLabels[value] ?? value),
                      ),
                    )
                    .toList(),
                onChanged: (value) {
                  if (value != null) onRoleChanged(value);
                },
              ),
            )
          else
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
              decoration: BoxDecoration(
                color: MessagesPage._chipInactive,
                borderRadius: BorderRadius.circular(999),
              ),
              child: Text(
                displayRole,
                style: const TextStyle(
                    color: MessagesPage._mutedColor,
                    fontWeight: FontWeight.w600,
                    fontSize: 12),
              ),
            ),
        ],
      ),
    );
  }
}

class _ConversationHeader extends StatelessWidget {
  const _ConversationHeader();

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          width: 46,
          height: 46,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(16),
            color: MessagesPage._focusColor.withOpacity(0.1),
            border:
                Border.all(color: MessagesPage._focusColor.withOpacity(0.22)),
          ),
          child: const Icon(Icons.chat_outlined,
              color: MessagesPage._focusColor, size: 24),
        ),
        const SizedBox(width: 16),
        Flexible(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: const [
              Text(
                'Inbox overview',
                style: TextStyle(
                    color: MessagesPage._titleColor,
                    fontSize: 17,
                    fontWeight: FontWeight.w800),
              ),
              SizedBox(height: 6),
              Text(
                'Live activity, service levels, and suggested moves appear as you engage.',
                style: TextStyle(
                    color: MessagesPage._mutedColor, fontSize: 13, height: 1.4),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

class _ConversationTaskPill extends StatelessWidget {
  const _ConversationTaskPill({required this.label});

  final String label;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 9),
      decoration: BoxDecoration(
        color: MessagesPage._focusColor.withOpacity(0.12),
        borderRadius: BorderRadius.circular(999),
        border: Border.all(color: MessagesPage._focusColor.withOpacity(0.24)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Icon(Icons.check_circle_outline,
              color: MessagesPage._focusColor, size: 18),
          const SizedBox(width: 8),
          Text(
            label,
            style: const TextStyle(
                color: MessagesPage._focusColor,
                fontSize: 12,
                fontWeight: FontWeight.w700),
          ),
        ],
      ),
    );
  }
}

class _InboxSparkChip extends StatelessWidget {
  const _InboxSparkChip({required this.icon, required this.label});

  final IconData icon;
  final String label;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: () {},
      borderRadius: BorderRadius.circular(16),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 10),
        decoration: BoxDecoration(
          color: MessagesPage._chipInactive,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: MessagesPage._borderColor),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, color: MessagesPage._focusColor, size: 18),
            const SizedBox(width: 8),
            Text(
              label,
              style: const TextStyle(
                  color: MessagesPage._titleColor,
                  fontSize: 12,
                  fontWeight: FontWeight.w700),
            ),
          ],
        ),
      ),
    );
  }
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Breakaway365',
      debugShowCheckedModeBanner: false,
      theme: lightTheme,
      darkTheme: darkTheme,
      themeMode: ThemeMode.light,
      builder: (context, child) {
        return WalkthroughOverlay(child: child ?? const SizedBox.shrink());
      },
      home: const AuthLandingPage(),
    );
  }
}

class AuthLandingPage extends StatelessWidget {
  const AuthLandingPage({super.key});

  static const Color _background = Color(0xFFF3F4F6);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: _background,
      body: LayoutBuilder(
        builder: (context, constraints) {
          final bool isCompact = constraints.maxWidth < 960;

          final Widget content = isCompact
              ? const Padding(
                  padding: EdgeInsets.fromLTRB(24, 32, 24, 24),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      _AuthCard(isPhoneView: true),
                    ],
                  ),
                )
              : Padding(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 48, vertical: 48),
                  child: ConstrainedBox(
                    constraints: const BoxConstraints(maxWidth: 1280),
                    child: Row(
                      children: [
                        Expanded(
                            flex: 6, child: _AuthHeroPanel(isCompact: false)),
                        const SizedBox(width: 48),
                        const Expanded(
                          flex: 4,
                          child: Align(
                            alignment: Alignment.center,
                            child: _AuthCard(isPhoneView: false),
                          ),
                        ),
                      ],
                    ),
                  ),
                );

          return SafeArea(
            child: SingleChildScrollView(
              child: ConstrainedBox(
                constraints: BoxConstraints(minHeight: constraints.maxHeight),
                child: Align(
                  alignment: Alignment.center,
                  child: content,
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

class _AuthHeroPanel extends StatelessWidget {
  const _AuthHeroPanel({required this.isCompact});

  final bool isCompact;

  static const List<_AuthFeatureCardData> _features = [
    _AuthFeatureCardData(
      title: 'Content Library',
      description: 'Access training materials organized by framework elements',
    ),
    _AuthFeatureCardData(
      title: 'Personal Dashboard',
      description: 'Track progress, store documents and view analytics.',
    ),
    _AuthFeatureCardData(
      title: 'Community Forums',
      description: 'Connect with other members and share experiences.',
    ),
    _AuthFeatureCardData(
      title: 'Coaching Tools',
      description: 'Schedule sessions and track business growth.',
    ),
  ];

  @override
  Widget build(BuildContext context) {
    final double height = isCompact ? 560 : 720;

    return ClipRRect(
      borderRadius: BorderRadius.circular(32),
      child: SizedBox(
        height: height,
        child: Stack(
          fit: StackFit.expand,
          children: [
            Image.network(
              'https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=1600&q=80',
              fit: BoxFit.cover,
            ),
            Container(
              decoration: const BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [Color(0xCC1A2A34), Color(0xCC0E1720)],
                ),
              ),
            ),
            Padding(
              padding: EdgeInsets.fromLTRB(
                  isCompact ? 24 : 48,
                  isCompact ? 32 : 56,
                  isCompact ? 24 : 48,
                  isCompact ? 32 : 56),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Image.asset(
                    'assets/images/Breakaway365_small_white.png',
                    height: isCompact ? 56 : 72,
                    fit: BoxFit.contain,
                  ),
                  const SizedBox(height: 24),
                  const Text(
                    'Access our comprehensive business framework, connect with coaches and join a community of successful business leaders.',
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 18,
                      height: 1.5,
                    ),
                  ),
                  const SizedBox(height: 36),
                  Expanded(
                    child: LayoutBuilder(
                      builder: (context, featureConstraints) {
                        final double maxWidth = featureConstraints.maxWidth;
                        final double spacing = isCompact ? 16 : 24;
                        int columns;

                        if (isCompact || maxWidth < 520) {
                          columns = 1;
                        } else if (maxWidth < 960) {
                          columns = 2;
                        } else if (maxWidth < 1200) {
                          columns = 3;
                        } else {
                          columns = 4;
                        }

                        columns = columns.clamp(1, _features.length).toInt();
                        final double itemWidth =
                            (maxWidth - spacing * (columns - 1)) / columns;

                        return Wrap(
                          spacing: spacing,
                          runSpacing: spacing,
                          alignment: isCompact
                              ? WrapAlignment.center
                              : WrapAlignment.start,
                          runAlignment: WrapAlignment.start,
                          children: _features
                              .map(
                                (feature) => SizedBox(
                                  width: itemWidth,
                                  child: _AuthFeatureCard(data: feature),
                                ),
                              )
                              .toList(),
                        );
                      },
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _AuthFeatureCard extends StatelessWidget {
  const _AuthFeatureCard({required this.data});

  final _AuthFeatureCardData data;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: const Color(0xFF7DDAD3).withOpacity(0.95),
        borderRadius: BorderRadius.circular(18),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.15),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            data.title,
            style: const TextStyle(
              color: Colors.white,
              fontSize: 18,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 12),
          Text(
            data.description,
            style: const TextStyle(
              color: Colors.white,
              fontSize: 14,
              height: 1.4,
            ),
          ),
        ],
      ),
    );
  }
}

enum _AuthMode { login, register }

class _AuthCard extends StatefulWidget {
  const _AuthCard({required this.isPhoneView});

  final bool isPhoneView;

  @override
  State<_AuthCard> createState() => _AuthCardState();
}

class _AuthCardState extends State<_AuthCard> {
  static const TextStyle _fieldLabelStyle = TextStyle(
    color: Color(0xFF111827),
    fontSize: 14,
    fontWeight: FontWeight.w600,
  );

  _AuthMode _mode = _AuthMode.login;
  bool _obscurePassword = true;
  bool _obscureRegisterPassword = true;
  bool _obscureRegisterConfirm = true;
  String _selectedRole = 'Member';
  final GlobalKey<FormState> _loginFormKey = GlobalKey<FormState>();
  final GlobalKey<FormState> _registerFormKey = GlobalKey<FormState>();

  List<Map<String, String>> _agencies = [];
  String? _selectedAgencyId;
  String? _selectedAgencyName;
  bool _isLoadingAgencies = false;

  final TextEditingController _loginEmailController = TextEditingController();
  final TextEditingController _loginPasswordController =
      TextEditingController();

  final TextEditingController _registerFirstNameController =
      TextEditingController();
  final TextEditingController _registerLastNameController =
      TextEditingController();
  final TextEditingController _registerEmailController =
      TextEditingController();
  final TextEditingController _registerDisplayNameController =
      TextEditingController();
  final TextEditingController _registerAgencyController =
      TextEditingController();
  final TextEditingController _registerTitleController =
      TextEditingController();
  final TextEditingController _registerLocationController =
      TextEditingController();
  final TextEditingController _registerPasswordController =
      TextEditingController();
  final TextEditingController _registerConfirmPasswordController =
      TextEditingController();

  bool _isLoginSubmitting = false;
  bool _isRegisterSubmitting = false;

  @override
  void initState() {
    super.initState();
    _loadAgencies();
  }

  Future<void> _loadAgencies() async {
    setState(() => _isLoadingAgencies = true);
    try {
      final agenciesSnapshot =
          await FirebaseFirestore.instance.collection('agencies').get();

      final List<Map<String, String>> agencies = [];
      for (final agencyDoc in agenciesSnapshot.docs) {
        final docData = agencyDoc.data();
        final agencyName = docData['agency_name'] as String? ??
            docData['name'] as String? ??
            agencyDoc.id;
        if (agencyName.isNotEmpty) {
          agencies.add({
            'id': agencyDoc.id,
            'name': agencyName,
          });
        }
      }

      agencies.sort((a, b) => (a['name'] ?? '').compareTo(b['name'] ?? ''));

      if (mounted) {
        setState(() {
          _agencies = agencies;
          _isLoadingAgencies = false;
        });
      }
    } catch (e) {
      debugPrint('Failed to load agencies: $e');
      if (mounted) {
        setState(() => _isLoadingAgencies = false);
      }
    }
  }

  @override
  void dispose() {
    _loginEmailController.dispose();
    _loginPasswordController.dispose();
    _registerFirstNameController.dispose();
    _registerLastNameController.dispose();
    _registerEmailController.dispose();
    _registerDisplayNameController.dispose();
    _registerAgencyController.dispose();
    _registerTitleController.dispose();
    _registerLocationController.dispose();
    _registerPasswordController.dispose();
    _registerConfirmPasswordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final bool isLogin = _mode == _AuthMode.login;

    return LayoutBuilder(
      builder: (context, constraints) {
        final double targetHeight = _resolveCardHeight(constraints.maxHeight);

        return Container(
          padding: const EdgeInsets.fromLTRB(32, 36, 32, 40),
          constraints: const BoxConstraints(maxWidth: 520),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(28),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.08),
                blurRadius: 20,
                offset: const Offset(0, 12),
              ),
            ],
          ),
          child: SizedBox(
            height: targetHeight,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                if (widget.isPhoneView && isLogin) ...[
                  Center(
                    child: Image.asset(
                      'assets/images/Breakaway365_small_white.png',
                      height: 56,
                      fit: BoxFit.contain,
                    ),
                  ),
                  const SizedBox(height: 24),
                ],
                if (isLogin) ...[
                  const Text(
                    'Welcome Back',
                    style: TextStyle(
                      color: Color(0xFF1F2937),
                      fontSize: 24,
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  const SizedBox(height: 6),
                  const Text(
                    'Enter your credentials to access your account',
                    style: TextStyle(
                      color: Color(0xFF6B7280),
                      fontSize: 14,
                    ),
                  ),
                ],
                SizedBox(height: isLogin ? 28 : 8),
                _buildTabSwitch(),
                SizedBox(height: isLogin ? 32 : 28),
                Expanded(
                  child: AnimatedSwitcher(
                    duration: const Duration(milliseconds: 250),
                    child: isLogin
                        ? SingleChildScrollView(
                            key: const ValueKey('_loginScroll'),
                            padding: EdgeInsets.zero,
                            child: _buildLoginForm(),
                          )
                        : Scrollbar(
                            key: const ValueKey('_registerScroll'),
                            thumbVisibility: true,
                            child: SingleChildScrollView(
                              padding:
                                  const EdgeInsets.only(right: 4, bottom: 12),
                              child: _buildRegisterForm(),
                            ),
                          ),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  double _resolveCardHeight(double maxConstraintHeight) {
    const double desiredHeight = 620;
    if (maxConstraintHeight.isFinite && maxConstraintHeight > 0) {
      return maxConstraintHeight < desiredHeight
          ? maxConstraintHeight
          : desiredHeight;
    }
    return desiredHeight;
  }

  Widget _buildTabSwitch() {
    return SizedBox(
      height: 48,
      child: Row(
        children: [
          _buildTabButton(label: 'Login', mode: _AuthMode.login),
          const SizedBox(width: 12),
          _buildTabButton(label: 'Register', mode: _AuthMode.register),
        ],
      ),
    );
  }

  Widget _buildTabButton({required String label, required _AuthMode mode}) {
    final bool isActive = _mode == mode;
    return Expanded(
      child: GestureDetector(
        onTap: () {
          if (!isActive) {
            setState(() => _mode = mode);
          }
        },
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          decoration: BoxDecoration(
            color: isActive ? const Color(0xFF68B56A) : const Color(0xFFE5E7EB),
            borderRadius: BorderRadius.circular(12),
          ),
          alignment: Alignment.center,
          child: Text(
            label,
            style: TextStyle(
              color: isActive ? Colors.white : const Color(0xFF6B7280),
              fontSize: 16,
              fontWeight: isActive ? FontWeight.w700 : FontWeight.w600,
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLoginForm() {
    return Form(
      key: _loginFormKey,
      child: Column(
        key: const ValueKey('_loginForm'),
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('Email', style: _fieldLabelStyle),
          const SizedBox(height: 8),
          _authInput(
            controller: _loginEmailController,
            hintText: 'your.email@example.com',
            keyboardType: TextInputType.emailAddress,
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Email is required';
              }
              final email = value.trim();
              final emailRegex = RegExp(r'^[^@]+@[^@]+\.[^@]+');
              if (!emailRegex.hasMatch(email)) {
                return 'Enter a valid email address';
              }
              return null;
            },
          ),
          const SizedBox(height: 24),
          const Text('Password', style: _fieldLabelStyle),
          const SizedBox(height: 8),
          _authInput(
            controller: _loginPasswordController,
            hintText: '********',
            obscureText: _obscurePassword,
            validator: (value) => (value == null || value.isEmpty)
                ? 'Password is required'
                : null,
            suffixIcon: IconButton(
              icon: Icon(
                _obscurePassword
                    ? Icons.visibility_off_outlined
                    : Icons.visibility_outlined,
                color: const Color(0xFF6B7280),
              ),
              onPressed: () {
                setState(() => _obscurePassword = !_obscurePassword);
              },
            ),
          ),
          const SizedBox(height: 12),
          Row(
            children: [
              const Spacer(),
              const Text(
                'Forgot password?',
                style: TextStyle(
                  color: Color(0xFF6B7280),
                  fontSize: 13,
                ),
              ),
              TextButton(
                onPressed: _isLoginSubmitting ? null : _handlePasswordReset,
                style: TextButton.styleFrom(
                  padding: EdgeInsets.zero,
                  minimumSize: Size.zero,
                  tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                  foregroundColor: const Color(0xFF3B5CCC),
                ),
                child: const Text(
                  'Reset password',
                  style: TextStyle(fontSize: 13, fontWeight: FontWeight.w600),
                ),
              ),
            ],
          ),
          const SizedBox(height: 24),
          SizedBox(
            width: double.infinity,
            height: 52,
            child: ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF2F55EE),
                foregroundColor: Colors.white,
                textStyle:
                    const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(14)),
                elevation: 0,
              ),
              onPressed: _isLoginSubmitting ? null : _handleLogin,
              child: _isLoginSubmitting
                  ? const SizedBox(
                      width: 22,
                      height: 22,
                      child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor:
                              AlwaysStoppedAnimation<Color>(Colors.white)),
                    )
                  : const Text('Login'),
            ),
          ),
          const SizedBox(height: 18),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Text(
                "Don't have an account?",
                style: TextStyle(color: Color(0xFF6B7280), fontSize: 14),
              ),
              TextButton(
                onPressed: () {
                  if (_mode != _AuthMode.register) {
                    setState(() => _mode = _AuthMode.register);
                  }
                },
                style: TextButton.styleFrom(
                  padding: const EdgeInsets.symmetric(horizontal: 6),
                  foregroundColor: const Color(0xFF3B5CCC),
                  textStyle: const TextStyle(
                      fontWeight: FontWeight.w600, fontSize: 14),
                ),
                child: const Text('Register'),
              ),
            ],
          ),
          const SizedBox(height: 16),
          _socialButton(
            iconAsset: 'assets/images/search.png',
            label: 'Google',
            borderColor: const Color(0xFFE5E7EB),
            textColor: const Color(0xFF1F2937),
            backgroundColor: Colors.white,
          ),
          const SizedBox(height: 12),
          _socialButton(
            iconAsset: 'assets/images/apple.png',
            label: 'Apple',
            borderColor: Colors.black,
            textColor: Colors.white,
            backgroundColor: Colors.black,
          ),
        ],
      ),
    );
  }

  Widget _buildRegisterForm() {
    return LayoutBuilder(
      key: const ValueKey('_registerForm'),
      builder: (context, constraints) {
        final bool useTwoColumns = constraints.maxWidth >= 520;
        return Form(
          key: _registerFormKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildFieldPair(
                useTwoColumns: useTwoColumns,
                left: _buildLabeledField(
                  'First Name *',
                  _authInput(
                    controller: _registerFirstNameController,
                    hintText: 'John',
                    textCapitalization: TextCapitalization.words,
                    validator: (value) =>
                        (value == null || value.trim().isEmpty)
                            ? 'Required'
                            : null,
                  ),
                ),
                right: _buildLabeledField(
                  'Last Name *',
                  _authInput(
                    controller: _registerLastNameController,
                    hintText: 'Doe',
                    textCapitalization: TextCapitalization.words,
                    validator: (value) =>
                        (value == null || value.trim().isEmpty)
                            ? 'Required'
                            : null,
                  ),
                ),
              ),
              const SizedBox(height: 18),
              _buildLabeledField(
                'Email Address *',
                _authInput(
                  controller: _registerEmailController,
                  hintText: 'Johndoe@breakaway365',
                  keyboardType: TextInputType.emailAddress,
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Required';
                    }
                    final email = value.trim();
                    final emailRegex = RegExp(r'^[^@]+@[^@]+\.[^@]+');
                    if (!emailRegex.hasMatch(email)) {
                      return 'Enter a valid email address';
                    }
                    return null;
                  },
                ),
              ),
              const SizedBox(height: 18),
              _buildLabeledField(
                'Display Name',
                _authInput(
                  controller: _registerDisplayNameController,
                  hintText: 'Johndoe424',
                ),
              ),
              const SizedBox(height: 18),
              _buildFieldPair(
                useTwoColumns: useTwoColumns,
                left: _buildLabeledField(
                  'Agency Name',
                  _buildAgencyDropdown(),
                ),
                right: _buildLabeledField(
                  'Title',
                  _authInput(
                    controller: _registerTitleController,
                    hintText: 'CEO',
                    textCapitalization: TextCapitalization.words,
                  ),
                ),
              ),
              const SizedBox(height: 18),
              _buildLabeledField(
                'Location',
                _authInput(
                  controller: _registerLocationController,
                  hintText: 'New York',
                  textCapitalization: TextCapitalization.words,
                ),
              ),
              const SizedBox(height: 18),
              _buildRoleSelector(),
              const SizedBox(height: 12),
              const Text(
                "Select 'Member' if you're joining as a business owner or 'Coach' if you're a business coach.",
                style: TextStyle(
                  color: Color(0xFF6B7280),
                  fontSize: 12,
                  height: 1.5,
                ),
              ),
              const SizedBox(height: 18),
              _buildLabeledField(
                'Password',
                _authInput(
                  controller: _registerPasswordController,
                  hintText: '********',
                  obscureText: _obscureRegisterPassword,
                  suffixIcon: IconButton(
                    icon: Icon(
                      _obscureRegisterPassword
                          ? Icons.visibility_off_outlined
                          : Icons.visibility_outlined,
                      color: const Color(0xFF6B7280),
                    ),
                    onPressed: () {
                      setState(() =>
                          _obscureRegisterPassword = !_obscureRegisterPassword);
                    },
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Required';
                    }
                    if (value.length < 8) {
                      return 'Use at least 8 characters';
                    }
                    return null;
                  },
                ),
              ),
              const SizedBox(height: 18),
              _buildLabeledField(
                'Confirm Password',
                _authInput(
                  controller: _registerConfirmPasswordController,
                  hintText: '********',
                  obscureText: _obscureRegisterConfirm,
                  suffixIcon: IconButton(
                    icon: Icon(
                      _obscureRegisterConfirm
                          ? Icons.visibility_off_outlined
                          : Icons.visibility_outlined,
                      color: const Color(0xFF6B7280),
                    ),
                    onPressed: () {
                      setState(() =>
                          _obscureRegisterConfirm = !_obscureRegisterConfirm);
                    },
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Required';
                    }
                    if (value != _registerPasswordController.text) {
                      return 'Passwords do not match';
                    }
                    return null;
                  },
                ),
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                height: 52,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF68B56A),
                    foregroundColor: Colors.white,
                    textStyle: const TextStyle(
                        fontSize: 16, fontWeight: FontWeight.w700),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(14)),
                    elevation: 0,
                  ),
                  onPressed: _isRegisterSubmitting ? null : _handleRegister,
                  child: _isRegisterSubmitting
                      ? const SizedBox(
                          width: 22,
                          height: 22,
                          child: CircularProgressIndicator(
                              strokeWidth: 2,
                              valueColor:
                                  AlwaysStoppedAnimation<Color>(Colors.white)),
                        )
                      : const Text('Register'),
                ),
              ),
              const SizedBox(height: 18),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Text(
                    'Already have an account?',
                    style: TextStyle(color: Color(0xFF6B7280), fontSize: 14),
                  ),
                  TextButton(
                    onPressed: () {
                      if (_mode != _AuthMode.login) {
                        setState(() => _mode = _AuthMode.login);
                      }
                    },
                    style: TextButton.styleFrom(
                      padding: const EdgeInsets.symmetric(horizontal: 6),
                      foregroundColor: const Color(0xFF3B5CCC),
                      textStyle: const TextStyle(
                          fontWeight: FontWeight.w600, fontSize: 14),
                    ),
                    child: const Text('Login'),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              _socialButton(
                iconAsset: 'assets/images/search.png',
                label: 'Google',
                borderColor: const Color(0xFFE5E7EB),
                textColor: const Color(0xFF1F2937),
                backgroundColor: Colors.white,
              ),
              const SizedBox(height: 12),
              _socialButton(
                iconAsset: 'assets/images/apple.png',
                label: 'Apple',
                borderColor: Colors.black,
                textColor: Colors.white,
                backgroundColor: Colors.black,
              ),
            ],
          ),
        );
      },
    );
  }

  Future<void> _handleLogin() async {
    if (_isLoginSubmitting) return;
    final formState = _loginFormKey.currentState;
    if (formState == null || !formState.validate()) {
      return;
    }
    FocusScope.of(context).unfocus();
    setState(() => _isLoginSubmitting = true);
    try {
      final credential = await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: _loginEmailController.text.trim(),
        password: _loginPasswordController.text,
      );
      final user = credential.user;
      if (user == null) {
        throw FirebaseAuthException(
            code: 'user-not-found',
            message: 'No user found for the provided credentials.');
      }

      Map<String, dynamic>? profile;
      try {
        final snapshot = await FirebaseFirestore.instance
            .collection('users')
            .doc(user.uid)
            .get();
        if (snapshot.exists) {
          profile = snapshot.data();
        }
      } on FirebaseException catch (e) {
        debugPrint('Failed to load profile data: ${e.message}');
      }

      final bool isCoach = _isCoachProfile(profile);
      final bool isAdmin = _isAdminProfile(profile);

      if (!mounted) return;
      _navigateAfterAuth(
        isCoach: isCoach,
        isAdmin: isAdmin,
        profile: profile,
        email: user.email,
      );
    } on FirebaseAuthException catch (e) {
      _showMessage(e.message ?? 'Authentication failed.', isError: true);
    } catch (_) {
      _showMessage('Authentication failed. Please try again.', isError: true);
    } finally {
      if (mounted) {
        setState(() => _isLoginSubmitting = false);
      }
    }
  }

  Future<void> _handleRegister() async {
    if (_isRegisterSubmitting) return;
    final formState = _registerFormKey.currentState;
    if (formState == null || !formState.validate()) {
      return;
    }
    FocusScope.of(context).unfocus();
    setState(() => _isRegisterSubmitting = true);
    try {
      final credential =
          await FirebaseAuth.instance.createUserWithEmailAndPassword(
        email: _registerEmailController.text.trim(),
        password: _registerPasswordController.text,
      );
      final user = credential.user;
      if (user == null) {
        throw FirebaseAuthException(
            code: 'user-creation-failed',
            message: 'Account could not be created.');
      }

      final timestamp = Timestamp.now();
      final profileDataForNavigation = {
        'firstName': _registerFirstNameController.text.trim(),
        'lastName': _registerLastNameController.text.trim(),
        'displayName': _registerDisplayNameController.text.trim(),
        'agencyName': _selectedAgencyName ?? '',
        'title': _registerTitleController.text.trim(),
        'location': _registerLocationController.text.trim(),
        'role': _selectedRole,
        'email': _registerEmailController.text.trim(),
        'createdAt': timestamp,
        'updatedAt': timestamp,
      };

      final Map<String, dynamic> userData = {
        ...profileDataForNavigation,
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      };

      // Add agency reference if an agency was selected
      if (_selectedAgencyId != null && _selectedAgencyId!.isNotEmpty) {
        userData['agency'] = FirebaseFirestore.instance
            .collection('agencies')
            .doc(_selectedAgencyId);
      }

      await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .set(userData);

      if (!mounted) return;
      _navigateAfterAuth(
        isCoach: _selectedRole.toLowerCase() == 'coach',
        isAdmin: _selectedRole.toLowerCase() == 'admin',
        profile: profileDataForNavigation,
        email: user.email,
      );
    } on FirebaseAuthException catch (e) {
      _showMessage(e.message ?? 'Registration failed.', isError: true);
    } catch (_) {
      _showMessage('Registration failed. Please try again.', isError: true);
    } finally {
      if (mounted) {
        setState(() => _isRegisterSubmitting = false);
      }
    }
  }

  Future<void> _handlePasswordReset() async {
    final email = _loginEmailController.text.trim();
    if (email.isEmpty) {
      _showMessage('Enter your email to reset your password.', isError: true);
      return;
    }
    try {
      await FirebaseAuth.instance.sendPasswordResetEmail(email: email);
      _showMessage('Password reset link sent to $email.');
    } on FirebaseAuthException catch (e) {
      _showMessage(e.message ?? 'Unable to send password reset email.',
          isError: true);
    }
  }

  void _showMessage(String message, {bool isError = false}) {
    final messenger = ScaffoldMessenger.of(context);
    messenger.hideCurrentSnackBar();
    messenger.showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor:
            isError ? const Color(0xFFB91C1C) : const Color(0xFF2563EB),
      ),
    );
  }

  bool _isCoachProfile(Map<String, dynamic>? profile) {
    if (profile == null || profile.isEmpty) {
      return false;
    }

    final Iterable<dynamic> roleCandidates = [
      profile['role'],
      profile['userRole'],
      profile['accountType'],
      profile['roleId'],
      profile['roles'],
    ].where((element) => element != null);

    bool? resolved;

    for (final candidate in roleCandidates) {
      if (candidate is String) {
        final normalized = candidate.trim().toLowerCase();
        if (normalized.contains('coach')) {
          resolved = true;
          break;
        }
        if (normalized.contains('member')) {
          resolved ??= false;
        }
      } else if (candidate is Iterable) {
        for (final value in candidate) {
          if (value is String) {
            final normalized = value.trim().toLowerCase();
            if (normalized.contains('coach')) {
              resolved = true;
              break;
            }
            if (normalized.contains('member')) {
              resolved ??= false;
            }
          }
        }
        if (resolved == true) {
          break;
        }
      }
    }

    return resolved ?? false;
  }

  bool _isAdminProfile(Map<String, dynamic>? profile) {
    if (profile == null || profile.isEmpty) {
      return false;
    }

    final Iterable<dynamic> roleCandidates = [
      profile['role'],
      profile['userRole'],
      profile['accountType'],
      profile['roleId'],
      profile['roles'],
    ].where((element) => element != null);

    for (final candidate in roleCandidates) {
      if (candidate is String) {
        if (candidate.toLowerCase().contains('admin')) {
          return true;
        }
      } else if (candidate is Iterable) {
        for (final value in candidate) {
          if (value is String && value.toLowerCase().contains('admin')) {
            return true;
          }
        }
      }
    }

    return false;
  }

  String _resolveDisplayName(Map<String, dynamic>? profile,
      {String? fallbackEmail}) {
    if (profile == null || profile.isEmpty) {
      return fallbackEmail ?? 'Admin';
    }

    final candidates = [
      profile['display_name'],
      profile['displayName'],
      profile['fullName'],
      profile['name'],
      profile['firstName'] != null || profile['lastName'] != null
          ? [profile['firstName'], profile['lastName']]
              .where((s) => s != null && s.toString().trim().isNotEmpty)
              .join(' ')
              .trim()
          : null,
      profile['first_name'] != null || profile['last_name'] != null
          ? [profile['first_name'], profile['last_name']]
              .where((s) => s != null && s.toString().trim().isNotEmpty)
              .join(' ')
              .trim()
          : null,
      profile['username'],
    ];

    for (final candidate in candidates) {
      if (candidate != null &&
          candidate is String &&
          candidate.trim().isNotEmpty) {
        return candidate.trim();
      }
    }

    final agencyName = (profile['agencyName'] as String?)?.trim();
    if (agencyName != null && agencyName.isNotEmpty) {
      return agencyName;
    }

    return fallbackEmail ?? 'Admin';
  }

  void _navigateAfterAuth({
    required bool isCoach,
    required bool isAdmin,
    Map<String, dynamic>? profile,
    String? email,
  }) {
    final Widget target;

    if (isAdmin) {
      final rawRole = (profile?['role'] as String?)?.trim();
      final String roleLabel = (rawRole == null || rawRole.isEmpty)
          ? 'Admin'
          : rawRole.length == 1
              ? rawRole.toUpperCase()
              : '${rawRole[0].toUpperCase()}${rawRole.substring(1).toLowerCase()}';
      final String? profileImageUrl = profile?['profileImageUrl'] as String? ??
          profile?['profile_image_url'] as String? ??
          profile?['photoURL'] as String? ??
          profile?['profilePicture'] as String?;

      target = AdminDashboardPage(
        displayName: _resolveDisplayName(profile, fallbackEmail: email),
        roleLabel: roleLabel,
        profileImageUrl: profileImageUrl,
      );
    } else if (isCoach) {
      target = const CoachDashboardShell();
    } else {
      target = DashboardPage(
        isCoach: false,
        userProfile: profile,
        userEmail: email,
      );
    }

    Navigator.of(context).pushReplacement(
      MaterialPageRoute(builder: (_) => target),
    );
  }

  Widget _buildAgencyDropdown() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        color: Colors.white,
        border: Border.all(color: const Color(0xFFD1D5DB)),
        borderRadius: BorderRadius.circular(12),
      ),
      child: _isLoadingAgencies
          ? const Padding(
              padding: EdgeInsets.symmetric(vertical: 16),
              child: Center(
                child: SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                ),
              ),
            )
          : DropdownButtonHideUnderline(
              child: DropdownButton<String>(
                isExpanded: true,
                value: _selectedAgencyId,
                hint: const Text(
                  'Select an agency',
                  style: TextStyle(
                    color: Color(0xFF9CA3AF),
                    fontSize: 14,
                  ),
                ),
                icon: const Icon(
                  Icons.expand_more,
                  color: Color(0xFF6B7280),
                ),
                items: _agencies.map((agency) {
                  return DropdownMenuItem<String>(
                    value: agency['id'],
                    child: Text(
                      agency['name'] ?? '',
                      style: const TextStyle(
                        color: Color(0xFF111827),
                        fontSize: 14,
                      ),
                    ),
                  );
                }).toList(),
                onChanged: (value) {
                  setState(() {
                    _selectedAgencyId = value;
                    _selectedAgencyName = _agencies.firstWhere(
                      (a) => a['id'] == value,
                      orElse: () => {'name': ''},
                    )['name'];
                  });
                },
              ),
            ),
    );
  }

  Widget _buildFieldPair({
    required bool useTwoColumns,
    required Widget left,
    required Widget right,
  }) {
    if (useTwoColumns) {
      return Row(
        children: [
          Expanded(child: left),
          const SizedBox(width: 16),
          Expanded(child: right),
        ],
      );
    }
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        left,
        const SizedBox(height: 18),
        right,
      ],
    );
  }

  Widget _buildLabeledField(String label, Widget field) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label, style: _fieldLabelStyle),
        const SizedBox(height: 8),
        field,
      ],
    );
  }

  Widget _buildRoleSelector() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('Role *', style: _fieldLabelStyle),
        const SizedBox(height: 8),
        DropdownButtonFormField<String>(
          value: _selectedRole,
          icon: const Icon(Icons.expand_more, color: Color(0xFF6B7280)),
          decoration: InputDecoration(
            filled: true,
            fillColor: const Color(0xFFF9FAFB),
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 18, vertical: 18),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14),
              borderSide: const BorderSide(color: Color(0xFFE5E7EB)),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14),
              borderSide:
                  const BorderSide(color: Color(0xFF2F55EE), width: 1.4),
            ),
          ),
          items: const [
            DropdownMenuItem(
              value: 'Member',
              child: Text(
                'Member',
                style: TextStyle(
                    color: Color(0xFF1F2937), fontWeight: FontWeight.w500),
              ),
            ),
            DropdownMenuItem(
              value: 'Coach',
              child: Text(
                'Coach',
                style: TextStyle(
                    color: Color(0xFF1F2937), fontWeight: FontWeight.w500),
              ),
            ),
            DropdownMenuItem(
              value: 'Admin',
              child: Text(
                'Admin',
                style: TextStyle(
                    color: Color(0xFF1F2937), fontWeight: FontWeight.w500),
              ),
            ),
          ],
          onChanged: (value) {
            if (value != null) {
              setState(() => _selectedRole = value);
            }
          },
        ),
      ],
    );
  }

  Widget _authInput({
    required TextEditingController controller,
    required String hintText,
    bool obscureText = false,
    Widget? suffixIcon,
    TextInputType? keyboardType,
    TextCapitalization textCapitalization = TextCapitalization.none,
    bool readOnly = false,
    VoidCallback? onTap,
    FormFieldValidator<String>? validator,
  }) {
    return TextFormField(
      controller: controller,
      obscureText: obscureText,
      keyboardType: keyboardType,
      textCapitalization: textCapitalization,
      readOnly: readOnly,
      onTap: onTap,
      validator: validator,
      decoration: InputDecoration(
        hintText: hintText,
        filled: true,
        fillColor: const Color(0xFFF9FAFB),
        contentPadding:
            const EdgeInsets.symmetric(horizontal: 18, vertical: 18),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(14),
          borderSide: const BorderSide(color: Color(0xFFE5E7EB)),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(14),
          borderSide: const BorderSide(color: Color(0xFF2F55EE), width: 1.4),
        ),
        suffixIcon: suffixIcon,
      ),
    );
  }

  Widget _socialButton({
    String? iconAsset,
    IconData? icon,
    required String label,
    required Color borderColor,
    required Color textColor,
    Color backgroundColor = Colors.white,
  }) {
    return SizedBox(
      width: double.infinity,
      height: 52,
      child: OutlinedButton(
        style: OutlinedButton.styleFrom(
          backgroundColor: backgroundColor,
          side: BorderSide(color: borderColor),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
        ),
        onPressed: () {},
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            if (iconAsset != null)
              Image.asset(
                iconAsset,
                width: 20,
                height: 20,
                errorBuilder: (context, error, stackTrace) =>
                    Icon(Icons.account_circle, color: textColor, size: 20),
              )
            else if (icon != null)
              Icon(icon, color: textColor, size: 20),
            const SizedBox(width: 12),
            Text(
              label,
              style: TextStyle(
                  color: textColor, fontSize: 15, fontWeight: FontWeight.w600),
            ),
          ],
        ),
      ),
    );
  }
}

class _AuthFeatureCardData {
  const _AuthFeatureCardData({required this.title, required this.description});

  final String title;
  final String description;
}

enum NavigationItem {
  dashboard,
  profile,
  contentLibrary,
  assessments,
  scorecard,
  documents,
  aiCoach,
  forums,
  messages,
  settings,
}

enum DashboardTab {
  overview,
  learningActivity,
  skills,
}

enum ForumTab {
  forums,
  friends,
  coaches,
}

class DashboardPage extends StatefulWidget {
  const DashboardPage({
    super.key,
    required this.isCoach,
    this.userProfile,
    this.userEmail,
  });

  static const Color _pageBackground = Color(0xFFF6F7FB);

  final bool isCoach;
  final Map<String, dynamic>? userProfile;
  final String? userEmail;

  @override
  State<DashboardPage> createState() => _DashboardPageState();
}

class _DashboardPageState extends State<DashboardPage> {
  NavigationItem _selectedItem = NavigationItem.dashboard;
  DashboardTab _dashboardTab = DashboardTab.overview;
  // Track an in-app learning session when user views the Learning Activity tab
  String? _activeLearningSessionId;
  DateTime? _learningSessionStartedAt;
  // Scorecard sub-navigation: null = list, otherwise details for metric
  String? _openScoreMetricTitle;
  // Counter to force widget recreation when navigating
  int _navigationCounter = 0;

  void _handleSelection(NavigationItem item) {
    if (_selectedItem == item) {
      // Reset sub-navigation to root when clicking the same item
      setState(() {
        _openScoreMetricTitle = null;
        _dashboardTab = DashboardTab.overview;
        _navigationCounter++; // Force widget recreation
      });
      return;
    }
    setState(() {
      _selectedItem = item;
      // Reset sub-navigation when switching sections
      _openScoreMetricTitle = null;
      _dashboardTab = DashboardTab.overview;
      _navigationCounter++; // Force widget recreation
    });
  }

  void _handleDashboardTabChange(DashboardTab tab) {
    if (_dashboardTab == tab) return;
    // Stop any active learning session when leaving the Learning Activity tab
    if (_dashboardTab == DashboardTab.learningActivity &&
        tab != DashboardTab.learningActivity) {
      _stopLearningSession();
    }
    setState(() => _dashboardTab = tab);
    // Start a learning session when entering the Learning Activity tab
    if (tab == DashboardTab.learningActivity) {
      _startLearningSession();
    }
  }

  Future<void> _handleLogout() async {
    // Ensure any active learning session is saved before logging out
    await _stopLearningSession();
    try {
      await FirebaseAuth.instance.signOut();
    } on FirebaseAuthException catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          SnackBar(
            content: Text(e.message ?? 'Failed to log out.'),
            backgroundColor: const Color(0xFFDC2626),
          ),
        );
      return;
    } catch (_) {
      if (!mounted) return;
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          const SnackBar(
            content: Text('Failed to log out. Please try again.'),
            backgroundColor: Color(0xFFDC2626),
          ),
        );
      return;
    }

    if (!mounted) return;
    Navigator.of(context).pushAndRemoveUntil(
      MaterialPageRoute(builder: (_) => const AuthLandingPage()),
      (route) => false,
    );
  }

  @override
  void initState() {
    super.initState();
    // Log today's access for the authenticated user
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid != null) {
      UsageMetricsService.logDailyAccess(uid: uid);
    }
  }

  @override
  void dispose() {
    // Stop session if user closes the page while on Learning Activity
    _stopLearningSession();
    super.dispose();
  }

  Future<void> _startLearningSession() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    // If already running, don't start another
    if (_activeLearningSessionId != null) return;
    _learningSessionStartedAt = DateTime.now();
    try {
      _activeLearningSessionId = await UsageMetricsService.startLearningSession(
          uid: uid, startedAt: _learningSessionStartedAt!);
    } catch (e) {
      debugPrint('Failed to start learning session: $e');
    }
  }

  Future<void> _stopLearningSession() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) {
      _activeLearningSessionId = null;
      _learningSessionStartedAt = null;
      return;
    }
    final sessionId = _activeLearningSessionId;
    final startedAt = _learningSessionStartedAt;
    if (sessionId == null || startedAt == null) return;
    _activeLearningSessionId = null;
    _learningSessionStartedAt = null;
    try {
      await UsageMetricsService.stopLearningSession(
        uid: uid,
        sessionId: sessionId,
        startedAt: startedAt,
        endedAt: DateTime.now(),
      );
    } catch (e) {
      debugPrint('Failed to stop learning session: $e');
    }
  }

  Widget _buildContent() {
    // Use ValueKey to force widget recreation when navigation counter changes
    final key = ValueKey('nav_$_navigationCounter');
    switch (_selectedItem) {
      case NavigationItem.dashboard:
        return DashboardView(
          key: key,
          activeTab: _dashboardTab,
          onTabSelected: _handleDashboardTabChange,
          userProfile: widget.userProfile,
          userEmail: widget.userEmail,
        );
      case NavigationItem.profile:
        return ProfilePage(key: key);
      case NavigationItem.contentLibrary:
        return ContentLibraryPage(key: key);
      case NavigationItem.assessments:
        return AssessmentsPage(key: key);
      case NavigationItem.scorecard:
        if (_openScoreMetricTitle == null) {
          return ScorecardPage(
            key: key,
            onViewDetails: (title) =>
                setState(() => _openScoreMetricTitle = title),
          );
        }
        return ScoreMetricDetailsPage(
          key: key,
          metricTitle: _openScoreMetricTitle!,
          onBack: () => setState(() => _openScoreMetricTitle = null),
        );
      case NavigationItem.documents:
        return MyDocumentsPage(key: key);
      case NavigationItem.aiCoach:
        return AICoachView(
          key: key,
          url:
              'https://app.gpt-trainer.com/widget/e75aedf2ab3541c28943d0094e09547f',
        );
      case NavigationItem.forums:
        return DiscussionForumPage(key: key);
      case NavigationItem.messages:
        return MessagesPage(key: key);
      case NavigationItem.settings:
        return SettingsPage(key: key);
    }
  }

  @override
  Widget build(BuildContext context) {
    if (widget.isCoach) {
      return const CoachDashboardShell();
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        final isMobileLayout = constraints.maxWidth < 900;

        if (isMobileLayout) {
          return Scaffold(
            backgroundColor: DashboardPage._pageBackground,
            appBar: AppBar(
              backgroundColor: Colors.white,
              elevation: 0,
              iconTheme: const IconThemeData(color: Color(0xFF111827)),
              titleSpacing: 0,
              title: SizedBox(
                height: 36,
                child: Image.asset(
                  'assets/images/Breakaway365_small_white.png',
                  fit: BoxFit.contain,
                  color: const Color(0xFF111827),
                ),
              ),
            ),
            drawer: Drawer(
              child: SafeArea(
                child: Builder(
                  builder: (drawerContext) {
                    return _SideNavigation(
                      selectedItem: _selectedItem,
                      onItemSelected: (item) {
                        Navigator.of(drawerContext).pop();
                        _handleSelection(item);
                      },
                      onLogout: () {
                        Navigator.of(drawerContext).pop();
                        _handleLogout();
                      },
                    );
                  },
                ),
              ),
            ),
            body: Column(
              children: [
                const AnnouncementMarquee(),
                Expanded(
                  child: Container(
                    color: DashboardPage._pageBackground,
                    child: _buildContent(),
                  ),
                ),
              ],
            ),
          );
        }

        return Scaffold(
          backgroundColor: DashboardPage._pageBackground,
          body: Column(
            children: [
              const AnnouncementMarquee(),
              Expanded(
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    SizedBox(
                      width: 260,
                      child: _SideNavigation(
                        selectedItem: _selectedItem,
                        onItemSelected: _handleSelection,
                        onLogout: _handleLogout,
                      ),
                    ),
                    Expanded(child: _buildContent()),
                  ],
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}

class _SideNavigation extends StatelessWidget {
  const _SideNavigation({
    required this.selectedItem,
    required this.onItemSelected,
    this.onLogout,
  });

  static const Color _sectionLabel = Color(0xFF9CA3AF);
  static const Color _itemColor = Color(0xFF1F2937);
  static const Color _activeBackground = Color(0xFFFDF3EC);
  static const Color _activeColor = Color(0xFFEB7723);

  final NavigationItem selectedItem;
  final ValueChanged<NavigationItem> onItemSelected;
  final VoidCallback? onLogout;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
      decoration: const BoxDecoration(
        color: Colors.white,
        border: Border(
          right: BorderSide(color: Color(0xFFE5E7EB)),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            child: SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(
                    height: 48,
                    child: Image.asset(
                      'assets/images/Breakaway365_small_white.png',
                      fit: BoxFit.contain,
                    ),
                  ),
                  const SizedBox(height: 32),
                  const _SectionHeader('MAIN'),
                  _NavItem(
                    icon: Icons.dashboard_outlined,
                    label: 'Dashboard',
                    isActive: selectedItem == NavigationItem.dashboard,
                    activeColor: _activeColor,
                    activeBackground: _activeBackground,
                    color: _itemColor,
                    onTap: () => onItemSelected(NavigationItem.dashboard),
                  ),
                  _NavItem(
                    icon: Icons.person_outline,
                    label: 'My Profile',
                    color: _itemColor,
                    isActive: selectedItem == NavigationItem.profile,
                    activeColor: const Color(0xFF111827),
                    activeBackground: const Color(0xFFEFF1F6),
                    onTap: () => onItemSelected(NavigationItem.profile),
                  ),
                  const SizedBox(height: 24),
                  const _SectionHeader('LEARNING'),
                  _NavItem(
                    icon: Icons.menu_book_outlined,
                    label: 'Content Library',
                    color: _itemColor,
                    isActive: selectedItem == NavigationItem.contentLibrary,
                    activeColor: const Color(0xFF111827),
                    activeBackground: const Color(0xFFEFF1F6),
                    onTap: () => onItemSelected(NavigationItem.contentLibrary),
                  ),
                  _NavItem(
                    icon: Icons.fact_check_outlined,
                    label: 'My Assessments',
                    color: _itemColor,
                    isActive: selectedItem == NavigationItem.assessments,
                    activeColor: const Color(0xFF111827),
                    activeBackground: const Color(0xFFEFF1F6),
                    onTap: () => onItemSelected(NavigationItem.assessments),
                  ),
                  _NavItem(
                    icon: Icons.leaderboard_outlined,
                    label: 'Scorecard',
                    color: _itemColor,
                    isActive: selectedItem == NavigationItem.scorecard,
                    activeColor: const Color(0xFF111827),
                    activeBackground: const Color(0xFFEFF1F6),
                    onTap: () => onItemSelected(NavigationItem.scorecard),
                  ),
                  _NavItem(
                    icon: Icons.insert_drive_file_outlined,
                    label: 'My Documents',
                    color: _itemColor,
                    isActive: selectedItem == NavigationItem.documents,
                    activeColor: const Color(0xFF111827),
                    activeBackground: const Color(0xFFEFF1F6),
                    onTap: () => onItemSelected(NavigationItem.documents),
                  ),
                  _NavItem(
                    icon: Icons.smart_toy_outlined,
                    label: 'AI Coach',
                    color: _itemColor,
                    isActive: selectedItem == NavigationItem.aiCoach,
                    activeColor: const Color(0xFF111827),
                    activeBackground: const Color(0xFFEFF1F6),
                    onTap: () => onItemSelected(NavigationItem.aiCoach),
                  ),
                  const SizedBox(height: 24),
                  const _SectionHeader('COMMUNITY'),
                  _NavItem(
                    icon: Icons.forum_outlined,
                    label: 'Discussion Forum',
                    color: _itemColor,
                    isActive: selectedItem == NavigationItem.forums,
                    activeColor: const Color(0xFF111827),
                    activeBackground: const Color(0xFFEFF1F6),
                    onTap: () => onItemSelected(NavigationItem.forums),
                  ),
                  _NavItem(
                    icon: Icons.mail_outline,
                    label: 'Messages',
                    color: _itemColor,
                    isActive: selectedItem == NavigationItem.messages,
                    activeColor: const Color(0xFF111827),
                    activeBackground: const Color(0xFFEFF1F6),
                    onTap: () => onItemSelected(NavigationItem.messages),
                  ),
                  const SizedBox(height: 24),
                  const _SectionHeader('SETTINGS'),
                  _NavItem(
                    icon: Icons.settings_outlined,
                    label: 'Settings',
                    color: _itemColor,
                    isActive: selectedItem == NavigationItem.settings,
                    activeColor: const Color(0xFF111827),
                    activeBackground: const Color(0xFFEFF1F6),
                    onTap: () => onItemSelected(NavigationItem.settings),
                  ),
                  const SizedBox(height: 24),
                ],
              ),
            ),
          ),
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              border: Border.all(color: _sectionLabel.withOpacity(0.4)),
            ),
            child: const Icon(Icons.person_outline, color: _sectionLabel),
          ),
          const SizedBox(height: 16),
          Material(
            color: Colors.transparent,
            child: InkWell(
              borderRadius: BorderRadius.circular(12),
              onTap: onLogout,
              child: Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: const Color(0xFFFECACA)),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: const [
                    Icon(Icons.logout, color: Colors.red),
                    SizedBox(width: 8),
                    Text(
                      'Logout',
                      style: TextStyle(
                        color: Colors.red,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _SectionHeader extends StatelessWidget {
  const _SectionHeader(this.title);

  final String title;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Text(
        title,
        style: const TextStyle(
          color: Color(0xFF9CA3AF),
          fontSize: 12,
          letterSpacing: 1.2,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }
}

class _NavItem extends StatelessWidget {
  const _NavItem({
    required this.icon,
    required this.label,
    this.isActive = false,
    this.activeColor,
    this.activeBackground,
    this.color,
    this.onTap,
  });

  final IconData icon;
  final String label;
  final bool isActive;
  final Color? activeColor;
  final Color? activeBackground;
  final Color? color;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final textColor =
        isActive ? activeColor ?? Colors.black : color ?? Colors.black;
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: isActive
            ? activeBackground ?? Colors.transparent
            : Colors.transparent,
        borderRadius: BorderRadius.circular(12),
      ),
      child: ListTile(
        dense: true,
        contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
        leading: Icon(
          icon,
          color: textColor,
        ),
        title: Text(
          label,
          style: TextStyle(
            color: textColor,
            fontWeight: isActive ? FontWeight.w700 : FontWeight.w500,
          ),
        ),
        onTap: onTap,
      ),
    );
  }
}

class AdminDashboardPage extends StatefulWidget {
  const AdminDashboardPage({
    super.key,
    required this.displayName,
    this.roleLabel,
    this.profileImageUrl,
  });

  final String displayName;
  final String? roleLabel;
  final String? profileImageUrl;

  @override
  State<AdminDashboardPage> createState() => _AdminDashboardPageState();
}

enum AdminSection {
  agencies,
  memberManagement,
  createUsers,
  contentLibrary,
  uploadContent,
  postConfirmationMessaging,
  messages,
  discussionForum,
  systemSettings,
}

class _AdminDashboardPageState extends State<AdminDashboardPage> {
  static const List<_AgencyFilterOption> _agencyFilters = [];

  static const List<Color> _agencyAccentPalette = [
    Color(0xFF5B8DEF),
    Color(0xFF5EC3B7),
    Color(0xFFF5A26C),
    Color(0xFF8B7CF0),
    Color(0xFF4AC3E0),
  ];

  static const Map<String, _AgencyDetailSnapshot> _agencyDetailSnapshots = {
    'Visiting Angels - Largo, MD': _AgencyDetailSnapshot(
      summary:
          'A high-touch franchise partner focused on rapid onboarding and consistent member outreach. Coaching cadence is steady and utilization is trending upward.',
      startDate: 'Jan 12, 2023',
      endDate: 'Present',
      programUtilization: 0.82,
      memberEngagement: 0.74,
      goalCompletion: 0.68,
      totalMembers: 2,
      activeMembers: 1,
      pendingInvites: 1,
      healthStatus: 'High engagement',
    ),
    'Visiting Angels - Roswell': _AgencyDetailSnapshot(
      summary:
          'Lean team with strong adoption across core learning modules. Coaching focus is on reinforcing goal completion habits.',
      startDate: 'Mar 03, 2023',
      endDate: 'Present',
      programUtilization: 0.71,
      memberEngagement: 0.66,
      goalCompletion: 0.59,
      totalMembers: 1,
      activeMembers: 1,
      pendingInvites: 0,
      healthStatus: 'Healthy adoption',
    ),
    'Right at Home - El Cajon': _AgencyDetailSnapshot(
      summary:
          'Regional location adopting Breakaway365 playbooks to align caregiver training. Engagement is accelerating following the latest cohort kickoff.',
      startDate: 'Aug 18, 2022',
      endDate: 'Present',
      programUtilization: 0.64,
      memberEngagement: 0.58,
      goalCompletion: 0.52,
      totalMembers: 2,
      activeMembers: 2,
      pendingInvites: 0,
      healthStatus: 'On track',
    ),
    'Homewatch Caregivers - AZ': _AgencyDetailSnapshot(
      summary:
          'Coaching partnership centers on onboarding new franchise owners. Pipeline of additional managers ready to be invited once initial cohort graduates.',
      startDate: 'Oct 02, 2022',
      endDate: 'Present',
      programUtilization: 0.55,
      memberEngagement: 0.48,
      goalCompletion: 0.44,
      totalMembers: 1,
      activeMembers: 1,
      pendingInvites: 0,
      healthStatus: 'Momentum building',
    ),
    'Symphony of Care': _AgencyDetailSnapshot(
      summary:
          'Emerging partner piloting the growth framework with leadership. Monitoring adoption before rolling out to frontline teams.',
      startDate: 'Jan 09, 2024',
      endDate: 'Present',
      programUtilization: 0.37,
      memberEngagement: 0.42,
      goalCompletion: 0.31,
      totalMembers: 1,
      activeMembers: 0,
      pendingInvites: 1,
      healthStatus: 'Watchlist',
    ),
  };

  AdminSection _selectedSection = AdminSection.agencies;
  int _navigationCounter = 0;
  bool _showCreateUsersModal = false;
  bool _showUploadContentModal = false;
  bool _showAgencyDetailModal = false;
  _AdminAgencyCardData? _selectedAgencyDetail;
  bool _showAgencyMembersModal = false;
  String? _selectedAgencyForMembers;
  String? _selectedAgencyForFilter;
  final TextEditingController _agencySearchController = TextEditingController();
  String _agencySearchQuery = '';
  int _activeAgencyFilterIndex = 0;

  Future<void> _handleLogout() async {
    await FirebaseAuth.instance.signOut();
    if (!mounted) return;
    Navigator.of(context).pushAndRemoveUntil(
      MaterialPageRoute<void>(builder: (_) => const AuthLandingPage()),
      (route) => false,
    );
  }

  Future<void> _openAddAgencyPage() async {
    final selectedSection = await Navigator.of(context).push<AdminSection>(
      MaterialPageRoute<AdminSection>(
        builder: (_) => AdminAddAgencyPage(
          displayName: widget.displayName,
          roleLabel: widget.roleLabel,
          profileImageUrl: widget.profileImageUrl,
        ),
      ),
    );

    if (!mounted) return;

    if (selectedSection != null && selectedSection != _selectedSection) {
      setState(() => _selectedSection = selectedSection);
    }
  }

  Future<void> _downloadRosterCSV() async {
    try {
      // Debug print to confirm click handler fires
      // ignore: avoid_print
      print('[Export CSV] Started exporting roster CSV...');
      final firestore = FirebaseFirestore.instance;

      // Fetch all users
      final usersSnapshot = await firestore.collection('users').get();

      // Fetch coach assignments
      final coachSnapshot = await firestore.collection('member_coach').get();
      final Map<String, String> memberCoachMap = {};
      for (final doc in coachSnapshot.docs) {
        final data = doc.data();
        final membersAssigned = data['membersAssigned'] as List<dynamic>?;
        if (membersAssigned != null) {
          for (final memberRef in membersAssigned) {
            if (memberRef is DocumentReference) {
              memberCoachMap[memberRef.id] = doc.id;
            }
          }
        }
      }

      // Build CSV content
      final StringBuffer csv = StringBuffer();
      csv.writeln('Name,Email,Role,Agency,Coach,Approved,Progress');

      for (final doc in usersSnapshot.docs) {
        final data = doc.data();
        final String firstName = data['firstName'] as String? ?? '';
        final String lastName = data['lastName'] as String? ?? '';
        final String displayName = data['display_name'] as String? ??
            data['displayName'] as String? ??
            data['username'] as String? ??
            '';
        final String name = displayName.isNotEmpty
            ? displayName
            : '$firstName $lastName'.trim();
        final String email = data['email'] as String? ?? '';
        final String role = data['role'] as String? ?? 'Member';

        dynamic agencyField = data['agency'];
        String agency = 'N/A';
        if (agencyField is DocumentReference) {
          agency = agencyField.id;
        } else if (agencyField is String && agencyField.isNotEmpty) {
          agency = agencyField;
        } else if (data['agencyName'] is String) {
          agency = data['agencyName'] as String;
        }

        // Get coach name
        String coach = 'N/A';
        if (memberCoachMap.containsKey(doc.id)) {
          final coachId = memberCoachMap[doc.id]!;
          final coachDoc =
              await firestore.collection('users').doc(coachId).get();
          if (coachDoc.exists) {
            final coachData = coachDoc.data()!;
            final coachFirstName = coachData['firstName'] as String? ?? '';
            final coachLastName = coachData['lastName'] as String? ?? '';
            coach = '$coachFirstName $coachLastName'.trim();
          }
        }

        final bool approved =
            data['isApproved'] as bool? ?? data['approved'] as bool? ?? false;
        final double progress = (data['progress'] as num? ?? 0.0).toDouble();

        // Escape CSV fields
        csv.writeln(
            '"${name.replaceAll('"', '""')}","${email.replaceAll('"', '""')}","$role","${agency.replaceAll('"', '""')}","${coach.replaceAll('"', '""')}","${approved ? 'Yes' : 'No'}","${(progress * 100).toStringAsFixed(1)}%"');
      }

      // Download the CSV file (Web)
      final csvBytes = Uint8List.fromList(utf8.encode(csv.toString()));
      if (kIsWeb) {
        _triggerWebDownload(
          csvBytes,
          'roster_export_${DateTime.now().toIso8601String().split('T')[0]}.csv',
          'text/csv',
        );
      }

      if (mounted) {
        ScaffoldMessenger.of(context)
          ..hideCurrentSnackBar()
          ..showSnackBar(
            const SnackBar(
              content: Text('CSV exported successfully!'),
              duration: Duration(seconds: 3),
            ),
          );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context)
          ..hideCurrentSnackBar()
          ..showSnackBar(
            SnackBar(
              content: Text('Error exporting CSV: $e'),
              duration: const Duration(seconds: 3),
            ),
          );
      }
    }
  }

  Future<void> _downloadRosterPDF() async {
    try {
      // ignore: avoid_print
      print('[Download PDF] Started generating roster PDF...');
      final firestore = FirebaseFirestore.instance;

      // Fetch all users
      final usersSnapshot = await firestore.collection('users').get();

      // Fetch coach assignments
      final coachSnapshot = await firestore.collection('member_coach').get();
      final Map<String, String> memberCoachMap = {};
      for (final doc in coachSnapshot.docs) {
        final data = doc.data();
        final membersAssigned = data['membersAssigned'] as List<dynamic>?;
        if (membersAssigned != null) {
          for (final memberRef in membersAssigned) {
            if (memberRef is DocumentReference) {
              memberCoachMap[memberRef.id] = doc.id;
            }
          }
        }
      }

      // Create PDF document
      final pdf = pw.Document();

      // Prepare data rows
      final List<List<String>> dataRows = [];
      for (final doc in usersSnapshot.docs) {
        final data = doc.data();
        final String firstName = data['firstName'] as String? ?? '';
        final String lastName = data['lastName'] as String? ?? '';
        final String displayName = data['display_name'] as String? ??
            data['displayName'] as String? ??
            data['username'] as String? ??
            '';
        final String name = displayName.isNotEmpty
            ? displayName
            : '$firstName $lastName'.trim();
        final String email = data['email'] as String? ?? '';
        final String role = data['role'] as String? ?? 'Member';

        dynamic agencyField = data['agency'];
        String agency = 'N/A';
        if (agencyField is DocumentReference) {
          agency = agencyField.id;
        } else if (agencyField is String && agencyField.isNotEmpty) {
          agency = agencyField;
        } else if (data['agencyName'] is String) {
          agency = data['agencyName'] as String;
        }

        // Get coach name
        String coach = 'N/A';
        if (memberCoachMap.containsKey(doc.id)) {
          final coachId = memberCoachMap[doc.id]!;
          final coachDoc =
              await firestore.collection('users').doc(coachId).get();
          if (coachDoc.exists) {
            final coachData = coachDoc.data()!;
            final coachFirstName = coachData['firstName'] as String? ?? '';
            final coachLastName = coachData['lastName'] as String? ?? '';
            coach = '$coachFirstName $coachLastName'.trim();
          }
        }

        final bool approved =
            data['isApproved'] as bool? ?? data['approved'] as bool? ?? false;
        final double progress = (data['progress'] as num? ?? 0.0).toDouble();

        dataRows.add([
          name,
          email,
          role,
          agency,
          coach,
          approved ? 'Yes' : 'No',
          '${(progress * 100).toStringAsFixed(1)}%',
        ]);
      }

      // Build PDF pages
      pdf.addPage(
        pw.MultiPage(
          pageFormat: PdfPageFormat.a4.landscape,
          margin: const pw.EdgeInsets.all(32),
          build: (context) => [
            pw.Header(
              level: 0,
              child: pw.Text(
                'Roster Snapshot - ${DateTime.now().toIso8601String().split('T')[0]}',
                style:
                    pw.TextStyle(fontSize: 24, fontWeight: pw.FontWeight.bold),
              ),
            ),
            pw.SizedBox(height: 20),
            pw.Table.fromTextArray(
              headers: [
                'Name',
                'Email',
                'Role',
                'Agency',
                'Coach',
                'Approved',
                'Progress'
              ],
              data: dataRows,
              headerStyle:
                  pw.TextStyle(fontWeight: pw.FontWeight.bold, fontSize: 10),
              cellStyle: const pw.TextStyle(fontSize: 9),
              headerDecoration:
                  const pw.BoxDecoration(color: PdfColors.grey300),
              cellHeight: 30,
              cellAlignments: {
                0: pw.Alignment.centerLeft,
                1: pw.Alignment.centerLeft,
                2: pw.Alignment.centerLeft,
                3: pw.Alignment.centerLeft,
                4: pw.Alignment.centerLeft,
                5: pw.Alignment.center,
                6: pw.Alignment.center,
              },
            ),
          ],
        ),
      );

      // Save and download PDF (Web)
      final bytes = await pdf.save();
      if (kIsWeb) {
        _triggerWebDownload(
          Uint8List.fromList(bytes),
          'roster_snapshot_${DateTime.now().toIso8601String().split('T')[0]}.pdf',
          'application/pdf',
        );
      } else {
        // Fallback for non-web (share)
        await Printing.sharePdf(
          bytes: bytes,
          filename:
              'roster_snapshot_${DateTime.now().toIso8601String().split('T')[0]}.pdf',
        );
      }

      if (mounted) {
        ScaffoldMessenger.of(context)
          ..hideCurrentSnackBar()
          ..showSnackBar(
            const SnackBar(
              content: Text('PDF downloaded successfully!'),
              duration: Duration(seconds: 3),
            ),
          );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context)
          ..hideCurrentSnackBar()
          ..showSnackBar(
            SnackBar(
              content: Text('Error downloading PDF: $e'),
              duration: const Duration(seconds: 3),
            ),
          );
      }
    }
  }

  List<_AdminAgencyCardData> _filterAgencies(
      List<_AdminAgencyCardData> agencies) {
    final query = _agencySearchQuery.trim().toLowerCase();
    debugPrint(
        'üîç Filter agencies - Query: "$query", Total agencies: ${agencies.length}');

    final filtered = agencies.where((agency) {
      final matchesQuery = query.isEmpty
          ? true
          : agency.name.toLowerCase().contains(query) ||
              agency.location.toLowerCase().contains(query);

      debugPrint(
          'üîç Agency: "${agency.name}", Location: "${agency.location}", Members: ${agency.members}');
      debugPrint('   - Matches query: $matchesQuery');

      return matchesQuery;
    }).toList(growable: false);

    debugPrint('‚úÖ Filtered result: ${filtered.length} agencies');
    return filtered;
  }

  void _handleSectionChange(AdminSection section) {
    // Always increment counter to force widget recreation, even when clicking same section
    if (section == AdminSection.createUsers) {
      setState(() {
        _selectedSection = AdminSection.createUsers;
        _navigationCounter++;
        _showCreateUsersModal = true;
        _showUploadContentModal = false;
        _showAgencyDetailModal = false;
        _selectedAgencyDetail = null;
      });
    } else if (section == AdminSection.uploadContent) {
      setState(() {
        _selectedSection = AdminSection.uploadContent;
        _navigationCounter++;
        _showCreateUsersModal = false;
        _showUploadContentModal = true;
        _showAgencyDetailModal = false;
        _selectedAgencyDetail = null;
      });
    } else {
      setState(() {
        _selectedSection = section;
        _navigationCounter++;
        _showCreateUsersModal = false;
        _showUploadContentModal = false;
        _showAgencyDetailModal = false;
        _selectedAgencyDetail = null;
      });
    }
  }

  void _closeCreateUsersModal() {
    if (!_showCreateUsersModal &&
        _selectedSection != AdminSection.createUsers) {
      return;
    }
    setState(() {
      _showCreateUsersModal = false;
      if (_selectedSection == AdminSection.createUsers) {
        _selectedSection = AdminSection.memberManagement;
      }
    });
  }

  void _closeUploadContentModal() {
    if (!_showUploadContentModal &&
        _selectedSection != AdminSection.uploadContent) {
      return;
    }
    setState(() {
      _showUploadContentModal = false;
      if (_selectedSection == AdminSection.uploadContent) {
        _selectedSection = AdminSection.contentLibrary;
      }
    });
  }

  Future<void> _handleCreateUsersSubmit(_CreateUserFormData data) async {
    // Validate fields
    if (data.username.isEmpty ||
        data.email.isEmpty ||
        data.firstName.isEmpty ||
        data.lastName.isEmpty ||
        data.role.isEmpty ||
        data.password.isEmpty) {
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          const SnackBar(
            content: Text('Please fill in all required fields.'),
            duration: Duration(seconds: 2),
            backgroundColor: Colors.red,
          ),
        );
      return;
    }

    if (data.password != data.confirmPassword) {
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          const SnackBar(
            content: Text('Passwords do not match.'),
            duration: Duration(seconds: 2),
            backgroundColor: Colors.red,
          ),
        );
      return;
    }

    // For non-Admin roles, agency is required
    if (data.role != 'Admin' && data.agency.isEmpty) {
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          const SnackBar(
            content: Text('Please select an agency.'),
            duration: Duration(seconds: 2),
            backgroundColor: Colors.red,
          ),
        );
      return;
    }

    // Password validation
    if (data.password.length < 6) {
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          const SnackBar(
            content: Text('Password must be at least 6 characters.'),
            duration: Duration(seconds: 2),
            backgroundColor: Colors.red,
          ),
        );
      return;
    }

    debugPrint('üöÄ Starting user creation process for ${data.email}...');
    FirebaseApp? secondaryApp;
    try {
      // Use a secondary Firebase app to create the user without signing out the current admin
      // This is necessary because createUserWithEmailAndPassword signs in the newly created user
      final String secondaryAppName =
          'SecondaryApp_${DateTime.now().millisecondsSinceEpoch}';
      secondaryApp = await Firebase.initializeApp(
        name: secondaryAppName,
        options: Firebase.app().options,
      );

      final secondaryAuth = FirebaseAuth.instanceFor(app: secondaryApp);

      // Create the Firebase Auth account
      final credential = await secondaryAuth.createUserWithEmailAndPassword(
        email: data.email.trim(),
        password: data.password,
      );

      final newUser = credential.user;
      if (newUser == null) {
        throw Exception('Failed to create user account.');
      }

      final userId = newUser.uid;

      // Sign out from secondary auth
      await secondaryAuth.signOut();

      // Create user document in 'users' collection using the Auth UID
      final userDoc =
          FirebaseFirestore.instance.collection('users').doc(userId);

      await userDoc.set({
        'username': data.username,
        'email': data.email.trim(),
        'firstName': data.firstName,
        'lastName': data.lastName,
        'displayName': '${data.firstName} ${data.lastName}'.trim(),
        'role': data.role,
        'agency': data.role == 'Admin'
            ? null
            : (data.agencyName.isNotEmpty ? data.agencyName : 'Unknown Agency'),
        'status': 'approved', // Auto-approve since admin created the account
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      });

      // If agency is selected, add user reference to agency's members field
      if (data.role != 'Admin' && data.agency.isNotEmpty) {
        debugPrint('üè¢ Adding user $userId to agency ${data.agency} members list...');
        await FirebaseFirestore.instance
            .collection('agencies')
            .doc(data.agency)
            .update({
          'members': FieldValue.arrayUnion([userId]),
        });
      }

      if (!mounted) return;
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          SnackBar(
            content: Text(
                'User account created successfully! ${data.email} can now login.'),
            duration: const Duration(seconds: 3),
            backgroundColor: Colors.green,
          ),
        );
      _closeCreateUsersModal();
    } on FirebaseAuthException catch (e) {
      debugPrint(
          'FirebaseAuthException creating user: ${e.code} - ${e.message}');
      String errorMessage = 'Error creating user account.';
      switch (e.code) {
        case 'email-already-in-use':
          errorMessage = 'An account with this email already exists.';
          break;
        case 'invalid-email':
          errorMessage = 'The email address is invalid.';
          break;
        case 'weak-password':
          errorMessage = 'The password is too weak. Use at least 6 characters.';
          break;
        case 'operation-not-allowed':
          errorMessage = 'Email/password accounts are not enabled.';
          break;
        default:
          errorMessage = e.message ?? 'Error creating user account.';
      }
      if (!mounted) return;
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          SnackBar(
            content: Text(errorMessage),
            duration: const Duration(seconds: 3),
            backgroundColor: Colors.red,
          ),
        );
    } catch (e) {
      debugPrint('Error creating user: $e');
      if (!mounted) return;
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          SnackBar(
            content: Text('Error creating user: $e'),
            duration: const Duration(seconds: 3),
            backgroundColor: Colors.red,
          ),
        );
    } finally {
      // Clean up the secondary app
      if (secondaryApp != null) {
        try {
          await secondaryApp.delete();
        } catch (e) {
          debugPrint('Error deleting secondary app: $e');
        }
      }
    }
  }

  void _handleUploadContentSubmit() {
    // Just close the modal - the upload success/error message is shown by _handleUploadWithFiles
    _closeUploadContentModal();
  }

  void _openAgencyDetails(_AdminAgencyCardData agency) {
    setState(() {
      _selectedAgencyDetail = agency;
      _showAgencyDetailModal = true;
    });
  }

  void _closeAgencyDetails() {
    if (!_showAgencyDetailModal) {
      return;
    }
    setState(() {
      _showAgencyDetailModal = false;
      _selectedAgencyDetail = null;
    });
  }

  void _openAgencyMembersModal(String agencyName) {
    setState(() {
      _selectedAgencyForMembers = agencyName;
      _showAgencyMembersModal = true;
      _showAgencyDetailModal = false;
      _selectedAgencyDetail = null;
    });
  }

  void _closeAgencyMembersModal() {
    if (!_showAgencyMembersModal) {
      return;
    }
    setState(() {
      _showAgencyMembersModal = false;
      _selectedAgencyForMembers = null;
    });
  }

  void _navigateToMemberManagementWithFilter(String agencyName) {
    setState(() {
      _selectedAgencyForFilter = agencyName;
      _selectedSection = AdminSection.memberManagement;
      _showAgencyDetailModal = false;
      _selectedAgencyDetail = null;
      _showAgencyMembersModal = false;
      _selectedAgencyForMembers = null;
    });
  }

  void _clearAgencyFilter() {
    setState(() {
      _selectedAgencyForFilter = null;
    });
  }

  Future<_AgencyDetailSnapshot> _resolveAgencySnapshot(
      _AdminAgencyCardData agency) async {
    if (agency.id == null) {
      return _AgencyDetailSnapshot(
        summary:
            '${agency.name} is not yet configured with detailed insights. Keep an eye on adoption metrics as members engage with Breakaway365.',
        startDate: 'Pending',
        endDate: 'TBD',
        programUtilization: 0.0,
        memberEngagement: 0.0,
        goalCompletion: 0.0,
        totalMembers: agency.members,
        activeMembers: math.min(agency.members, 1),
        pendingInvites: math.max(agency.members - 1, 0),
        healthStatus: 'Configuration needed',
      );
    }

    try {
      final doc = await FirebaseFirestore.instance
          .collection('agencies')
          .doc(agency.id)
          .get();

      final data = doc.data();
      if (data != null && data.containsKey('detailSnapshot')) {
        final details = data['detailSnapshot'] as Map<String, dynamic>;
        return _AgencyDetailSnapshot(
          summary: details['summary'] as String? ?? 'No summary available.',
          startDate: details['startDate'] as String? ?? 'Pending',
          endDate: details['endDate'] as String? ?? 'Present',
          programUtilization: _safeDouble(details['programUtilization']) ?? 0.0,
          memberEngagement: _safeDouble(details['memberEngagement']) ?? 0.0,
          goalCompletion: _safeDouble(details['goalCompletion']) ?? 0.0,
          totalMembers: _safeInt(details['totalMembers']) ?? agency.members,
          activeMembers: _safeInt(details['activeMembers']) ?? 0,
          pendingInvites: _safeInt(details['pendingInvites']) ?? 0,
          healthStatus: details['healthStatus'] as String? ?? 'Pending review',
        );
      }

      // Fallback to static data if available
      final snapshot = _agencyDetailSnapshots[agency.name];
      if (snapshot != null) {
        return snapshot;
      }
    } catch (e) {
      debugPrint('Error fetching agency details: $e');
    }

    return _AgencyDetailSnapshot(
      summary:
          '${agency.name} is not yet configured with detailed insights. Keep an eye on adoption metrics as members engage with Breakaway365.',
      startDate: 'Pending',
      endDate: 'TBD',
      programUtilization: 0.0,
      memberEngagement: 0.0,
      goalCompletion: 0.0,
      totalMembers: agency.members,
      activeMembers: math.min(agency.members, 1),
      pendingInvites: math.max(agency.members - 1, 0),
      healthStatus: 'Configuration needed',
    );
  }

  static int? _safeInt(dynamic value) {
    if (value == null) return null;
    if (value is int) return value;
    if (value is num) return value.toInt();
    if (value is String) return int.tryParse(value);
    if (value is List && value.isNotEmpty) {
      // Handle case where Firebase returns array instead of int
      final first = value.first;
      if (first is int) return first;
      if (first is num) return first.toInt();
      if (first is String) return int.tryParse(first);
    }
    return null;
  }

  static double? _safeDouble(dynamic value) {
    if (value == null) return null;
    if (value is double) return value;
    if (value is num) return value.toDouble();
    if (value is String) return double.tryParse(value);
    if (value is List && value.isNotEmpty) {
      // Handle case where Firebase returns array instead of double
      final first = value.first;
      if (first is double) return first;
      if (first is num) return first.toDouble();
      if (first is String) return double.tryParse(first);
    }
    return null;
  }

  @override
  void dispose() {
    _agencySearchController.dispose();
    super.dispose();
  }

  Widget _buildAgenciesView(ThemeData theme) {
    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance.collection('users').snapshots(),
      builder: (userContext, userSnapshot) {
        return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
          stream: FirebaseFirestore.instance.collection('agencies').snapshots(),
          builder: (context, snapshot) {
            debugPrint(
                'üîç Agencies StreamBuilder - connectionState: ${snapshot.connectionState}');
            debugPrint(
                'üîç Agencies StreamBuilder - hasError: ${snapshot.hasError}');
            debugPrint('üîç Agencies StreamBuilder - error: ${snapshot.error}');
            debugPrint('üîç Agencies StreamBuilder - hasData: ${snapshot.hasData}');
            debugPrint(
                'üîç Agencies StreamBuilder - docs count: ${snapshot.data?.docs.length ?? 0}');

            if (snapshot.hasError) {
              debugPrint('‚ùå Error loading agencies: ${snapshot.error}');
              return Center(
                  child: Text('Error loading agencies: ${snapshot.error}'));
            }

            if (snapshot.connectionState == ConnectionState.waiting ||
                userSnapshot.connectionState == ConnectionState.waiting) {
              debugPrint('‚è≥ Waiting for data...');
              return const Center(child: CircularProgressIndicator());
            }

            // Get all user docs to count them per agency
            final userDocs = userSnapshot.data?.docs ?? [];

            final allAgencies = snapshot.data?.docs.map((doc) {
                  debugPrint(
                      'üìÑ Processing agency doc: ${doc.id}, data: ${doc.data()}');
                  final baseData = _AdminAgencyCardData.fromFirestore(doc);

                  // Count users where the 'agency' field matches this agency name
                  final actualMemberCount = userDocs.where((u) {
                    final userData = u.data() as Map<String, dynamic>?;
                    final userAgency = userData?['agency'];
                    // We check if the user's agency matches the card's agency name
                    return userAgency == baseData.name;
                  }).length;

                  return baseData.copyWith(members: actualMemberCount);
                }).toList() ??
                [];
            debugPrint('‚úÖ Total agencies loaded: ${allAgencies.length}');

            final agencies = _filterAgencies(allAgencies);
            debugPrint('‚úÖ Filtered agencies: ${agencies.length}');

            final int totalAgencies = allAgencies.length;
            final int totalMembers =
                allAgencies.fold<int>(0, (sum, agency) => sum + agency.members);
            final String averageMembers = totalAgencies == 0
                ? '--'
                : (totalMembers / totalAgencies).toStringAsFixed(1);
            final int highEngagementCount =
                allAgencies.where((agency) => agency.members >= 2).length;

            return _buildAgenciesContent(theme, agencies, totalAgencies,
                totalMembers, averageMembers, highEngagementCount);
          },
        );
      },
    );
  }

  Widget _buildAgenciesContent(
      ThemeData theme,
      List<_AdminAgencyCardData> agencies,
      int totalAgencies,
      int totalMembers,
      String averageMembers,
      int highEngagementCount) {
    final Widget baseContent = Container(
      color: Colors.white,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(32, 32, 32, 0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Container(
                  decoration: BoxDecoration(
                    color: const Color(0xFF2563EB),
                    borderRadius: BorderRadius.circular(32),
                    boxShadow: const [
                      BoxShadow(
                        color: Color(0x1A2563EB),
                        blurRadius: 28,
                        offset: Offset(0, 18),
                      ),
                    ],
                  ),
                  padding: const EdgeInsets.fromLTRB(32, 32, 32, 36),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: const [
                                Text(
                                  'Agencies',
                                  style: TextStyle(
                                    color: Colors.white,
                                    fontSize: 26,
                                    fontWeight: FontWeight.w800,
                                  ),
                                ),
                                SizedBox(height: 8),
                                Text(
                                  'Monitor agency health at a glance. Search, filter, and act without leaving the dashboard.',
                                  style: TextStyle(
                                    color: Colors.white,
                                    fontSize: 15,
                                    height: 1.45,
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                              ],
                            ),
                          ),
                          const SizedBox(width: 16),
                          ElevatedButton.icon(
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.white,
                              foregroundColor: const Color(0xFF2563EB),
                              elevation: 0,
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 26, vertical: 16),
                              shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(16)),
                              textStyle: const TextStyle(
                                  fontWeight: FontWeight.w700, fontSize: 15),
                            ),
                            onPressed: _openAddAgencyPage,
                            icon: const Icon(Icons.add, size: 20),
                            label: const Text('Add Agency'),
                          ),
                        ],
                      ),
                      const SizedBox(height: 28),
                      Wrap(
                        spacing: 16,
                        runSpacing: 12,
                        children: [
                          _buildAgencyMetric(
                            icon: Icons.apartment,
                            label: 'Active agencies',
                            value: '$totalAgencies',
                            accent: const Color(0xFF2563EB),
                          ),
                          _buildAgencyMetric(
                            icon: Icons.groups_outlined,
                            label: 'Total members',
                            value: '$totalMembers',
                            accent: const Color(0xFF0F9D58),
                          ),
                          _buildAgencyMetric(
                            icon: Icons.analytics_outlined,
                            label: 'Avg. per agency',
                            value: averageMembers,
                            accent: const Color(0xFF6D28D9),
                          ),
                          _buildAgencyMetric(
                            icon: Icons.trending_up_outlined,
                            label: 'High engagement',
                            value: '$highEngagementCount',
                            accent: const Color(0xFFF97316),
                          ),
                        ],
                      ),
                      const SizedBox(height: 28),
                      Container(
                        decoration: BoxDecoration(
                          color: Colors.white,
                          borderRadius: BorderRadius.circular(20),
                          border: Border.all(color: const Color(0xFFE0E7FF)),
                          boxShadow: const [
                            BoxShadow(
                              color: Color(0x14000000),
                              blurRadius: 20,
                              offset: Offset(0, 14),
                            ),
                          ],
                        ),
                        padding: const EdgeInsets.fromLTRB(20, 18, 20, 20),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            TextField(
                              controller: _agencySearchController,
                              onChanged: (value) {
                                debugPrint('üîç Search input changed: "$value"');
                                setState(() => _agencySearchQuery = value);
                              },
                              decoration: InputDecoration(
                                hintText:
                                    'Search by agency name, city, or state',
                                prefixIcon: const Icon(Icons.search,
                                    color: Color(0xFF64748B)),
                                suffixIcon: _agencySearchQuery.isEmpty
                                    ? null
                                    : IconButton(
                                        icon: const Icon(Icons.clear,
                                            color: Color(0xFF64748B)),
                                        onPressed: () {
                                          _agencySearchController.clear();
                                          setState(
                                              () => _agencySearchQuery = '');
                                        },
                                      ),
                                filled: true,
                                fillColor: const Color(0xFFF8FAFF),
                                contentPadding: const EdgeInsets.symmetric(
                                    horizontal: 18, vertical: 18),
                                border: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(16),
                                  borderSide: const BorderSide(
                                      color: Color(0xFFE0E7FF)),
                                ),
                                enabledBorder: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(16),
                                  borderSide: const BorderSide(
                                      color: Color(0xFFE0E7FF)),
                                ),
                                focusedBorder: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(16),
                                  borderSide: const BorderSide(
                                      color: Color(0xFF2563EB), width: 1.4),
                                ),
                              ),
                            ),
                            if (_agencyFilters.isNotEmpty) ...[
                              const SizedBox(height: 16),
                              SingleChildScrollView(
                                scrollDirection: Axis.horizontal,
                                child: Row(
                                  children: _agencyFilters
                                      .asMap()
                                      .entries
                                      .map((entry) {
                                    return Padding(
                                      padding: EdgeInsets.only(
                                          right: entry.key ==
                                                  _agencyFilters.length - 1
                                              ? 0
                                              : 12),
                                      child: _buildAgencyFilterChip(
                                          entry.key, entry.value),
                                    );
                                  }).toList(growable: false),
                                ),
                              ),
                            ],
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 24),
              ],
            ),
          ),
          Expanded(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(32, 0, 32, 48),
              child: AnimatedSwitcher(
                duration: const Duration(milliseconds: 250),
                child: agencies.isEmpty
                    ? _buildEmptyAgenciesState()
                    : LayoutBuilder(
                        builder: (context, constraints) {
                          int crossAxisCount;
                          if (constraints.maxWidth > 1400) {
                            crossAxisCount = 4;
                          } else if (constraints.maxWidth > 1000) {
                            crossAxisCount = 3;
                          } else if (constraints.maxWidth > 650) {
                            crossAxisCount = 2;
                          } else {
                            crossAxisCount = 1;
                          }
                          return GridView.builder(
                            padding: EdgeInsets.zero,
                            gridDelegate:
                                SliverGridDelegateWithFixedCrossAxisCount(
                              crossAxisCount: crossAxisCount,
                              crossAxisSpacing: 20,
                              mainAxisSpacing: 20,
                              childAspectRatio: 0.85,
                            ),
                            itemCount: agencies.length,
                            itemBuilder: (context, index) {
                              final color = _agencyAccentPalette[
                                  index % _agencyAccentPalette.length];
                              final _AdminAgencyCardData agency =
                                  agencies[index];
                              return _AdminAgencyCard(
                                data: agency,
                                accentColor: color,
                                onViewDetails: () => _openAgencyDetails(agency),
                                onManageMembers: () =>
                                    _navigateToMemberManagementWithFilter(
                                        agency.name),
                              );
                            },
                          );
                        },
                      ),
              ),
            ),
          ),
        ],
      ),
    );

    if (_showAgencyMembersModal && _selectedAgencyForMembers != null) {
      return Stack(
        children: [
          baseContent,
          Positioned.fill(
            child: GestureDetector(
              behavior: HitTestBehavior.opaque,
              onTap: _closeAgencyMembersModal,
              child: Container(
                color: Colors.black.withOpacity(0.55),
                alignment: Alignment.center,
                child: LayoutBuilder(
                  builder: (context, constraints) {
                    final double horizontalPadding =
                        constraints.maxWidth < 720 ? 16 : 32;
                    return SingleChildScrollView(
                      padding: EdgeInsets.symmetric(
                          horizontal: horizontalPadding, vertical: 48),
                      child: Center(
                        child: GestureDetector(
                          onTap: () {},
                          child: StreamBuilder<QuerySnapshot>(
                            stream: FirebaseFirestore.instance
                                .collection('users')
                                .snapshots(),
                            builder: (context, snapshot) {
                              final List<_AdminMemberRowData> allMembers =
                                  snapshot.hasData
                                      ? snapshot.data!.docs.map((doc) {
                                          return _AdminMemberRowData
                                              .fromFirestore(
                                            doc.id,
                                            doc.data() as Map<String, dynamic>,
                                          );
                                        }).toList()
                                      : [];
                              return _AgencyMembersDialog(
                                agencyName: _selectedAgencyForMembers!,
                                allMembers: allMembers,
                                onClose: _closeAgencyMembersModal,
                              );
                            },
                          ),
                        ),
                      ),
                    );
                  },
                ),
              ),
            ),
          ),
        ],
      );
    }

    if (!_showAgencyDetailModal || _selectedAgencyDetail == null) {
      return baseContent;
    }

    final _AdminAgencyCardData agency = _selectedAgencyDetail!;

    return Stack(
      children: [
        baseContent,
        Positioned.fill(
          child: GestureDetector(
            behavior: HitTestBehavior.opaque,
            onTap: _closeAgencyDetails,
            child: Container(
              color: Colors.black.withOpacity(0.55),
              alignment: Alignment.center,
              child: FutureBuilder<_AgencyDetailSnapshot>(
                future: _resolveAgencySnapshot(agency),
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const Center(
                        child: CircularProgressIndicator(color: Colors.white));
                  }

                  final agencySnapshot = snapshot.data ??
                      _AgencyDetailSnapshot(
                        summary: 'Loading...',
                        startDate: 'Pending',
                        endDate: 'TBD',
                        programUtilization: 0.0,
                        memberEngagement: 0.0,
                        goalCompletion: 0.0,
                        totalMembers: agency.members,
                        activeMembers: 0,
                        pendingInvites: 0,
                        healthStatus: 'Loading',
                      );

                  return LayoutBuilder(
                    builder: (context, constraints) {
                      final double horizontalPadding =
                          constraints.maxWidth < 720 ? 16 : 32;
                      return SingleChildScrollView(
                        padding: EdgeInsets.symmetric(
                            horizontal: horizontalPadding, vertical: 48),
                        child: Center(
                          child: GestureDetector(
                            onTap: () {},
                            child: _AgencyDetailDialog(
                              agency: agency,
                              snapshot: agencySnapshot,
                              onClose: _closeAgencyDetails,
                              onManageMembers: () =>
                                  _navigateToMemberManagementWithFilter(
                                      agency.name),
                              onDelete: () async {
                                // Show confirmation dialog
                                final confirmed = await showDialog<bool>(
                                  context: context,
                                  builder: (ctx) => AlertDialog(
                                    shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(20),
                                    ),
                                    title: const Text('Delete Agency'),
                                    content: Text(
                                      'Are you sure you want to delete "${agency.name}"?\n\n'
                                      'This will remove the agency and reset all members\' agency association.',
                                    ),
                                    actions: [
                                      TextButton(
                                        onPressed: () => Navigator.pop(ctx, false),
                                        child: const Text('Cancel'),
                                      ),
                                      ElevatedButton(
                                        onPressed: () => Navigator.pop(ctx, true),
                                        style: ElevatedButton.styleFrom(
                                          backgroundColor: const Color(0xFFDC2626),
                                          foregroundColor: Colors.white,
                                        ),
                                        child: const Text('Delete'),
                                      ),
                                    ],
                                  ),
                                );

                                if (confirmed != true) return;

                                try {
                                  // Update all members with this agency - set their agency field to 'add to agency'
                                  final usersWithAgency = await FirebaseFirestore.instance
                                      .collection('users')
                                      .where('agency', isEqualTo: agency.name)
                                      .get();

                                  final batch = FirebaseFirestore.instance.batch();
                                  
                                  for (final userDoc in usersWithAgency.docs) {
                                    batch.update(userDoc.reference, {'agency': 'add to agency'});
                                  }

                                  // Delete the agency document
                                  batch.delete(FirebaseFirestore.instance.collection('agencies').doc(agency.id));

                                  await batch.commit();

                                  if (context.mounted) {
                                    ScaffoldMessenger.of(context)
                                      ..hideCurrentSnackBar()
                                      ..showSnackBar(
                                        SnackBar(
                                          content: Text('${agency.name} deleted successfully'),
                                          backgroundColor: const Color(0xFF22C55E),
                                          duration: const Duration(seconds: 3),
                                        ),
                                      );
                                    _closeAgencyDetails();
                                  }
                                } catch (e) {
                                  debugPrint('Error deleting agency: $e');
                                  if (context.mounted) {
                                    ScaffoldMessenger.of(context)
                                      ..hideCurrentSnackBar()
                                      ..showSnackBar(
                                        SnackBar(
                                          content: Text('Failed to delete agency: $e'),
                                          backgroundColor: const Color(0xFFDC2626),
                                          duration: const Duration(seconds: 4),
                                        ),
                                      );
                                  }
                                }
                              },
                            ),
                          ),
                        ),
                      );
                    },
                  );
                },
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildAgencyMetric({
    required IconData icon,
    required String label,
    required String value,
    required Color accent,
  }) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 18),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: accent.withOpacity(0.22)),
        boxShadow: [
          BoxShadow(
            color: accent.withOpacity(0.14),
            blurRadius: 18,
            offset: const Offset(0, 12),
          ),
        ],
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: 44,
            height: 44,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: accent.withOpacity(0.12),
            ),
            alignment: Alignment.center,
            child: Icon(icon, color: accent, size: 22),
          ),
          const SizedBox(width: 16),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                value,
                style: const TextStyle(
                  color: Color(0xFF0F172A),
                  fontSize: 18,
                  fontWeight: FontWeight.w800,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                label,
                style: const TextStyle(
                  color: Color(0xFF64748B),
                  fontSize: 13,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildAgencyFilterChip(int index, _AgencyFilterOption option) {
    final bool isActive = _activeAgencyFilterIndex == index;
    final Color activeColor = const Color(0xFF2563EB);
    return ChoiceChip(
      label: Text(option.label),
      selected: isActive,
      onSelected: (selected) {
        if (!selected) return;
        setState(() => _activeAgencyFilterIndex = index);
      },
      pressElevation: 0,
      selectedColor: activeColor.withOpacity(0.14),
      backgroundColor: const Color(0xFFF1F5FB),
      labelStyle: TextStyle(
        color: isActive ? activeColor : const Color(0xFF475569),
        fontWeight: FontWeight.w600,
      ),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      side: BorderSide(color: isActive ? activeColor : const Color(0xFFE2E8F0)),
    );
  }

  Widget _buildEmptyAgenciesState() {
    return Center(
      child: Container(
        width: 420,
        padding: const EdgeInsets.fromLTRB(32, 48, 32, 48),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(28),
          border: Border.all(color: const Color(0xFFE2E8F0)),
          boxShadow: const [
            BoxShadow(
              color: Color(0x11000000),
              blurRadius: 24,
              offset: Offset(0, 18),
            ),
          ],
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 72,
              height: 72,
              decoration: const BoxDecoration(
                shape: BoxShape.circle,
                color: Color(0xFFE0E7FF),
              ),
              alignment: Alignment.center,
              child: const Icon(Icons.search_off,
                  color: Color(0xFF2563EB), size: 30),
            ),
            const SizedBox(height: 20),
            const Text(
              'No agencies match your filters yet',
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Color(0xFF0F172A),
                fontSize: 18,
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 12),
            const Text(
              'Try adjusting your search or filter selection to discover more partners.',
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Color(0xFF64748B),
                fontSize: 14,
                height: 1.5,
              ),
            ),
            const SizedBox(height: 24),
            TextButton.icon(
              onPressed: () {
                _agencySearchController.clear();
                setState(() {
                  _agencySearchQuery = '';
                  _activeAgencyFilterIndex = 0;
                });
              },
              style: TextButton.styleFrom(
                foregroundColor: const Color(0xFF2563EB),
                textStyle:
                    const TextStyle(fontSize: 14, fontWeight: FontWeight.w700),
              ),
              icon: const Icon(Icons.refresh),
              label: const Text('Reset filters'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildMemberManagementStack() {
    final baseView = _AdminMemberManagementView(
      onCreateUsers: () => _handleSectionChange(AdminSection.createUsers),
      onPrimaryAction: _downloadRosterCSV,
      onSecondaryAction: _downloadRosterPDF,
      initialAgencyFilter: _selectedAgencyForFilter,
      onClearAgencyFilter: _clearAgencyFilter,
    );

    if (!_showCreateUsersModal) {
      return baseView;
    }

    return Stack(
      children: [
        baseView,
        Positioned.fill(
          child: Container(
            color: Colors.black.withOpacity(0.45),
            alignment: Alignment.center,
            child: LayoutBuilder(
              builder: (context, constraints) {
                final double horizontalPadding =
                    constraints.maxWidth < 720 ? 16 : 32;
                return SingleChildScrollView(
                  padding: EdgeInsets.symmetric(
                      horizontal: horizontalPadding, vertical: 40),
                  child: Center(
                    child: _AdminCreateUsersDialog(
                      onCancel: _closeCreateUsersModal,
                      onSubmit: _handleCreateUsersSubmit,
                    ),
                  ),
                );
              },
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildUploadContentStack() {
    final baseView = const ContentLibraryPage(isAdmin: true);

    if (!_showUploadContentModal) {
      return baseView;
    }

    return Stack(
      children: [
        baseView,
        Positioned.fill(
          child: Container(
            color: Colors.black.withOpacity(0.45),
            alignment: Alignment.center,
            child: LayoutBuilder(
              builder: (context, constraints) {
                final double horizontalPadding =
                    constraints.maxWidth < 720 ? 16 : 32;
                return SingleChildScrollView(
                  padding: EdgeInsets.symmetric(
                      horizontal: horizontalPadding, vertical: 40),
                  child: Center(
                    child: _AdminUploadContentDialog(
                      onCancel: _closeUploadContentModal,
                      onSubmit: _handleUploadContentSubmit,
                    ),
                  ),
                );
              },
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildActiveSectionView(ThemeData theme) {
    final key = ValueKey('admin_nav_$_navigationCounter');
    switch (_selectedSection) {
      case AdminSection.agencies:
        return _buildAgenciesView(theme);
      case AdminSection.memberManagement:
      case AdminSection.createUsers:
        return _buildMemberManagementStack();
      case AdminSection.contentLibrary:
        return ContentLibraryPage(key: key, isAdmin: true);
      case AdminSection.uploadContent:
        return _buildUploadContentStack();
      case AdminSection.postConfirmationMessaging:
        return _AdminPostConfirmationMessagingView(key: key);
      case AdminSection.messages:
        return MessagesPage(key: key);
      case AdminSection.discussionForum:
        return DiscussionForumPage(key: key);
      case AdminSection.systemSettings:
        return AdminSystemSettingsPage(key: key);
    }
  }

  String _resolvePlaceholderTitle(AdminSection section) {
    switch (section) {
      case AdminSection.createUsers:
        return 'Create New Users';
      case AdminSection.contentLibrary:
        return 'Content Library';
      case AdminSection.uploadContent:
        return 'Upload Content';
      case AdminSection.messages:
        return 'Messages';
      case AdminSection.discussionForum:
        return 'Discussion Forum';
      case AdminSection.postConfirmationMessaging:
        return 'Post-confirmation Message';
      case AdminSection.systemSettings:
        return 'System Settings';
      case AdminSection.agencies:
      case AdminSection.memberManagement:
        return 'Admin';
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Row(
          children: [
            _AdminSidebar(
              displayName: widget.displayName,
              roleLabel: widget.roleLabel ?? 'Admin',
              profileImageUrl: widget.profileImageUrl,
              selectedSection: _selectedSection,
              onSectionSelected: _handleSectionChange,
              onLogout: _handleLogout,
            ),
            Expanded(
              child: _buildActiveSectionView(theme),
            ),
          ],
        ),
      ),
    );
  }
}

class AdminAddAgencyPage extends StatefulWidget {
  const AdminAddAgencyPage({
    super.key,
    required this.displayName,
    this.roleLabel,
    this.profileImageUrl,
  });

  final String displayName;
  final String? roleLabel;
  final String? profileImageUrl;

  @override
  State<AdminAddAgencyPage> createState() => _AdminAddAgencyPageState();
}

class _AdminAddAgencyPageState extends State<AdminAddAgencyPage> {
  final TextEditingController _agencyNameController = TextEditingController();
  final TextEditingController _agencySummaryController =
      TextEditingController();
  final TextEditingController _locationController = TextEditingController();

  final FocusNode _agencyNameFocusNode = FocusNode();
  final FocusNode _agencySummaryFocusNode = FocusNode();
  final FocusNode _locationFocusNode = FocusNode();

  List<_DirectoryPersonOption> _memberOptions = [];
  List<String> _selectedMemberIds = [];
  bool _loadingMembers = true;

  Uint8List? _profilePreviewBytes;
  String? _profileFileName;

  bool _isSubmitting = false;

  @override
  void initState() {
    super.initState();
    _loadMembers();
  }

  @override
  void dispose() {
    _agencyNameController.dispose();
    _agencySummaryController.dispose();
    _locationController.dispose();
    _agencyNameFocusNode.dispose();
    _agencySummaryFocusNode.dispose();
    _locationFocusNode.dispose();
    super.dispose();
  }

  Future<void> _loadMembers() async {
    try {
      final snapshot =
          await FirebaseFirestore.instance.collection('users').limit(200).get();
      final options = snapshot.docs
          .map((doc) {
            final data = doc.data();
            final name = _resolveDisplayName(data);
            if (name == null || name.isEmpty) {
              return null;
            }
            return _DirectoryPersonOption(
              id: doc.id,
              name: name,
              subtitle: _resolveSubtitle(data),
              avatarUrl: _resolveAvatarUrl(data),
            );
          })
          .whereType<_DirectoryPersonOption>()
          .toList()
        ..sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));

      if (!mounted) return;
      setState(() {
        _memberOptions = options;
        _loadingMembers = false;
      });
    } catch (error, stackTrace) {
      debugPrint('‚ùå Failed to load members for agency assignment: $error');
      debugPrint('$stackTrace');
      if (!mounted) return;
      setState(() {
        _memberOptions = const [];
        _loadingMembers = false;
      });
    }
  }

  String? _resolveDisplayName(Map<String, dynamic> data) {
    final candidates = [
      data['display_name'],
      data['fullName'],
      data['name'],
      data['firstName'] != null || data['lastName'] != null
          ? [data['firstName'], data['lastName']]
              .where((s) => s != null && s.toString().trim().isNotEmpty)
              .join(' ')
              .trim()
          : null,
      data['first_name'] != null || data['last_name'] != null
          ? [data['first_name'], data['last_name']]
              .whereType<String>()
              .join(' ')
              .trim()
          : null,
    ];

    for (final candidate in candidates) {
      if (candidate is String && candidate.trim().isNotEmpty) {
        return candidate.trim();
      }
    }
    return null;
  }

  String? _resolveSubtitle(Map<String, dynamic> data) {
    final role = data['role'] ?? data['userRole'] ?? data['accountType'];
    if (role is String && role.trim().isNotEmpty) {
      return role.trim();
    }
    final email = data['email'];
    if (email is String && email.trim().isNotEmpty) {
      return email.trim();
    }
    return null;
  }

  String? _resolveAvatarUrl(Map<String, dynamic> data) {
    final candidates = [
      data['profileImageUrl'],
      data['profile_image_url'],
      data['photoURL'],
      data['profilePicture'],
      data['avatar'],
    ];
    for (final candidate in candidates) {
      if (candidate is String && candidate.trim().isNotEmpty) {
        return candidate.trim();
      }
    }
    return null;
  }

  Widget _buildMultiSelectDropdown() {
    return GestureDetector(
      onTap: _loadingMembers ? null : () => _showMemberSelectionDialog(),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          border: Border.all(color: const Color(0xFFE2E8F0)),
          borderRadius: BorderRadius.circular(12),
          color: Colors.white,
        ),
        child: Row(
          children: [
            Expanded(
              child: _selectedMemberIds.isEmpty
                  ? Text(
                      _loadingMembers ? 'Loading members...' : 'Add members',
                      style: const TextStyle(
                        color: Color(0xFF94A3B8),
                        fontSize: 14,
                      ),
                    )
                  : Wrap(
                      spacing: 6,
                      runSpacing: 4,
                      children: _selectedMemberIds.map((memberId) {
                        final member = _memberOptions
                            .where((option) => option.id == memberId)
                            .firstOrNull;
                        if (member == null) return const SizedBox.shrink();
                        return Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: const Color(0xFF0F172A),
                            borderRadius: BorderRadius.circular(16),
                          ),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Text(
                                member.name,
                                style: const TextStyle(
                                  color: Colors.white,
                                  fontSize: 12,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                              const SizedBox(width: 4),
                              GestureDetector(
                                onTap: () {
                                  setState(() {
                                    _selectedMemberIds.remove(memberId);
                                  });
                                },
                                child: const Icon(
                                  Icons.close,
                                  size: 14,
                                  color: Colors.white,
                                ),
                              ),
                            ],
                          ),
                        );
                      }).toList(),
                    ),
            ),
            const Icon(
              Icons.keyboard_arrow_down_rounded,
              color: Color(0xFF64748B),
            ),
          ],
        ),
      ),
    );
  }

  void _showMemberSelectionDialog() {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return Dialog(
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
              child: Container(
                width: MediaQuery.of(context).size.width * 0.8,
                constraints: BoxConstraints(
                  maxHeight: MediaQuery.of(context).size.height * 0.7,
                ),
                padding: const EdgeInsets.all(24),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      'Select Members',
                      style: TextStyle(
                        fontSize: 20,
                        fontWeight: FontWeight.w600,
                        color: Color(0xFF0F172A),
                      ),
                    ),
                    const SizedBox(height: 16),
                    Expanded(
                      child: ListView.builder(
                        itemCount: _memberOptions.length,
                        itemBuilder: (context, index) {
                          final option = _memberOptions[index];
                          final isSelected =
                              _selectedMemberIds.contains(option.id);
                          return CheckboxListTile(
                            value: isSelected,
                            onChanged: (bool? value) {
                              setDialogState(() {
                                if (value == true) {
                                  setState(() {
                                    _selectedMemberIds.add(option.id);
                                  });
                                } else {
                                  setState(() {
                                    _selectedMemberIds.remove(option.id);
                                  });
                                }
                              });
                            },
                            title: Row(
                              children: [
                                CircleAvatar(
                                  radius: 16,
                                  backgroundColor: const Color(0xFFE2E8F0),
                                  backgroundImage: option.avatarUrl != null
                                      ? NetworkImage(option.avatarUrl!)
                                      : null,
                                  child: option.avatarUrl == null
                                      ? Text(
                                          option.initials,
                                          style: const TextStyle(
                                            color: Color(0xFF1E293B),
                                            fontWeight: FontWeight.w600,
                                          ),
                                        )
                                      : null,
                                ),
                                const SizedBox(width: 12),
                                Expanded(
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        option.name,
                                        style: const TextStyle(
                                          fontSize: 14,
                                          fontWeight: FontWeight.w600,
                                          color: Color(0xFF0F172A),
                                        ),
                                      ),
                                      if (option.subtitle != null)
                                        Text(
                                          option.subtitle!,
                                          style: const TextStyle(
                                            fontSize: 12,
                                            color: Color(0xFF64748B),
                                          ),
                                        ),
                                    ],
                                  ),
                                ),
                              ],
                            ),
                            contentPadding: const EdgeInsets.symmetric(
                                horizontal: 0, vertical: 4),
                          );
                        },
                      ),
                    ),
                    const SizedBox(height: 16),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        TextButton(
                          onPressed: () => Navigator.of(context).pop(),
                          child: const Text('Cancel'),
                        ),
                        const SizedBox(width: 8),
                        ElevatedButton(
                          onPressed: () => Navigator.of(context).pop(),
                          child: Text(
                              'Select (${_selectedMemberIds.length}) Members'),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            );
          },
        );
      },
    );
  }

  Future<void> _pickProfileImage() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        allowMultiple: false,
        withData: true,
      );

      if (result == null || result.files.isEmpty) {
        return;
      }

      final file = result.files.first;
      if (file.bytes == null) {
        return;
      }

      setState(() {
        _profilePreviewBytes = file.bytes;
        _profileFileName = file.name;
      });
    } catch (error, stackTrace) {
      debugPrint('‚ùå Failed to pick agency profile image: $error');
      debugPrint('$stackTrace');
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content: Text('We couldn\'t load that image. Please try again.')),
      );
    }
  }

  Future<void> _handleCreateAgency() async {
    FocusScope.of(context).unfocus();

    // Validate required fields
    final agencyName = _agencyNameController.text.trim();
    if (agencyName.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter an agency name')),
      );
      return;
    }

    if (_locationController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter a location')),
      );
      return;
    }

    setState(() => _isSubmitting = true);

    try {
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) {
        throw Exception('You must be logged in to create an agency');
      }

      String? profileImageUrl;

      // Upload profile image if provided
      if (_profilePreviewBytes != null && _profileFileName != null) {
        debugPrint('üì§ Uploading agency profile image: $_profileFileName');

        final timestamp = DateTime.now().millisecondsSinceEpoch;
        final sanitizedFileName =
            _profileFileName!.replaceAll(RegExp(r'[^a-zA-Z0-9._-]'), '_');
        final gcsFileName =
            'agencies/$agencyName-$timestamp-$sanitizedFileName';

        profileImageUrl = await GCSService.uploadFile(
          fileName: gcsFileName,
          fileBytes: _profilePreviewBytes!,
          contentType: 'image/jpeg',
        );

        debugPrint('‚úÖ Agency profile image uploaded: $profileImageUrl');
      }

      // Get selected member details
      final selectedMembers = _memberOptions
          .where((option) => _selectedMemberIds.contains(option.id))
          .toList();

      // Create agency document
      final agencyData = {
        'agency_name': agencyName,
        'summary': _agencySummaryController.text.trim(),
        'location': _locationController.text.trim(),
        'profileImageUrl': profileImageUrl,
        'createdBy': currentUser.uid,
        'createdByName':
            currentUser.displayName ?? currentUser.email ?? 'Unknown',
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
        'status': 'active',
      };

      // Only add member-related fields if members are selected
      if (_selectedMemberIds.isNotEmpty) {
        agencyData.addAll({
          'assignedMemberIds': _selectedMemberIds,
          'assignedMemberNames': selectedMembers.map((m) => m.name).toList(),
          'memberCount': _selectedMemberIds.length,
        });
      }

      debugPrint('üíæ Saving agency to Firestore: $agencyName');

      final docRef = await FirebaseFirestore.instance
          .collection('agencies')
          .add(agencyData);

      debugPrint('‚úÖ Agency created successfully with ID: ${docRef.id}');

      // Update selected members with agency name and add them to agency's members field
      if (_selectedMemberIds.isNotEmpty) {
        final batch = FirebaseFirestore.instance.batch();
        final agencyRef =
            FirebaseFirestore.instance.collection('agencies').doc(docRef.id);

        // Add member references to agency's members field
        final memberRefs = _selectedMemberIds
            .map((memberId) =>
                FirebaseFirestore.instance.collection('users').doc(memberId))
            .toList();

        batch.update(agencyRef, {'members': memberRefs});

        // Update each selected member's agency field with agency name
        for (final memberId in _selectedMemberIds) {
          final userRef =
              FirebaseFirestore.instance.collection('users').doc(memberId);
          batch.update(userRef, {
            'agency': agencyName,
            'updatedAt': FieldValue.serverTimestamp(),
          });
        }

        await batch.commit();
        debugPrint(
            '‚úÖ Updated ${_selectedMemberIds.length} members with agency name');
      }

      if (!mounted) return;

      setState(() => _isSubmitting = false);

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Agency "$agencyName" created successfully!'),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 3),
        ),
      );

      // Navigate back to agencies page
      Navigator.of(context).pop();
    } catch (error, stackTrace) {
      debugPrint('‚ùå Failed to create agency: $error');
      debugPrint('$stackTrace');

      if (!mounted) return;

      setState(() => _isSubmitting = false);

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Failed to create agency: ${error.toString()}'),
          backgroundColor: Colors.red,
          duration: const Duration(seconds: 4),
        ),
      );
    }
  }

  void _handleSectionSelected(AdminSection section) {
    Navigator.of(context).pop(section);
  }

  InputDecoration _inputDecoration(String hint) {
    return InputDecoration(
      hintText: hint,
      filled: true,
      fillColor: const Color(0xFFF8FAFC),
      contentPadding: const EdgeInsets.symmetric(horizontal: 18, vertical: 16),
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(14),
        borderSide: const BorderSide(color: Color(0xFFE2E8F0)),
      ),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(14),
        borderSide: const BorderSide(color: Color(0xFFDDE3F1)),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(14),
        borderSide: const BorderSide(color: Color(0xFF2563EB), width: 1.6),
      ),
    );
  }

  Widget _buildFieldLabel(String label) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 10),
      child: Text(
        label,
        style: const TextStyle(
          color: Color(0xFF0F172A),
          fontSize: 15,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF0F5FC),
      body: SafeArea(
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _AdminSidebar(
              displayName: widget.displayName,
              roleLabel: widget.roleLabel ?? 'Admin',
              profileImageUrl: widget.profileImageUrl,
              selectedSection: AdminSection.agencies,
              onSectionSelected: _handleSectionSelected,
              onLogout: () async {
                await FirebaseAuth.instance.signOut();
                if (!mounted) return;
                Navigator.of(context).pushAndRemoveUntil(
                  MaterialPageRoute<void>(
                      builder: (_) => const AuthLandingPage()),
                  (route) => false,
                );
              },
            ),
            Expanded(
              child: Container(
                color: const Color(0xFFF0F5FC),
                alignment: Alignment.topCenter,
                child: SingleChildScrollView(
                  padding: const EdgeInsets.fromLTRB(48, 40, 48, 40),
                  child: ConstrainedBox(
                    constraints: const BoxConstraints(maxWidth: 1120),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text(
                          'Create your agency',
                          style: TextStyle(
                            fontSize: 28,
                            fontWeight: FontWeight.w800,
                            color: Color(0xFF0F172A),
                          ),
                        ),
                        const SizedBox(height: 28),
                        Container(
                          decoration: BoxDecoration(
                            color: Colors.white,
                            borderRadius: BorderRadius.circular(28),
                            border: Border.all(color: const Color(0xFFE2E8F0)),
                            boxShadow: const [
                              BoxShadow(
                                color: Color(0x14000000),
                                blurRadius: 32,
                                offset: Offset(0, 18),
                              ),
                            ],
                          ),
                          padding: const EdgeInsets.fromLTRB(36, 36, 36, 32),
                          child: LayoutBuilder(
                            builder: (context, constraints) {
                              final isCompact = constraints.maxWidth < 900;
                              final double fieldWidth = isCompact
                                  ? constraints.maxWidth
                                  : (constraints.maxWidth - 28) / 2;

                              return Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  _buildFieldLabel('Agency Profile Picture'),
                                  GestureDetector(
                                    onTap: _pickProfileImage,
                                    child: AnimatedContainer(
                                      duration:
                                          const Duration(milliseconds: 200),
                                      curve: Curves.easeOut,
                                      height: isCompact ? 260 : 280,
                                      width: double.infinity,
                                      decoration: BoxDecoration(
                                        color: const Color(0xFFF8FAFF),
                                        borderRadius: BorderRadius.circular(32),
                                        border: Border.all(
                                            color: const Color(0xFFE0E7FF)),
                                      ),
                                      child: _profilePreviewBytes == null
                                          ? Column(
                                              mainAxisAlignment:
                                                  MainAxisAlignment.center,
                                              children: const [
                                                Icon(
                                                  Icons.image_outlined,
                                                  size: 48,
                                                  color: Color(0xFF94A3B8),
                                                ),
                                                SizedBox(height: 12),
                                                Text(
                                                  'Upload a compelling cover image',
                                                  style: TextStyle(
                                                    fontSize: 16,
                                                    fontWeight: FontWeight.w600,
                                                    color: Color(0xFF475569),
                                                  ),
                                                ),
                                                SizedBox(height: 6),
                                                Text(
                                                  'PNG or JPG ‚Ä¢ 1200 x 800 recommended',
                                                  style: TextStyle(
                                                    fontSize: 13,
                                                    color: Color(0xFF94A3B8),
                                                  ),
                                                ),
                                              ],
                                            )
                                          : ClipRRect(
                                              borderRadius:
                                                  BorderRadius.circular(32),
                                              child: Stack(
                                                fit: StackFit.expand,
                                                children: [
                                                  Image.memory(
                                                    _profilePreviewBytes!,
                                                    fit: BoxFit.cover,
                                                  ),
                                                  Positioned(
                                                    right: 16,
                                                    bottom: 16,
                                                    child: DecoratedBox(
                                                      decoration: BoxDecoration(
                                                        color: Colors.black
                                                            .withOpacity(0.55),
                                                        borderRadius:
                                                            BorderRadius
                                                                .circular(16),
                                                      ),
                                                      child: Padding(
                                                        padding:
                                                            const EdgeInsets
                                                                .symmetric(
                                                          horizontal: 14,
                                                          vertical: 8,
                                                        ),
                                                        child: Row(
                                                          mainAxisSize:
                                                              MainAxisSize.min,
                                                          children: [
                                                            const Icon(
                                                              Icons.image,
                                                              size: 16,
                                                              color:
                                                                  Colors.white,
                                                            ),
                                                            const SizedBox(
                                                                width: 8),
                                                            Text(
                                                              _profileFileName ??
                                                                  'Selected image',
                                                              style:
                                                                  const TextStyle(
                                                                color: Colors
                                                                    .white,
                                                                fontSize: 13,
                                                                fontWeight:
                                                                    FontWeight
                                                                        .w600,
                                                              ),
                                                            ),
                                                          ],
                                                        ),
                                                      ),
                                                    ),
                                                  ),
                                                ],
                                              ),
                                            ),
                                    ),
                                  ),
                                  const SizedBox(height: 32),
                                  Wrap(
                                    spacing: 28,
                                    runSpacing: 24,
                                    children: [
                                      SizedBox(
                                        width: fieldWidth,
                                        child: Column(
                                          crossAxisAlignment:
                                              CrossAxisAlignment.start,
                                          children: [
                                            _buildFieldLabel('Agency Name'),
                                            TextFormField(
                                              controller: _agencyNameController,
                                              focusNode: _agencyNameFocusNode,
                                              textInputAction:
                                                  TextInputAction.next,
                                              decoration: _inputDecoration(
                                                  'Course name'),
                                            ),
                                          ],
                                        ),
                                      ),
                                      SizedBox(
                                        width: fieldWidth,
                                        child: Column(
                                          crossAxisAlignment:
                                              CrossAxisAlignment.start,
                                          children: [
                                            _buildFieldLabel('Agency Summary'),
                                            TextFormField(
                                              controller:
                                                  _agencySummaryController,
                                              focusNode:
                                                  _agencySummaryFocusNode,
                                              textInputAction:
                                                  TextInputAction.next,
                                              minLines: 1,
                                              maxLines: 3,
                                              decoration: _inputDecoration(
                                                  'Agency summary'),
                                            ),
                                          ],
                                        ),
                                      ),
                                      SizedBox(
                                        width: fieldWidth,
                                        child: Column(
                                          crossAxisAlignment:
                                              CrossAxisAlignment.start,
                                          children: [
                                            _buildFieldLabel('Assign Member'),
                                            _buildMultiSelectDropdown(),
                                          ],
                                        ),
                                      ),
                                      SizedBox(
                                        width: fieldWidth,
                                        child: Column(
                                          crossAxisAlignment:
                                              CrossAxisAlignment.start,
                                          children: [
                                            _buildFieldLabel('Location'),
                                            TextFormField(
                                              controller: _locationController,
                                              focusNode: _locationFocusNode,
                                              textInputAction:
                                                  TextInputAction.done,
                                              decoration:
                                                  _inputDecoration('Location'),
                                            ),
                                          ],
                                        ),
                                      ),
                                    ],
                                  ),
                                  const SizedBox(height: 36),
                                  Align(
                                    alignment: Alignment.centerRight,
                                    child: SizedBox(
                                      height: 56,
                                      child: ElevatedButton(
                                        style: ElevatedButton.styleFrom(
                                          elevation: 0,
                                          shape: RoundedRectangleBorder(
                                            borderRadius:
                                                BorderRadius.circular(18),
                                          ),
                                          padding: const EdgeInsets.symmetric(
                                              horizontal: 28),
                                          backgroundColor:
                                              const Color(0xFF14B8A6),
                                          foregroundColor: Colors.white,
                                        ),
                                        onPressed: _isSubmitting
                                            ? null
                                            : _handleCreateAgency,
                                        child: Row(
                                          mainAxisSize: MainAxisSize.min,
                                          children: [
                                            if (_isSubmitting)
                                              const SizedBox(
                                                width: 20,
                                                height: 20,
                                                child:
                                                    CircularProgressIndicator(
                                                  strokeWidth: 2.4,
                                                  valueColor:
                                                      AlwaysStoppedAnimation<
                                                          Color>(Colors.white),
                                                ),
                                              )
                                            else
                                              const Icon(
                                                  Icons.check_circle_outline,
                                                  size: 20),
                                            const SizedBox(width: 10),
                                            Text(
                                              _isSubmitting
                                                  ? 'Creating‚Ä¶'
                                                  : 'Create Agency',
                                              style: const TextStyle(
                                                fontSize: 16,
                                                fontWeight: FontWeight.w700,
                                              ),
                                            ),
                                          ],
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              );
                            },
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _DirectoryPersonOption {
  const _DirectoryPersonOption({
    required this.id,
    required this.name,
    this.subtitle,
    this.avatarUrl,
  });

  final String id;
  final String name;
  final String? subtitle;
  final String? avatarUrl;

  String get initials {
    final segments = name
        .split(RegExp(r'\s+'))
        .where((part) => part.trim().isNotEmpty)
        .toList();

    if (segments.isEmpty) {
      return name.isNotEmpty ? name.substring(0, 1).toUpperCase() : '?';
    }

    if (segments.length == 1) {
      final word = segments.first;
      return word.isNotEmpty ? word.substring(0, 1).toUpperCase() : '?';
    }

    final firstInitial = segments.first.isNotEmpty
        ? segments.first.substring(0, 1).toUpperCase()
        : '';
    final lastInitial = segments.last.isNotEmpty
        ? segments.last.substring(0, 1).toUpperCase()
        : '';
    final combined = '$firstInitial$lastInitial';
    return combined.isNotEmpty ? combined : '?';
  }
}

class _AdminSidebar extends StatelessWidget {
  const _AdminSidebar({
    required this.displayName,
    required this.roleLabel,
    this.profileImageUrl,
    required this.selectedSection,
    required this.onSectionSelected,
    required this.onLogout,
  });

  final String displayName;
  final String roleLabel;
  final String? profileImageUrl;
  final AdminSection selectedSection;
  final ValueChanged<AdminSection> onSectionSelected;
  final VoidCallback onLogout;

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 260,
      decoration: const BoxDecoration(
        color: Colors.white,
        boxShadow: [
          BoxShadow(
            color: Color(0x14000000),
            blurRadius: 20,
            offset: Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: double.infinity,
            color: const Color(0xFFF8FAFC),
            padding: const EdgeInsets.fromLTRB(24, 28, 24, 32),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(
                  height: 44,
                  child: Image.asset(
                    'assets/images/Breakaway365_small_white.png',
                    fit: BoxFit.contain,
                  ),
                ),
                const SizedBox(height: 28),
                Container(
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(18),
                    border: Border.all(color: const Color(0xFFE2E8F0)),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Container(
                            height: 44,
                            width: 44,
                            decoration: BoxDecoration(
                              shape: BoxShape.circle,
                              color: const Color(0xFF2563EB).withOpacity(0.12),
                              image: profileImageUrl != null &&
                                      profileImageUrl!.isNotEmpty
                                  ? DecorationImage(
                                      image: NetworkImage(profileImageUrl!),
                                      fit: BoxFit.cover,
                                    )
                                  : null,
                            ),
                            alignment: Alignment.center,
                            child: profileImageUrl == null ||
                                    profileImageUrl!.isEmpty
                                ? const Icon(Icons.person_outline,
                                    color: Color(0xFF2563EB))
                                : null,
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  displayName,
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                  style: const TextStyle(
                                    fontSize: 17,
                                    fontWeight: FontWeight.w700,
                                    color: Color(0xFF0F172A),
                                  ),
                                ),
                                const SizedBox(height: 4),
                                Text(
                                  roleLabel,
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                  style: const TextStyle(
                                    fontSize: 13,
                                    fontWeight: FontWeight.w500,
                                    color: Color(0xFF64748B),
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 16),
                      Align(
                        alignment: Alignment.centerLeft,
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 10, vertical: 6),
                          decoration: BoxDecoration(
                            color: const Color(0xFF2563EB).withOpacity(0.08),
                            borderRadius: BorderRadius.circular(999),
                          ),
                          child: const Text(
                            'Admin',
                            style: TextStyle(
                              fontSize: 11,
                              fontWeight: FontWeight.w600,
                              color: Color(0xFF1D4ED8),
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.fromLTRB(24, 0, 24, 0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _AdminSidebarSection(
                    title: 'MAIN',
                    selectedSection: selectedSection,
                    onSectionSelected: onSectionSelected,
                    items: [
                      _AdminSidebarItem(
                        icon: Icons.apartment,
                        label: 'Agencies',
                        section: AdminSection.agencies,
                      ),
                    ],
                  ),
                  _AdminSidebarSection(
                    title: 'USER MANAGEMENT',
                    selectedSection: selectedSection,
                    onSectionSelected: onSectionSelected,
                    items: [
                      _AdminSidebarItem(
                        icon: Icons.group_outlined,
                        label: 'Member Management',
                        section: AdminSection.memberManagement,
                      ),
                      _AdminSidebarItem(
                        icon: Icons.person_add_alt_1_outlined,
                        label: 'Create New Users',
                        section: AdminSection.createUsers,
                      ),
                    ],
                  ),
                  _AdminSidebarSection(
                    title: 'CONTENT MANAGEMENT',
                    selectedSection: selectedSection,
                    onSectionSelected: onSectionSelected,
                    items: [
                      _AdminSidebarItem(
                        icon: Icons.library_books_outlined,
                        label: 'Content Library',
                        section: AdminSection.contentLibrary,
                      ),
                      _AdminSidebarItem(
                        icon: Icons.cloud_upload_outlined,
                        label: 'Upload Content',
                        section: AdminSection.uploadContent,
                      ),
                      _AdminSidebarItem(
                        icon: Icons.mark_email_read_outlined,
                        label: 'Post-confirmation Message',
                        section: AdminSection.postConfirmationMessaging,
                      ),
                      _AdminSidebarItem(
                        icon: Icons.message_outlined,
                        label: 'Messages',
                        section: AdminSection.messages,
                      ),
                      _AdminSidebarItem(
                        icon: Icons.forum_outlined,
                        label: 'Discussion Forum',
                        section: AdminSection.discussionForum,
                      ),
                    ],
                  ),
                  _AdminSidebarSection(
                    title: 'SETTINGS',
                    selectedSection: selectedSection,
                    onSectionSelected: onSectionSelected,
                    items: [
                      const _AdminSidebarItem(
                        icon: Icons.settings_outlined,
                        label: 'System Settings',
                        section: AdminSection.systemSettings,
                      ),
                      _AdminSidebarItem(
                        icon: Icons.logout,
                        label: 'Logout',
                        isDestructive: true,
                        onTap: onLogout,
                      ),
                    ],
                  ),
                  const SizedBox(height: 24),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _AdminSidebarSection extends StatelessWidget {
  const _AdminSidebarSection({
    required this.title,
    required this.items,
    required this.selectedSection,
    required this.onSectionSelected,
  });

  final String title;
  final List<_AdminSidebarItem> items;
  final AdminSection selectedSection;
  final ValueChanged<AdminSection> onSectionSelected;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 28),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: const TextStyle(
              fontSize: 12,
              letterSpacing: 1.2,
              fontWeight: FontWeight.w700,
              color: Color(0xFF9CA3AF),
            ),
          ),
          const SizedBox(height: 12),
          for (final item in items)
            _AdminSidebarTile(
              item: item,
              selectedSection: selectedSection,
              onSectionSelected: onSectionSelected,
            ),
        ],
      ),
    );
  }
}

class _AdminSidebarItem {
  const _AdminSidebarItem({
    required this.icon,
    required this.label,
    this.section,
    this.isActive = false,
    this.isDestructive = false,
    this.onTap,
  });

  final IconData icon;
  final String label;
  final AdminSection? section;
  final bool isActive;
  final bool isDestructive;
  final VoidCallback? onTap;
}

class _AdminSidebarTile extends StatelessWidget {
  const _AdminSidebarTile({
    required this.item,
    required this.selectedSection,
    required this.onSectionSelected,
  });

  final _AdminSidebarItem item;
  final AdminSection selectedSection;
  final ValueChanged<AdminSection> onSectionSelected;

  @override
  Widget build(BuildContext context) {
    final bool active =
        item.section != null ? item.section == selectedSection : item.isActive;
    final bool destructive = item.isDestructive;
    return Padding(
      padding: const EdgeInsets.only(bottom: 6),
      child: Material(
        color: active
            ? const Color(0xFFEFF5FF)
            : destructive
                ? const Color(0xFFFFF5F5)
                : Colors.transparent,
        borderRadius: BorderRadius.circular(12),
        child: InkWell(
          borderRadius: BorderRadius.circular(12),
          onTap: () {
            if (item.section != null) {
              onSectionSelected(item.section!);
            } else {
              item.onTap?.call();
            }
          },
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 12),
            child: Row(
              children: [
                Icon(
                  item.icon,
                  size: 20,
                  color: destructive
                      ? const Color(0xFFDC2626)
                      : active
                          ? const Color(0xFF1D4ED8)
                          : const Color(0xFF374151),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    item.label,
                    style: TextStyle(
                      fontSize: 14,
                      fontWeight: active ? FontWeight.w700 : FontWeight.w500,
                      color: destructive
                          ? const Color(0xFFDC2626)
                          : active
                              ? const Color(0xFF1D4ED8)
                              : const Color(0xFF374151),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class _AdminPostConfirmationMessagingView extends StatefulWidget {
  const _AdminPostConfirmationMessagingView({super.key});

  @override
  State<_AdminPostConfirmationMessagingView> createState() =>
      _AdminPostConfirmationMessagingViewState();
}

class _AdminPostConfirmationMessagingViewState
    extends State<_AdminPostConfirmationMessagingView> {
  final TextEditingController _apiKeyController = TextEditingController();
  final TextEditingController _fromNameController =
      TextEditingController(text: 'Breakaway365 Team');
  final TextEditingController _fromEmailController =
      TextEditingController(text: 'support@breakaway365.com');
  final TextEditingController _subjectController = TextEditingController(
    text: "You're all set ‚Äì Welcome to Breakaway365!",
  );
  final TextEditingController _preheaderController = TextEditingController(
    text:
        'Here is what happens next and how to get the most out of your membership.',
  );
  final TextEditingController _messageController = TextEditingController(
    text:
        'Hi {{firstName}},\n\nWe just confirmed your account and unlocked the full Breakaway365 experience for you.\n\nHere is how to make the most of today:\n‚Ä¢ Bookmark your dashboard so you can jump back in quickly.\n‚Ä¢ Meet your coach inside the community forums to align on goals.\n‚Ä¢ Review the first learning sprint we handpicked for new members.\n\nIf you run into any questions, reply to this email and our team will help within one business day.\n\nLet‚Äôs build something extraordinary together,\nBreakaway365 Success Team',
  );
  final TextEditingController _ctaLabelController =
      TextEditingController(text: 'Open My Dashboard');
  final TextEditingController _ctaUrlController =
      TextEditingController(text: 'https://app.breakaway365.com/login');

  bool _savingSettings = false;
  bool _sendingPreview = false;
  String? _statusMessage;
  bool _statusIsError = false;

  @override
  void dispose() {
    _apiKeyController.dispose();
    _fromNameController.dispose();
    _fromEmailController.dispose();
    _subjectController.dispose();
    _preheaderController.dispose();
    _messageController.dispose();
    _ctaLabelController.dispose();
    _ctaUrlController.dispose();
    super.dispose();
  }

  Future<void> _handleSaveSettings() async {
    if (_savingSettings) return;
    setState(() {
      _savingSettings = true;
      _statusMessage = null;
    });
    await Future<void>.delayed(const Duration(milliseconds: 750));
    if (!mounted) return;
    setState(() {
      _savingSettings = false;
      _statusIsError = false;
      _statusMessage =
          'Settings captured locally. Connect backend storage to persist SendGrid credentials.';
    });
  }

  Future<void> _handleSendPreview() async {
    if (_sendingPreview) return;
    if (_fromEmailController.text.trim().isEmpty) {
      setState(() {
        _statusIsError = true;
        _statusMessage =
            'Add a reply-to email so we know where to deliver the preview.';
      });
      return;
    }
    setState(() {
      _sendingPreview = true;
      _statusMessage = null;
    });
    await Future<void>.delayed(const Duration(milliseconds: 900));
    if (!mounted) return;
    setState(() {
      _sendingPreview = false;
      _statusIsError = false;
      _statusMessage =
          'Preview queued. Wire this action to your backend to trigger the SendGrid send.';
    });
  }

  void _insertToken(String token) {
    final TextSelection selection = _messageController.selection;
    final String text = _messageController.text;
    final int start = selection.start >= 0 ? selection.start : text.length;
    final int end = selection.end >= 0 ? selection.end : text.length;
    final String newText = text.replaceRange(start, end, token);
    _messageController.value = TextEditingValue(
      text: newText,
      selection: TextSelection.collapsed(offset: start + token.length),
    );
  }

  @override
  Widget build(BuildContext context) {
    final ThemeData theme = Theme.of(context);
    return Container(
      color: const Color(0xFFF6F7FB),
      child: LayoutBuilder(
        builder: (context, constraints) {
          final bool stackVertically = constraints.maxWidth < 1200;
          return SingleChildScrollView(
            padding: const EdgeInsets.fromLTRB(32, 32, 32, 48),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildHeroHeader(
                    stackVertically: stackVertically, theme: theme),
                const SizedBox(height: 26),
                if (_statusMessage != null)
                  _StatusBanner(
                    message: _statusMessage!,
                    isError: _statusIsError,
                  ),
                if (_statusMessage != null) const SizedBox(height: 20),
                Flex(
                  direction: stackVertically ? Axis.vertical : Axis.horizontal,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    if (stackVertically) ...[
                      _buildDeliverySettingsCard(theme),
                      const SizedBox(height: 24),
                      _buildTemplateComposerCard(theme),
                      const SizedBox(height: 28),
                      _buildLivePreview(theme),
                    ] else ...[
                      Flexible(
                        flex: 6,
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.stretch,
                          children: [
                            _buildDeliverySettingsCard(theme),
                            const SizedBox(height: 24),
                            _buildTemplateComposerCard(theme),
                          ],
                        ),
                      ),
                      const SizedBox(width: 28),
                      Flexible(
                        flex: 5,
                        child: _buildLivePreview(theme),
                      ),
                    ],
                  ],
                ),
              ],
            ),
          );
        },
      ),
    );
  }

  Widget _buildHeroHeader(
      {required bool stackVertically, required ThemeData theme}) {
    return Container(
      decoration: BoxDecoration(
        gradient: const LinearGradient(
          colors: [Color(0xFF1F3EF8), Color(0xFF2563EB)],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(28),
        boxShadow: const [
          BoxShadow(
              color: Color(0x331F3EF8), blurRadius: 30, offset: Offset(0, 20)),
        ],
      ),
      padding: EdgeInsets.fromLTRB(
          stackVertically ? 24 : 32, 28, stackVertically ? 24 : 32, 32),
      child: stackVertically
          ? Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _HeroChip(label: 'Post-confirmation messaging'),
                const SizedBox(height: 20),
                _HeroHeadline(
                  title: 'Delight members the moment they join',
                  subtitle:
                      'Compose onboarding emails, capture your SendGrid API key, and preview exactly what members see after activating their account.',
                ),
                const SizedBox(height: 24),
                _OutlookHighlights(),
              ],
            )
          : Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: const [
                Expanded(
                  flex: 2,
                  child: _HeroHeadline(
                    title: 'Delight members the moment they join',
                    subtitle:
                        'Compose onboarding emails, capture your SendGrid API key, and preview exactly what members see after activating their account.',
                  ),
                ),
                SizedBox(width: 32),
                Expanded(flex: 1, child: _OutlookHighlights()),
              ],
            ),
    );
  }

  Widget _buildDeliverySettingsCard(ThemeData theme) {
    return _AdminCard(
      title: 'Delivery settings',
      subtitle:
          'Secure your SendGrid credentials and define the sender identity members receive.',
      trailing: TextButton.icon(
        onPressed: _savingSettings ? null : _handleSaveSettings,
        icon: _savingSettings
            ? const SizedBox(
                width: 18,
                height: 18,
                child: CircularProgressIndicator(strokeWidth: 2))
            : const Icon(Icons.save_outlined),
        label: Text(_savingSettings ? 'Saving‚Ä¶' : 'Save settings'),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _LabeledField(
            label: 'SendGrid API key',
            helper:
                'Stored securely server-side. Use an API key with Mail Send permissions only.',
            child: TextField(
              controller: _apiKeyController,
              obscureText: true,
              decoration: _fieldDecoration('SG.xxxxxx')
                  .copyWith(prefixIcon: const Icon(Icons.key_rounded)),
            ),
          ),
          const SizedBox(height: 18),
          Flex(
            direction: Axis.horizontal,
            children: [
              Expanded(
                child: _LabeledField(
                  label: 'From name',
                  child: TextField(
                    controller: _fromNameController,
                    textCapitalization: TextCapitalization.words,
                    decoration: _fieldDecoration('Breakaway365 Team'),
                  ),
                ),
              ),
              const SizedBox(width: 18),
              Expanded(
                child: _LabeledField(
                  label: 'Reply-to email',
                  child: TextField(
                    controller: _fromEmailController,
                    keyboardType: TextInputType.emailAddress,
                    decoration: _fieldDecoration('team@breakaway365.com'),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildTemplateComposerCard(ThemeData theme) {
    return _AdminCard(
      title: 'Message template',
      subtitle:
          'Craft the warm welcome note every confirmed member receives. Personalise it with dynamic tokens.',
      trailing: Wrap(
        spacing: 12,
        children: [
          OutlinedButton.icon(
            onPressed: _sendingPreview ? null : _handleSendPreview,
            icon: _sendingPreview
                ? const SizedBox(
                    width: 18,
                    height: 18,
                    child: CircularProgressIndicator(strokeWidth: 2))
                : const Icon(Icons.send_outlined),
            label: Text(_sendingPreview ? 'Sending‚Ä¶' : 'Send preview'),
          ),
          FilledButton.icon(
            onPressed: () => _insertToken('{{dashboardLink}}'),
            icon: const Icon(Icons.auto_awesome_motion_outlined),
            label: const Text('Insert dashboard link'),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Flex(
            direction: Axis.horizontal,
            children: [
              Expanded(
                child: _LabeledField(
                  label: 'Subject line',
                  child: TextField(
                    controller: _subjectController,
                    decoration:
                        _fieldDecoration('Subject line members can‚Äôt miss'),
                  ),
                ),
              ),
              const SizedBox(width: 18),
              Expanded(
                child: _LabeledField(
                  label: 'Preheader text',
                  child: TextField(
                    controller: _preheaderController,
                    decoration: _fieldDecoration(
                        'Short teaser shown beside the subject'),
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 20),
          Text(
            'Personalisation tokens',
            style: theme.textTheme.titleSmall?.copyWith(
                color: const Color(0xFF1F2937), fontWeight: FontWeight.w700),
          ),
          const SizedBox(height: 12),
          Wrap(
            spacing: 12,
            runSpacing: 10,
            children: [
              for (final token in const [
                '{{firstName}}',
                '{{lastName}}',
                '{{agencyName}}',
                '{{dashboardLink}}',
                '{{supportEmail}}'
              ])
                _TokenChip(label: token, onTap: () => _insertToken(token)),
            ],
          ),
          const SizedBox(height: 20),
          _LabeledField(
            label: 'Email body',
            child: TextField(
              controller: _messageController,
              keyboardType: TextInputType.multiline,
              minLines: 12,
              maxLines: 16,
              decoration:
                  _fieldDecoration('Write a clear, inspiring welcome message'),
            ),
          ),
          const SizedBox(height: 20),
          Flex(
            direction: Axis.horizontal,
            children: [
              Expanded(
                child: _LabeledField(
                  label: 'Call-to-action label',
                  child: TextField(
                    controller: _ctaLabelController,
                    decoration: _fieldDecoration('Open My Dashboard'),
                  ),
                ),
              ),
              const SizedBox(width: 18),
              Expanded(
                child: _LabeledField(
                  label: 'Call-to-action URL',
                  child: TextField(
                    controller: _ctaUrlController,
                    decoration:
                        _fieldDecoration('https://app.breakaway365.com/login'),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildLivePreview(ThemeData theme) {
    final String previewBody = _messageController.text.replaceAll('\n', '\n\n');
    return _AdminCard(
      title: 'Live preview',
      subtitle:
          'See the exact experience members receive across desktop clients.',
      child: Container(
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(24),
          border: Border.all(color: const Color(0xFFE2E8F0)),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Container(
              padding: const EdgeInsets.fromLTRB(22, 20, 22, 20),
              decoration: BoxDecoration(
                color: const Color(0xFFF8FAFC),
                borderRadius:
                    const BorderRadius.vertical(top: Radius.circular(24)),
                border:
                    Border(bottom: BorderSide(color: const Color(0xFFE2E8F0))),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'From: ${_fromNameController.text} <${_fromEmailController.text}>',
                    style: theme.textTheme.bodySmall?.copyWith(
                        color: const Color(0xFF475569),
                        fontWeight: FontWeight.w600),
                  ),
                  const SizedBox(height: 6),
                  Text(
                    'Subject: ${_subjectController.text}',
                    style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w700,
                        color: const Color(0xFF0F172A)),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    _preheaderController.text,
                    style: theme.textTheme.bodySmall
                        ?.copyWith(color: const Color(0xFF64748B)),
                  ),
                ],
              ),
            ),
            Padding(
              padding: const EdgeInsets.fromLTRB(22, 22, 22, 26),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Container(
                        width: 42,
                        height: 42,
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          color: const Color(0xFF2563EB).withOpacity(0.12),
                        ),
                        alignment: Alignment.center,
                        child: const Icon(Icons.mark_email_unread_outlined,
                            color: Color(0xFF2563EB)),
                      ),
                      const SizedBox(width: 14),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'Hi {{firstName}}',
                              style: theme.textTheme.titleMedium?.copyWith(
                                color: const Color(0xFF0F172A),
                                fontWeight: FontWeight.w700,
                              ),
                            ),
                            const SizedBox(height: 12),
                            SelectableText(
                              previewBody,
                              style: theme.textTheme.bodyMedium?.copyWith(
                                  color: const Color(0xFF475569), height: 1.55),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 24),
                  ConstrainedBox(
                    constraints: const BoxConstraints(maxWidth: 260),
                    child: FilledButton(
                      style: FilledButton.styleFrom(
                        backgroundColor: const Color(0xFF2563EB),
                        shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(14)),
                        padding: const EdgeInsets.symmetric(
                            horizontal: 20, vertical: 16),
                        textStyle: theme.textTheme.titleSmall?.copyWith(
                            fontWeight: FontWeight.w700, color: Colors.white),
                      ),
                      onPressed: () {},
                      child: Text(_ctaLabelController.text),
                    ),
                  ),
                  const SizedBox(height: 18),
                  Container(
                    padding: const EdgeInsets.all(14),
                    decoration: BoxDecoration(
                      color: const Color(0xFFF8FAFC),
                      borderRadius: BorderRadius.circular(16),
                      border: Border.all(color: const Color(0xFFE2E8F0)),
                    ),
                    child: Row(
                      children: [
                        const Icon(Icons.info_outline,
                            color: Color(0xFF2563EB), size: 20),
                        const SizedBox(width: 10),
                        Expanded(
                          child: Text(
                            'Preview shows placeholder tokens. Replace {{firstName}} etc. with real member data before sending.',
                            style: theme.textTheme.bodySmall?.copyWith(
                                color: const Color(0xFF475569), height: 1.45),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  InputDecoration _fieldDecoration(String hint) {
    return InputDecoration(
      hintText: hint,
      filled: true,
      fillColor: Colors.white,
      contentPadding: const EdgeInsets.symmetric(horizontal: 18, vertical: 16),
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(16),
        borderSide: const BorderSide(color: Color(0xFFE2E8F0)),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(16),
        borderSide: const BorderSide(color: Color(0xFF2563EB), width: 1.4),
      ),
    );
  }
}

class _StatusBanner extends StatelessWidget {
  const _StatusBanner({required this.message, required this.isError});

  final String message;
  final bool isError;

  @override
  Widget build(BuildContext context) {
    final Color background =
        isError ? const Color(0xFFFFE4E6) : const Color(0xFFE6F6FF);
    final Color border =
        isError ? const Color(0xFFFCA5A5) : const Color(0xFF93C5FD);
    final Color textColor =
        isError ? const Color(0xFFB91C1C) : const Color(0xFF1D4ED8);
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
      decoration: BoxDecoration(
        color: background,
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: border),
      ),
      child: Row(
        children: [
          Icon(isError ? Icons.error_outline : Icons.check_circle_outline,
              color: textColor),
          const SizedBox(width: 10),
          Expanded(
            child: Text(
              message,
              style: TextStyle(color: textColor, fontWeight: FontWeight.w600),
            ),
          ),
        ],
      ),
    );
  }
}

class _HeroChip extends StatelessWidget {
  const _HeroChip({required this.label});

  final String label;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.16),
        borderRadius: BorderRadius.circular(999),
        border: Border.all(color: Colors.white.withOpacity(0.28)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Icon(Icons.mark_email_read_outlined,
              color: Colors.white, size: 18),
          const SizedBox(width: 8),
          Text(
            label,
            style: const TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.w600,
                letterSpacing: 0.4),
          ),
        ],
      ),
    );
  }
}

class _HeroHeadline extends StatelessWidget {
  const _HeroHeadline({required this.title, required this.subtitle});

  final String title;
  final String subtitle;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            color: Colors.white,
            fontSize: 26,
            fontWeight: FontWeight.w800,
            height: 1.2,
          ),
        ),
        const SizedBox(height: 10),
        Text(
          subtitle,
          style: TextStyle(
            color: Colors.white.withOpacity(0.85),
            fontSize: 15,
            height: 1.5,
            fontWeight: FontWeight.w500,
          ),
        ),
      ],
    );
  }
}

class _OutlookHighlights extends StatelessWidget {
  const _OutlookHighlights();

  @override
  Widget build(BuildContext context) {
    final TextStyle metricStyle = const TextStyle(
        color: Colors.white, fontWeight: FontWeight.w700, fontSize: 16);
    final TextStyle captionStyle = TextStyle(
        color: Colors.white.withOpacity(0.78), fontSize: 12, height: 1.4);
    return Container(
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.14),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: Colors.white.withOpacity(0.18)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          _HeroChip(label: 'Automations snapshot'),
          const SizedBox(height: 16),
          Text('89%', style: metricStyle),
          Text('members open post-confirmation emails within 2 hours.',
              style: captionStyle),
          const SizedBox(height: 14),
          Text('47%', style: metricStyle),
          Text('click the primary CTA when the message includes next steps.',
              style: captionStyle),
          const SizedBox(height: 14),
          Text('2.1√ó', style: metricStyle),
          Text(
              'increase in course adoption when the CTA links straight to the dashboard.',
              style: captionStyle),
        ],
      ),
    );
  }
}

class _AdminCard extends StatelessWidget {
  const _AdminCard({
    required this.title,
    required this.child,
    this.subtitle,
    this.trailing,
  });

  final String title;
  final String? subtitle;
  final Widget child;
  final Widget? trailing;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.fromLTRB(26, 26, 26, 28),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(26),
        border: Border.all(color: const Color(0xFFE2E8F0)),
        boxShadow: const [
          BoxShadow(
              color: Color(0x0F000000), blurRadius: 28, offset: Offset(0, 18)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: const TextStyle(
                        color: Color(0xFF0F172A),
                        fontSize: 18,
                        fontWeight: FontWeight.w800,
                      ),
                    ),
                    if (subtitle != null) ...[
                      const SizedBox(height: 6),
                      Text(
                        subtitle!,
                        style: const TextStyle(
                            color: Color(0xFF475569),
                            fontSize: 13,
                            height: 1.45),
                      ),
                    ],
                  ],
                ),
              ),
              if (trailing != null) ...[
                const SizedBox(width: 16),
                trailing!,
              ],
            ],
          ),
          const SizedBox(height: 24),
          child,
        ],
      ),
    );
  }
}

class _LabeledField extends StatelessWidget {
  const _LabeledField({required this.label, required this.child, this.helper});

  final String label;
  final Widget child;
  final String? helper;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: const TextStyle(
            color: Color(0xFF1F2937),
            fontSize: 13,
            fontWeight: FontWeight.w700,
          ),
        ),
        const SizedBox(height: 8),
        child,
        if (helper != null) ...[
          const SizedBox(height: 6),
          Text(
            helper!,
            style: const TextStyle(
                color: Color(0xFF64748B), fontSize: 11, height: 1.45),
          ),
        ],
      ],
    );
  }
}

class _TokenChip extends StatelessWidget {
  const _TokenChip({required this.label, required this.onTap});

  final String label;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
        decoration: BoxDecoration(
          color: const Color(0xFFEEF2FF),
          borderRadius: BorderRadius.circular(14),
          border: Border.all(color: const Color(0xFFE0E7FF)),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.add_circle_outline,
                size: 16, color: Color(0xFF4F46E5)),
            const SizedBox(width: 8),
            Text(
              label,
              style: const TextStyle(
                  color: Color(0xFF4338CA),
                  fontWeight: FontWeight.w700,
                  fontSize: 12),
            ),
          ],
        ),
      ),
    );
  }
}

enum _AdminMemberTab { all, byCoach, byAgency }

enum _AdminMemberActionType {
  approve,
  assignCoach,
  reassignCoach,
  removeMember,
  none
}

enum _AdminMemberFocus { all, pendingApproval, needsCoach, activelyCoached }

class _AdminMemberRowData {
  const _AdminMemberRowData({
    required this.userId,
    required this.name,
    required this.role,
    required this.agency,
    required this.coach,
    required this.progress,
    required this.actionType,
    required this.email,
    this.hasSecondaryAction = false,
    this.approved = true,
    this.hasCoachAssignment = false,
    this.profileImageUrl,
    this.completedModules = const [],
    this.coachId,
  });

  final String userId;
  final String name;
  final String role;
  final String agency;
  final String coach;
  final double progress;
  final _AdminMemberActionType actionType;
  final String email;
  final bool hasSecondaryAction;
  final bool approved;
  final bool hasCoachAssignment;
  final String? profileImageUrl;
  final List<Map<String, String>> completedModules;
  final String? coachId;

  static Future<_AdminMemberRowData> fromFirestoreAsync(
    String userId,
    Map<String, dynamic> data, {
    bool hasCoachAssignment = false,
    String? agencyName,
    String? coachName,
    String? coachId,
  }) async {
    // --- ROBUST NAME RESOLUTION START ---
    final candidates = [
      data['display_name'],
      data['fullName'],
      data['name'],
      data['firstName'] != null || data['lastName'] != null
          ? [data['firstName'], data['lastName']]
              .where((s) => s != null && s.toString().trim().isNotEmpty)
              .join(' ')
              .trim()
          : null,
      data['first_name'] != null || data['last_name'] != null
          ? [data['first_name'], data['last_name']]
              .where((s) => s != null && s.toString().trim().isNotEmpty)
              .join(' ')
              .trim()
          : null,
      data['username'],
    ];

    String name = '';
    for (final candidate in candidates) {
      if (candidate != null &&
          candidate is String &&
          candidate.trim().isNotEmpty) {
        name = candidate.trim();
        break;
      }
    }
    if (name.isEmpty) {
      debugPrint(
          '‚ö†Ô∏è _AdminMemberRowData: Name resolution failed for user $userId. Data keys: ${data.keys.toList()}');
      name = 'Unnamed User';
    } else {
      debugPrint('‚úÖ _AdminMemberRowData: Resolved name "$name" for user $userId');
    }
    // --- ROBUST NAME RESOLUTION END ---

    final String role = (data['role'] as String? ?? 'Member').trim();
    final bool approved = data['isApproved'] as bool? ??
        data['approved'] as bool? ??
        data['accountStatus'] == 'approved' ??
        false;

    // Use agencyName from parameter (looked up from agencies collection) if provided
    String resolvedAgencyName = agencyName ?? 'add to agency';

    // Fallback to reading from user document if not found in agencies collection
    if (resolvedAgencyName == 'add to agency') {
      dynamic agencyField = data['agency'];
      if (agencyField is DocumentReference) {
        resolvedAgencyName = agencyField.id;
      } else if (agencyField is String && agencyField.isNotEmpty) {
        resolvedAgencyName = agencyField;
      } else if (data['agencyName'] is String &&
          (data['agencyName'] as String).isNotEmpty) {
        resolvedAgencyName = data['agencyName'] as String;
      }
    }

    // Use coachName from parameter (looked up from member_coach collection) if provided
    String resolvedCoachName = coachName ?? '';

    // Fallback to reading from user document if not found in member_coach collection
    if (resolvedCoachName.isEmpty) {
      dynamic coachField = data['coach'];
      if (coachField is DocumentReference) {
        resolvedCoachName = coachField.id;
      } else if (coachField is String) {
        resolvedCoachName = coachField;
      }
    }

    final completedModules = <Map<String, String>>[];
    double calculatedProgress = 0.0;

    try {
      final firestore = FirebaseFirestore.instance;

      // Get THINK completions
      final thinkSnapshot = await firestore
          .collection('users')
          .doc(userId)
          .collection('completed_courses')
          .where('topic', isEqualTo: 'THINK')
          .get();

      // Get KEEP completions
      final keepSnapshot = await firestore
          .collection('users')
          .doc(userId)
          .collection('completed_courses')
          .where('topic', isEqualTo: 'KEEP')
          .get();

      // Collect completed module details
      for (final doc in thinkSnapshot.docs) {
        final docData = doc.data();
        completedModules.add({
          'title': docData['title'] as String? ?? 'THINK Module',
          'topic': 'THINK',
        });
      }

      for (final doc in keepSnapshot.docs) {
        final docData = doc.data();
        completedModules.add({
          'title': docData['title'] as String? ?? 'KEEP Module',
          'topic': 'KEEP',
        });
      }

      // Get total THINK and KEEP modules
      final videoSnapshot = await firestore
          .collection('video')
          .where('topic', whereIn: ['THINK', 'KEEP']).get();

      final totalModules = videoSnapshot.docs.length;
      final completedCount = completedModules.length;

      calculatedProgress =
          totalModules > 0 ? completedCount / totalModules : 0.0;
    } catch (e) {
      debugPrint('Error calculating progress for user $userId: $e');
      calculatedProgress = 0.0;
    }

    // Extract profile image URL
    final String? profileImageUrl = data['profileImageUrl'] as String? ??
        data['profile_image_url'] as String? ??
        data['photoURL'] as String? ??
        data['profilePicture'] as String?;

    final _AdminMemberActionType actionType = !approved
        ? _AdminMemberActionType.approve
        : (approved && !hasCoachAssignment && role.toLowerCase() == 'member')
            ? _AdminMemberActionType.assignCoach
            : _AdminMemberActionType.none;

    final String email = data['email'] as String? ?? '';

    return _AdminMemberRowData(
      userId: userId,
      name: name,
      role: role,
      approved: approved,
      agency: resolvedAgencyName,
      coach: resolvedCoachName,
      progress: calculatedProgress,
      actionType: actionType,
      email: email,
      completedModules: completedModules,
      hasCoachAssignment: hasCoachAssignment,
      profileImageUrl: profileImageUrl,
      coachId: coachId,
    );
  }

  // Optimized version that uses pre-loaded progress data
  static _AdminMemberRowData fromFirestoreWithProgress(
    String userId,
    Map<String, dynamic> data,
    Map<String, dynamic> progressData,
    int totalModules, {
    bool hasCoachAssignment = false,
    String? agencyName,
    String? coachName,
    String? coachId,
  }) {
    // --- ROBUST NAME RESOLUTION START ---
    final candidates = [
      data['display_name'],
      data['fullName'],
      data['name'],
      data['firstName'] != null || data['lastName'] != null
          ? [data['firstName'], data['lastName']]
              .where((s) => s != null && s.toString().trim().isNotEmpty)
              .join(' ')
              .trim()
          : null,
      data['first_name'] != null || data['last_name'] != null
          ? [data['first_name'], data['last_name']]
              .where((s) => s != null && s.toString().trim().isNotEmpty)
              .join(' ')
              .trim()
          : null,
      data['username'],
    ];

    String name = '';
    for (final candidate in candidates) {
      if (candidate != null &&
          candidate is String &&
          candidate.trim().isNotEmpty) {
        name = candidate.trim();
        break;
      }
    }
    if (name.isEmpty) {
      name = 'Unnamed User';
    }
    // --- ROBUST NAME RESOLUTION END ---

    final String role = (data['role'] as String? ?? 'Member').trim();
    final bool approved = data['isApproved'] as bool? ??
        data['approved'] as bool? ??
        data['accountStatus'] == 'approved' ??
        false;

    // Use agencyName from parameter (looked up from agencies collection) if provided
    String resolvedAgencyName = agencyName ?? 'add to agency';

    // Fallback to reading from user document if not found in agencies collection
    if (resolvedAgencyName == 'add to agency') {
      dynamic agencyField = data['agency'];
      if (agencyField is DocumentReference) {
        resolvedAgencyName = agencyField.id;
      } else if (agencyField is String && agencyField.isNotEmpty) {
        resolvedAgencyName = agencyField;
      } else if (data['agencyName'] is String &&
          (data['agencyName'] as String).isNotEmpty) {
        resolvedAgencyName = data['agencyName'] as String;
      }
    }

    // Use coachName from parameter (looked up from member_coach collection) if provided
    String resolvedCoachName = coachName ?? '';

    // Fallback to reading from user document if not found in member_coach collection
    if (resolvedCoachName.isEmpty) {
      dynamic coachField = data['coach'];
      if (coachField is DocumentReference) {
        resolvedCoachName = coachField.id;
      } else if (coachField is String) {
        resolvedCoachName = coachField;
      }
    }

    final completedModules =
        progressData['completedModules'] as List<Map<String, String>>? ?? [];
    final completedCount = completedModules.length;
    final calculatedProgress =
        totalModules > 0 ? completedCount / totalModules : 0.0;

    // Extract profile image URL
    final String? profileImageUrl = data['profileImageUrl'] as String? ??
        data['profile_image_url'] as String? ??
        data['photoURL'] as String? ??
        data['profilePicture'] as String?;

    final _AdminMemberActionType actionType = !approved
        ? _AdminMemberActionType.approve
        : (approved && !hasCoachAssignment && role.toLowerCase() == 'member')
            ? _AdminMemberActionType.assignCoach
            : _AdminMemberActionType.none;

    final String email = data['email'] as String? ?? '';

    return _AdminMemberRowData(
      userId: userId,
      name: name,
      role: role,
      approved: approved,
      agency: resolvedAgencyName,
      coach: resolvedCoachName,
      progress: calculatedProgress,
      actionType: actionType,
      email: email,
      completedModules: completedModules,
      hasCoachAssignment: hasCoachAssignment,
      profileImageUrl: profileImageUrl,
      coachId: coachId,
    );
  }

  factory _AdminMemberRowData.fromFirestore(
    String userId,
    Map<String, dynamic> data, {
    bool hasCoachAssignment = false,
    String? agencyName,
    String? coachName,
    String? coachId,
  }) {
    // --- ROBUST NAME RESOLUTION START ---
    final candidates = [
      data['display_name'],
      data['fullName'],
      data['name'],
      data['firstName'] != null || data['lastName'] != null
          ? [data['firstName'], data['lastName']]
              .where((s) => s != null && s.toString().trim().isNotEmpty)
              .join(' ')
              .trim()
          : null,
      data['first_name'] != null || data['last_name'] != null
          ? [data['first_name'], data['last_name']]
              .where((s) => s != null && s.toString().trim().isNotEmpty)
              .join(' ')
              .trim()
          : null,
      data['username'],
    ];

    String name = '';
    for (final candidate in candidates) {
      if (candidate != null &&
          candidate is String &&
          candidate.trim().isNotEmpty) {
        name = candidate.trim();
        break;
      }
    }
    if (name.isEmpty) {
      debugPrint(
          '‚ö†Ô∏è _AdminMemberRowData.fromFirestore: Name resolution failed for user $userId. Data keys: ${data.keys.toList()}');
      name = 'Unnamed User';
    } else {
      debugPrint(
          '‚úÖ _AdminMemberRowData.fromFirestore: Resolved name "$name" for user $userId');
    }
    // --- ROBUST NAME RESOLUTION END ---

    final String role = (data['role'] as String? ?? 'Member').trim();
    final bool approved = data['isApproved'] as bool? ??
        data['approved'] as bool? ??
        data['accountStatus'] == 'approved' ??
        false;

    String resolvedAgencyName = agencyName ?? 'add to agency';
    if (resolvedAgencyName == 'add to agency') {
      dynamic agencyField = data['agency'];
      if (agencyField is DocumentReference) {
        resolvedAgencyName = agencyField.id;
      } else if (agencyField is String && agencyField.isNotEmpty) {
        resolvedAgencyName = agencyField;
      } else if (data['agencyName'] is String &&
          (data['agencyName'] as String).isNotEmpty) {
        resolvedAgencyName = data['agencyName'] as String;
      }
    }

    // Use coachName from parameter (looked up from member_coach collection) if provided
    String resolvedCoachName = coachName ?? '';

    // Fallback to reading from user document if not found in member_coach collection
    if (resolvedCoachName.isEmpty) {
      dynamic coachField = data['coach'];
      if (coachField is DocumentReference) {
        resolvedCoachName = coachField.id;
      } else if (coachField is String) {
        resolvedCoachName = coachField;
      }
    }

    final String? profileImageUrl = data['profileImageUrl'] as String? ??
        data['profile_image_url'] as String? ??
        data['photoURL'] as String? ??
        data['profilePicture'] as String?;

    final _AdminMemberActionType actionType = !approved
        ? _AdminMemberActionType.approve
        : (approved && !hasCoachAssignment && role.toLowerCase() == 'member')
            ? _AdminMemberActionType.assignCoach
            : _AdminMemberActionType.none;

    final bool hasSecondaryAction =
        resolvedAgencyName.toLowerCase() == 'add to agency' ||
            role.toLowerCase() == 'member';

    final String email = data['email'] as String? ?? '';

    return _AdminMemberRowData(
      userId: userId,
      name: name.isEmpty ? 'Unnamed User' : name,
      role: role,
      agency: resolvedAgencyName,
      coach: resolvedCoachName,
      progress: 0.0,
      actionType: actionType,
      hasSecondaryAction: hasSecondaryAction,
      approved: approved,
      hasCoachAssignment: hasCoachAssignment,
      profileImageUrl: profileImageUrl,
      completedModules: const [],
      email: email,
      coachId: coachId,
    );
  }
}

class _FocusFilterData {
  const _FocusFilterData({
    required this.label,
    required this.icon,
    required this.focus,
    required this.caption,
  });

  final String label;
  final IconData icon;
  final _AdminMemberFocus focus;
  final String caption;
}

class _AdminMemberManagementView extends StatefulWidget {
  const _AdminMemberManagementView({
    required this.onCreateUsers,
    required this.onPrimaryAction,
    required this.onSecondaryAction,
    this.initialAgencyFilter,
    this.onClearAgencyFilter,
  });

  final VoidCallback onCreateUsers;
  final VoidCallback onPrimaryAction;
  final VoidCallback onSecondaryAction;
  final String? initialAgencyFilter;
  final VoidCallback? onClearAgencyFilter;

  @override
  State<_AdminMemberManagementView> createState() =>
      _AdminMemberManagementViewState();
}

class _AdminMemberManagementViewState
    extends State<_AdminMemberManagementView> {
  List<_AdminMemberRowData> _members = [];
  final Map<String, _AdminMemberRowData> _membersWithProgress = {};

  _AdminMemberTab _activeTab = _AdminMemberTab.all;
  _AdminMemberFocus _focusFilter = _AdminMemberFocus.all;
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';
  bool _showByAgencyModal = false;
  String? _appliedAgencyFilter;
  double _computedAverageProgress = 0.0;
  bool _isLoadingProgress = false;
  Set<String> _loadedMemberIds = {};
  int _refreshKey = 0; // Key to force StreamBuilder rebuild
  
  // Optimization: Cache available agencies
  List<Map<String, String>> _availableAgencies = [];
  StreamSubscription<QuerySnapshot>? _agenciesSubscription;

  /// Force refresh the member list by clearing cached data and triggering rebuild
  void _forceRefresh() {
    if (mounted) {
      setState(() {
        _refreshKey++;
        _membersWithProgress.clear();
        _loadedMemberIds.clear();
        _members.clear();
      });
    }
  }

  @override
  void initState() {
    super.initState();
    _appliedAgencyFilter = widget.initialAgencyFilter;
    _loadAverageProgress();
    
    // Subscribe to agencies for caching
    _agenciesSubscription = FirebaseFirestore.instance
        .collection('agencies')
        .snapshots()
        .listen((snapshot) {
      if (mounted) {
        final loaded = snapshot.docs.map((doc) {
          final data = doc.data();
          return {
            'id': doc.id,
            'name': (data['agency_name'] ?? data['name'] ?? 'Unknown Agency')
                as String,
          };
        }).toList();
        // Sort explicitly
        loaded.sort((a, b) => (a['name'] ?? '').compareTo(b['name'] ?? ''));
        
        setState(() {
          _availableAgencies = loaded;
        });
      }
    });
  }

  @override
  void dispose() {
    _agenciesSubscription?.cancel();
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _loadMemberProgress(
    List<QueryDocumentSnapshot> docs,
    Set<String> assignedMemberIds,
    Map<String, String> userAgencyMap,
    Map<String, String> memberToCoachMap,
    Map<String, String> coachIdToNameMap,
  ) async {
    if (_isLoadingProgress) return;
    
    final currentIds = docs.map((d) => d.id).toSet();
    if (_loadedMemberIds.length == currentIds.length && _loadedMemberIds.containsAll(currentIds)) {
      return; 
    }

    _isLoadingProgress = true;
    _loadedMemberIds = currentIds;

    final stopwatch = Stopwatch()..start();
    debugPrint(
        'üöÄ Starting optimized progress loading for ${docs.length} members');

    // Batch load all necessary data at once
    try {
      final Map<String, Map<String, dynamic>> progressData =
          await _batchLoadProgressData(docs);
      debugPrint(
          '‚ö° Batch loading completed in ${stopwatch.elapsedMilliseconds}ms');

      // Get total modules once
      final totalModules = await _getTotalModulesCount();

      // Process members in smaller batches to avoid blocking UI
      const batchSize = 10;
      for (int i = 0; i < docs.length; i += batchSize) {
        final batch = docs.skip(i).take(batchSize).toList();

        final List<_AdminMemberRowData> updatedBatch = [];
        for (final doc in batch) {
          final memberData = doc.data() as Map<String, dynamic>;
          final bool hasCoachAssignment = assignedMemberIds.contains(doc.id);
          final String? agencyFromMap = userAgencyMap[doc.id];
          final String? coachId = memberToCoachMap[doc.id];
          final String? coachName =
              coachId != null ? coachIdToNameMap[coachId] : null;

          final memberWithProgress =
              _AdminMemberRowData.fromFirestoreWithProgress(
            doc.id,
            memberData,
            progressData[doc.id] ?? {},
            totalModules,
            hasCoachAssignment: hasCoachAssignment,
            agencyName: agencyFromMap,
            coachName: coachName,
          );
          updatedBatch.add(memberWithProgress);
        }

        if (mounted) {
          setState(() {
            for (final member in updatedBatch) {
              _membersWithProgress[member.userId] = member;
              // Update the member in the main list
              final index =
                  _members.indexWhere((m) => m.userId == member.userId);
              if (index != -1) {
                _members[index] = member;
              }
            }
          });
        }

        // Small delay to allow UI updates
        await Future.delayed(const Duration(milliseconds: 10));
      }

      debugPrint(
          '‚úÖ Progress loading completed in ${stopwatch.elapsedMilliseconds}ms');
    } catch (e) {
      debugPrint('‚ùå Error in _loadMemberProgress: $e');
    } finally {
      _isLoadingProgress = false;
    }
  }

  Future<Map<String, Map<String, dynamic>>> _batchLoadProgressData(
      List<QueryDocumentSnapshot> docs) async {
    final firestore = FirebaseFirestore.instance;
    final Map<String, Map<String, dynamic>> allProgressData = {};

    // Batch query for all completions
    final List<Future<QuerySnapshot>> completionFutures = [];
    for (final doc in docs) {
      completionFutures.add(firestore
          .collection('users')
          .doc(doc.id)
          .collection('completed_courses')
          .where('topic', whereIn: ['THINK', 'KEEP']).get());
    }

    final completionSnapshots = await Future.wait(completionFutures);

    for (int i = 0; i < docs.length; i++) {
      final doc = docs[i];
      final snapshot = completionSnapshots[i];

      final completedModules = <Map<String, String>>[];
      for (final doc in snapshot.docs) {
        final docData = doc.data() as Map<String, dynamic>?;
        if (docData != null) {
          completedModules.add({
            'title': docData['title'] as String? ?? 'Module',
            'topic': docData['topic'] as String? ?? 'UNKNOWN',
          });
        }
      }

      allProgressData[doc.id] = {
        'completedModules': completedModules,
      };
    }

    return allProgressData;
  }

  Future<int> _getTotalModulesCount() async {
    try {
      final firestore = FirebaseFirestore.instance;
      final videoSnapshot = await firestore
          .collection('video')
          .where('topic', whereIn: ['THINK', 'KEEP']).get();
      return videoSnapshot.docs.length;
    } catch (e) {
      debugPrint('Error getting total modules count: $e');
      return 20; // Fallback
    }
  }

  Future<void> _loadAverageProgress() async {
    if (_isLoadingProgress) return;
    setState(() => _isLoadingProgress = true);

    try {
      final stopwatch = Stopwatch()..start();
      debugPrint('üöÄ Starting optimized average progress calculation');

      final firestore = FirebaseFirestore.instance;

      // Get total modules once
      final totalModules = await _getTotalModulesCount();
      debugPrint('üìä Total modules: $totalModules');

      // Get all users
      final usersSnapshot = await firestore.collection('users').get();

      if (usersSnapshot.docs.isEmpty) {
        if (mounted) setState(() => _isLoadingProgress = false);
        return;
      }

      // Batch load all completion data
      final List<Future<QuerySnapshot>> completionFutures = [];
      for (final userDoc in usersSnapshot.docs) {
        completionFutures.add(firestore
            .collection('users')
            .doc(userDoc.id)
            .collection('completed_courses')
            .where('topic', whereIn: ['THINK', 'KEEP']).get());
      }

      final completionSnapshots = await Future.wait(completionFutures);

      double totalProgress = 0.0;
      int userCount = usersSnapshot.docs.length;

      for (int i = 0; i < usersSnapshot.docs.length; i++) {
        final completedCount = completionSnapshots[i].docs.length;
        final userProgress =
            totalModules > 0 ? completedCount / totalModules : 0.0;
        totalProgress += userProgress;
      }

      final avgProgress = userCount > 0 ? totalProgress / userCount : 0.0;

      debugPrint(
          '‚úÖ Average progress calculated in ${stopwatch.elapsedMilliseconds}ms');

      if (mounted) {
        setState(() {
          _computedAverageProgress = avgProgress.clamp(0.0, 1.0);
          _isLoadingProgress = false;
        });
      }
    } catch (e) {
      debugPrint('Error calculating average progress: $e');
      if (mounted) {
        setState(() => _isLoadingProgress = false);
      }
    }
  }

  @override
  void didUpdateWidget(_AdminMemberManagementView oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.initialAgencyFilter != oldWidget.initialAgencyFilter) {
      setState(() {
        _appliedAgencyFilter = widget.initialAgencyFilter;
      });
    }
  }

  int get _totalMembers => _members.length;
  int get _pendingApprovalCount =>
      _members.where((member) => !member.approved).length;
  int get _activelyCoachedCount =>
      _members.where((member) => member.coach.isNotEmpty).length;
  int get _needsCoachCount => _members
      .where((member) =>
          member.coach.isEmpty && member.role.toLowerCase() == 'member')
      .length;
  double get _averageProgress => _computedAverageProgress;



  List<_AdminMemberRowData> _getFilteredMembers(
      List<_AdminMemberRowData> allMembers) {
    debugPrint(
        'üîç _getFilteredMembers called - Total members: ${allMembers.length}');
    debugPrint('üîç Active tab: $_activeTab');
    debugPrint('üîç Applied agency filter: "$_appliedAgencyFilter"');
    debugPrint('üîç Search query: "$_searchQuery"');
    debugPrint('üîç Focus filter: $_focusFilter');

    List<_AdminMemberRowData> base;
    switch (_activeTab) {
      case _AdminMemberTab.all:
        base = allMembers;
        break;
      case _AdminMemberTab.byCoach:
        base = allMembers
            .where((member) => member.coach.isNotEmpty)
            .toList(growable: false);
        break;
      case _AdminMemberTab.byAgency:
        base = allMembers
            .where((member) => member.agency.toLowerCase() != 'add to agency')
            .toList(growable: false);
        break;
    }
    debugPrint('‚úÖ After tab filter: ${base.length} members');

    Iterable<_AdminMemberRowData> filtered = base;

    if (_appliedAgencyFilter != null && _appliedAgencyFilter!.isNotEmpty) {
      debugPrint(
          'üîç Filtering by agency: "${_appliedAgencyFilter!.toLowerCase()}"');
      // Debug: Print all unique agencies before filtering
      final uniqueAgencies = base.map((m) => m.agency).toSet();
      debugPrint('üîç Available agencies in base: $uniqueAgencies');

      filtered = filtered.where(
        (member) {
          final matches = member.agency.toLowerCase() ==
              _appliedAgencyFilter!.toLowerCase();
          if (!matches) {
            debugPrint(
                '   ‚ùå Member "${member.name}" agency "${member.agency}" != "$_appliedAgencyFilter"');
          }
          return matches;
        },
      );
      debugPrint('‚úÖ After agency filter: ${filtered.length} members');
    }

    if (_searchQuery.isNotEmpty) {
      final String query = _searchQuery.toLowerCase();
      filtered = filtered.where(
        (member) =>
            member.name.toLowerCase().contains(query) ||
            member.agency.toLowerCase().contains(query) ||
            member.coach.toLowerCase().contains(query),
      );
      debugPrint('‚úÖ After search filter: ${filtered.length} members');
    }

    switch (_focusFilter) {
      case _AdminMemberFocus.pendingApproval:
        filtered = filtered.where((member) => !member.approved);
        break;
      case _AdminMemberFocus.needsCoach:
        filtered = filtered.where(
          (member) =>
              member.coach.isEmpty && member.role.toLowerCase() == 'member',
        );
        break;
      case _AdminMemberFocus.activelyCoached:
        filtered = filtered.where((member) => member.coach.isNotEmpty);
        break;
      case _AdminMemberFocus.all:
        break;
    }
    debugPrint('‚úÖ After focus filter: ${filtered.length} members');

    final result = filtered.toList(growable: false);
    debugPrint('‚úÖ Final result: ${result.length} members');
    return result;
  }

  List<_AgencyRosterGroup> _getAgencyRosterGroups(
      List<_AdminMemberRowData> allMembers) {
    final Map<String, List<_AdminMemberRowData>> grouped = {};
    for (final member in allMembers) {
      final String agencyName = member.agency.trim();
      if (agencyName.isEmpty || agencyName.toLowerCase() == 'add to agency') {
        continue;
      }
      grouped
          .putIfAbsent(agencyName, () => <_AdminMemberRowData>[])
          .add(member);
    }

    final List<_AgencyRosterGroup> groups = grouped.entries
        .map((entry) =>
            _AgencyRosterGroup(name: entry.key, members: entry.value))
        .toList(growable: false);
    groups.sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));
    return groups;
  }

  Widget _buildHeroBanner() {
    return LayoutBuilder(
      builder: (context, constraints) {
        final bool isCompact = constraints.maxWidth < 860;

        final Widget overviewColumn = Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 6),
              decoration: BoxDecoration(
                color: Colors.white.withOpacity(0.16),
                borderRadius: BorderRadius.circular(999),
                border: Border.all(color: Colors.white.withOpacity(0.24)),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: const [
                  Icon(Icons.auto_awesome, size: 16, color: Colors.white),
                  SizedBox(width: 8),
                  Text(
                    'Operational overview',
                    style: TextStyle(
                        color: Colors.white,
                        fontSize: 13,
                        fontWeight: FontWeight.w600),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 20),
            const Text(
              'Member Management',
              style: TextStyle(
                color: Colors.white,
                fontSize: 26,
                fontWeight: FontWeight.w800,
                height: 1.2,
              ),
            ),
            const SizedBox(height: 12),
            Text(
              'Curate member relationships, balance coach capacity, and action approvals with ease.',
              style: TextStyle(
                color: Colors.white.withOpacity(0.84),
                height: 1.5,
                fontSize: 15,
                fontWeight: FontWeight.w500,
              ),
            ),
            if (_appliedAgencyFilter != null &&
                _appliedAgencyFilter!.isNotEmpty) ...[
              const SizedBox(height: 16),
              Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                decoration: BoxDecoration(
                  color: Colors.white.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.white.withOpacity(0.3)),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const Icon(Icons.filter_alt, size: 16, color: Colors.white),
                    const SizedBox(width: 8),
                    Text(
                      'Filtered by: $_appliedAgencyFilter',
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 13,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(width: 8),
                    InkWell(
                      onTap: () {
                        setState(() {
                          _appliedAgencyFilter = null;
                        });
                        widget.onClearAgencyFilter?.call();
                      },
                      child: Container(
                        padding: const EdgeInsets.all(2),
                        decoration: BoxDecoration(
                          color: Colors.white.withOpacity(0.2),
                          shape: BoxShape.circle,
                        ),
                        child: const Icon(Icons.close,
                            size: 14, color: Colors.white),
                      ),
                    ),
                  ],
                ),
              ),
            ],
            const SizedBox(height: 24),
            Wrap(
              spacing: 12,
              runSpacing: 12,
              children: [
                _buildHeroInfoPill(
                    Icons.groups_rounded, 'Total members', '$_totalMembers'),
                _buildHeroInfoPill(Icons.verified_user_outlined,
                    'Actively coached', '$_activelyCoachedCount'),
                _buildHeroInfoPill(Icons.pending_actions_outlined,
                    'Pending approvals', '$_pendingApprovalCount'),
              ],
            ),
            const SizedBox(height: 28),
            _buildAverageProgressIndicator(),
          ],
        );

        final Widget ctaPanel = Container(
          width: isCompact ? double.infinity : 280,
          padding: const EdgeInsets.all(24),
          decoration: BoxDecoration(
            color: Colors.white.withOpacity(0.18),
            borderRadius: BorderRadius.circular(22),
            border: Border.all(color: Colors.white.withOpacity(0.22)),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Need to onboard someone?',
                style: TextStyle(
                    color: Colors.white,
                    fontSize: 16,
                    fontWeight: FontWeight.w700),
              ),
              const SizedBox(height: 8),
              Text(
                'Spin up accounts, assign roles, and deliver welcome content in minutes.',
                style: TextStyle(
                    color: Colors.white.withOpacity(0.86),
                    height: 1.4,
                    fontSize: 14),
              ),
              const SizedBox(height: 22),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: widget.onCreateUsers,
                  style: ElevatedButton.styleFrom(
                    elevation: 0,
                    backgroundColor: Colors.white,
                    foregroundColor: const Color(0xFF1F3EF8),
                    padding: const EdgeInsets.symmetric(vertical: 15),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(14)),
                    textStyle: const TextStyle(
                        fontSize: 15, fontWeight: FontWeight.w700),
                  ),
                  child: const Text('Create users'),
                ),
              ),
              const SizedBox(height: 14),
              TextButton.icon(
                onPressed: widget.onSecondaryAction,
                style: TextButton.styleFrom(
                  foregroundColor: Colors.white,
                  textStyle: const TextStyle(fontWeight: FontWeight.w600),
                ),
                icon: const Icon(Icons.picture_as_pdf_outlined),
                label: const Text('Download roster PDF'),
              ),
            ],
          ),
        );

        return Container(
          decoration: BoxDecoration(
            gradient: const LinearGradient(
              colors: [Color(0xFF1E3A8A), Color(0xFF2563EB)],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
            borderRadius: BorderRadius.circular(28),
            boxShadow: const [
              BoxShadow(
                  color: Color(0x4D1E3A8A),
                  blurRadius: 30,
                  offset: Offset(0, 24)),
            ],
          ),
          child: Stack(
            children: [
              Positioned(
                top: -28,
                right: -18,
                child: Container(
                  width: 180,
                  height: 180,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    color: Colors.white.withOpacity(0.08),
                  ),
                ),
              ),
              Positioned(
                bottom: -24,
                left: 120,
                child: Container(
                  width: 120,
                  height: 120,
                  decoration: BoxDecoration(
                    border: Border.all(
                        color: Colors.white.withOpacity(0.16), width: 14),
                    shape: BoxShape.circle,
                  ),
                ),
              ),
              Padding(
                padding: EdgeInsets.fromLTRB(32, 32, isCompact ? 32 : 40, 32),
                child: isCompact
                    ? Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          overviewColumn,
                          const SizedBox(height: 28),
                          ctaPanel,
                        ],
                      )
                    : Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Expanded(child: overviewColumn),
                          const SizedBox(width: 40),
                          ctaPanel,
                        ],
                      ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildHeroInfoPill(IconData icon, String label, String value) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.18),
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: Colors.white.withOpacity(0.22)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, color: Colors.white, size: 18),
          const SizedBox(width: 10),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(label.toUpperCase(),
                  style: const TextStyle(
                      color: Colors.white,
                      fontSize: 11,
                      fontWeight: FontWeight.w600,
                      letterSpacing: 0.6)),
              const SizedBox(height: 4),
              Text(
                value,
                style: const TextStyle(
                    color: Colors.white,
                    fontSize: 15,
                    fontWeight: FontWeight.w700),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildAverageProgressIndicator() {
    final double average = _averageProgress.clamp(0, 1);
    return TweenAnimationBuilder<double>(
      tween: Tween<double>(begin: 0, end: average),
      duration: const Duration(milliseconds: 650),
      curve: Curves.easeOut,
      builder: (context, value, child) {
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Text(
                  'Average completion',
                  style: TextStyle(
                      color: Colors.white,
                      fontSize: 14,
                      fontWeight: FontWeight.w600),
                ),
                const SizedBox(width: 12),
                Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                  decoration: BoxDecoration(
                    color: Colors.white.withOpacity(0.22),
                    borderRadius: BorderRadius.circular(999),
                  ),
                  child: Text(
                    '${(value * 100).round()}%',
                    style: const TextStyle(
                        color: Colors.white,
                        fontSize: 12,
                        fontWeight: FontWeight.w700),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            ClipRRect(
              borderRadius: BorderRadius.circular(999),
              child: LinearProgressIndicator(
                value: value,
                backgroundColor: Colors.white.withOpacity(0.18),
                valueColor:
                    const AlwaysStoppedAnimation<Color>(Color(0xFF9AE6B4)),
                minHeight: 10,
              ),
            ),
            const SizedBox(height: 10),
            Text(
              value < 0.35
                  ? 'Momentum opportunity: consider scheduling new sessions.'
                  : 'Engagement momentum looks healthy across the cohort.',
              style: TextStyle(
                  color: Colors.white.withOpacity(0.82),
                  fontSize: 13,
                  height: 1.4),
            ),
          ],
        );
      },
    );
  }

  Widget _buildMetricTiles(double maxWidth) {
    final bool stackCards = maxWidth < 1024;
    final int total = _totalMembers;
    final double coachedRatio = total == 0 ? 0 : _activelyCoachedCount / total;
    final double needsCoachRatio = total == 0 ? 0 : _needsCoachCount / total;

    final List<Widget> cards = [
      _buildMetricCard(
        icon: Icons.groups_rounded,
        title: 'Total members',
        value: total.toString(),
        descriptor: 'Roster size',
        meta: '$_pendingApprovalCount pending invites',
        accent: const Color(0xFF2563EB),
        gradient: const [Color(0xFFFFFFFF), Color(0xFFEFF6FF)],
        progress: total == 0 ? null : 1.0,
      ),
      _buildMetricCard(
        icon: Icons.person_pin_circle_outlined,
        title: 'Actively coached',
        value: _activelyCoachedCount.toString(),
        descriptor: 'Members paired with a coach',
        meta: '${(coachedRatio * 100).round()}% of roster',
        accent: const Color(0xFF22C55E),
        gradient: const [Color(0xFFEFFDF5), Color(0xFFD1FAE5)],
        progress: coachedRatio,
      ),
      _buildMetricCard(
        icon: Icons.flag_outlined,
        title: 'Needs attention',
        value: _needsCoachCount.toString(),
        descriptor: 'Awaiting coach assignment',
        meta: '${(needsCoachRatio * 100).round()}% of roster',
        accent: const Color(0xFFF97316),
        gradient: const [Color(0xFFFFFBEB), Color(0xFFFFEDD5)],
        progress: needsCoachRatio,
      ),
    ];

    if (stackCards) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          for (int i = 0; i < cards.length; i++)
            Padding(
              padding: EdgeInsets.only(bottom: i == cards.length - 1 ? 0 : 18),
              child: cards[i],
            ),
        ],
      );
    }

    return Row(
      children: [
        for (int i = 0; i < cards.length; i++)
          Expanded(
            child: Padding(
              padding: EdgeInsets.only(right: i == cards.length - 1 ? 0 : 20),
              child: cards[i],
            ),
          ),
      ],
    );
  }

  Widget _buildMetricCard({
    required IconData icon,
    required String title,
    required String value,
    required String descriptor,
    required String meta,
    required List<Color> gradient,
    required Color accent,
    double? progress,
  }) {
    return Container(
      padding: const EdgeInsets.fromLTRB(26, 24, 26, 24),
      decoration: BoxDecoration(
        gradient: LinearGradient(
            colors: gradient,
            begin: Alignment.topLeft,
            end: Alignment.bottomRight),
        borderRadius: BorderRadius.circular(26),
        border: Border.all(color: Colors.white.withOpacity(0.6)),
        boxShadow: const [
          BoxShadow(
              color: Color(0x1A1E293B), blurRadius: 20, offset: Offset(0, 12)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: 44,
            height: 44,
            decoration: BoxDecoration(
              color: accent.withOpacity(0.08),
              borderRadius: BorderRadius.circular(14),
            ),
            child: Icon(icon, color: accent, size: 24),
          ),
          const SizedBox(height: 18),
          Text(
            title,
            style: const TextStyle(
                color: Color(0xFF0F172A),
                fontSize: 15,
                fontWeight: FontWeight.w700),
          ),
          const SizedBox(height: 6),
          Text(
            descriptor,
            style: const TextStyle(
                color: Color(0xFF475569),
                fontSize: 13,
                fontWeight: FontWeight.w500),
          ),
          const SizedBox(height: 18),
          Row(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              Text(
                value,
                style: const TextStyle(
                    color: Color(0xFF0F172A),
                    fontSize: 28,
                    fontWeight: FontWeight.w800),
              ),
              const SizedBox(width: 12),
              Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                decoration: BoxDecoration(
                  color: accent.withOpacity(0.12),
                  borderRadius: BorderRadius.circular(999),
                ),
                child: Text(
                  meta,
                  style: TextStyle(
                      color: accent, fontSize: 12, fontWeight: FontWeight.w700),
                ),
              ),
            ],
          ),
          if (progress != null) ...[
            const SizedBox(height: 16),
            ClipRRect(
              borderRadius: BorderRadius.circular(999),
              child: LinearProgressIndicator(
                value: progress.clamp(0, 1),
                minHeight: 8,
                backgroundColor: accent.withOpacity(0.12),
                valueColor: AlwaysStoppedAnimation<Color>(accent),
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildControlsRow() {
    return LayoutBuilder(
      builder: (context, constraints) {
        final bool stack = constraints.maxWidth < 900;

        final Widget searchField = SizedBox(
          width: stack ? double.infinity : constraints.maxWidth * 0.5,
          child: _buildSearchField(),
        );

        final Widget actionButtons = OutlinedButton.icon(
          onPressed: widget.onPrimaryAction,
          icon: const Icon(Icons.download_outlined),
          label: const Text('Export CSV'),
          style: OutlinedButton.styleFrom(
            foregroundColor: const Color(0xFF1F2937),
            side: const BorderSide(color: Color(0xFFD1D5DB)),
            padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
            textStyle: const TextStyle(fontWeight: FontWeight.w600),
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
          ),
        );

        final Widget filters = _buildFocusFilters();

        if (stack) {
          return Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              searchField,
              const SizedBox(height: 18),
              actionButtons,
              const SizedBox(height: 20),
              filters,
            ],
          );
        }

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(child: searchField),
                const SizedBox(width: 24),
                actionButtons,
              ],
            ),
            const SizedBox(height: 22),
            filters,
          ],
        );
      },
    );
  }

  Widget _buildSearchField() {
    return TextField(
      controller: _searchController,
      onChanged: (value) => setState(() => _searchQuery = value.trim()),
      decoration: InputDecoration(
        hintText: 'Search by member, coach, or agency',
        prefixIcon: const Icon(Icons.search, color: Color(0xFF2563EB)),
        suffixIcon: _searchQuery.isNotEmpty
            ? IconButton(
                tooltip: 'Clear search',
                onPressed: () {
                  _searchController.clear();
                  setState(() => _searchQuery = '');
                },
                icon: const Icon(Icons.close_rounded, color: Color(0xFF6B7280)),
              )
            : null,
        filled: true,
        fillColor: Colors.white,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(18),
          borderSide: const BorderSide(color: Color(0xFFE2E8F0)),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(18),
          borderSide: const BorderSide(color: Color(0xFF2563EB)),
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 18, vertical: 0),
      ),
    );
  }

  Widget _buildFocusFilters() {
    final List<_FocusFilterData> filters = [
      _FocusFilterData(
        label: 'All status',
        icon: Icons.blur_on_rounded,
        focus: _AdminMemberFocus.all,
        caption: 'Everyone',
      ),
      _FocusFilterData(
        label: 'Pending approval',
        icon: Icons.verified_outlined,
        focus: _AdminMemberFocus.pendingApproval,
        caption: '$_pendingApprovalCount waiting',
      ),
      _FocusFilterData(
        label: 'Needs coach',
        icon: Icons.person_search_outlined,
        focus: _AdminMemberFocus.needsCoach,
        caption: '$_needsCoachCount unassigned',
      ),
      _FocusFilterData(
        label: 'Actively coached',
        icon: Icons.handshake_outlined,
        focus: _AdminMemberFocus.activelyCoached,
        caption: '$_activelyCoachedCount in flight',
      ),
    ];

    return Wrap(
      spacing: 12,
      runSpacing: 12,
      children: filters.map(_buildFocusChip).toList(growable: false),
    );
  }

  Widget _buildFocusChip(_FocusFilterData data) {
    final bool selected = _focusFilter == data.focus;
    return FilterChip(
      labelPadding: const EdgeInsets.symmetric(horizontal: 14, vertical: 2),
      avatar: Icon(
        data.icon,
        size: 18,
        color: selected ? Colors.white : const Color(0xFF2563EB),
      ),
      label: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            data.label,
            style: TextStyle(
              color: selected ? Colors.white : const Color(0xFF1F2937),
              fontSize: 13,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 2),
          Text(
            data.caption,
            style: TextStyle(
              color: selected
                  ? Colors.white.withOpacity(0.82)
                  : const Color(0xFF64748B),
              fontSize: 11,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
      selected: selected,
      onSelected: (_) => setState(() => _focusFilter = data.focus),
      selectedColor: const Color(0xFF2563EB),
      backgroundColor: Colors.white,
      side: BorderSide(
          color: selected ? Colors.transparent : const Color(0xFFD1D5DB)),
      showCheckmark: false,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
    );
  }

  void _openByAgencyModal() {
    setState(() {
      _activeTab = _AdminMemberTab.byAgency;
      _showByAgencyModal = true;
    });
  }

  void _closeByAgencyModal({_AdminMemberTab? nextTab}) {
    if (!_showByAgencyModal && nextTab == null) {
      return;
    }
    setState(() {
      _showByAgencyModal = false;
      _activeTab = nextTab ?? _AdminMemberTab.all;
    });
  }

  void _showActionSnack(String message) {
    ScaffoldMessenger.of(context)
      ..hideCurrentSnackBar()
      ..showSnackBar(
        SnackBar(
          content: Text(message),
          duration: const Duration(seconds: 2),
        ),
      );
  }

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<QuerySnapshot>(
      key: ValueKey('member_mgmt_$_refreshKey'),
      stream: FirebaseFirestore.instance.collection('users').snapshots(),
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          return Center(
            child: Padding(
              padding: const EdgeInsets.all(24),
              child: Text('Error loading users: ${snapshot.error}'),
            ),
          );
        }

        return StreamBuilder<QuerySnapshot>(
          stream:
              FirebaseFirestore.instance.collection('member_coach').snapshots(),
          builder: (coachContext, coachSnapshot) {
            return StreamBuilder<QuerySnapshot>(
              stream:
                  FirebaseFirestore.instance.collection('agencies').snapshots(),
              builder: (agencyContext, agencySnapshot) {
                List<_AdminMemberRowData> allMembers = [];
                if (snapshot.hasData) {
                  final Set<String> assignedMemberIds = {};
                  final Map<String, String> memberToCoachMap = {};

                  if (coachSnapshot.hasData) {
                    for (final coachDoc in coachSnapshot.data!.docs) {
                      final data = coachDoc.data() as Map<String, dynamic>;

                      // Get coach reference from 'coachref' field
                      final coachRef = data['coachref'] as DocumentReference? ??
                          data['coach'] as DocumentReference?;
                      String coachId = '';

                      if (coachRef != null) {
                        // Extract coach ID from reference
                        coachId = coachRef.id;
                      }

                      // Get member reference - could be memberref or membersAssigned
                      final memberRef = data['memberref'] as DocumentReference? ??
                          data['member'] as DocumentReference?;
                      final membersAssigned =
                          data['membersAssigned'] as List<dynamic>?;

                      // Handle single member reference
                      if (memberRef != null && coachId.isNotEmpty) {
                        final memberId = memberRef.id;
                        assignedMemberIds.add(memberId);
                        memberToCoachMap[memberId] = coachId;
                      }

                      // Handle multiple members assigned (legacy)
                      if (membersAssigned != null && coachId.isNotEmpty) {
                        for (final memberRefItem in membersAssigned) {
                          if (memberRefItem is DocumentReference) {
                            final memberId = memberRefItem.id;
                            assignedMemberIds.add(memberId);
                            memberToCoachMap[memberId] = coachId;
                          }
                        }
                      }
                    }
                  }

                  // Build a map of coach IDs to coach names
                  final Map<String, String> coachIdToNameMap = {};
                  for (final coachId in memberToCoachMap.values.toSet()) {
                    try {
                      final userDoc = snapshot.data!.docs.firstWhere(
                        (doc) {
                          final docData = doc.data() as Map<String, dynamic>?;
                          return doc.id == coachId;
                        },
                      );
                      final userData = userDoc.data() as Map<String, dynamic>;
                      final firstName = userData['firstName'] as String? ?? '';
                      final lastName = userData['lastName'] as String? ?? '';
                      final displayName = userData['display_name'] as String? ??
                          userData['displayName'] as String? ??
                          userData['username'] as String? ??
                          '';
                      final coachName = displayName.isNotEmpty
                          ? displayName
                          : '$firstName $lastName'.trim();
                      if (coachName.isNotEmpty) {
                        coachIdToNameMap[coachId] = coachName;
                      }
                    } catch (e) {
                      // Coach not found in users collection
                      debugPrint('Coach with ID $coachId not found');
                    }
                  }

                  // Build a map of user IDs to agency names
                  final Map<String, String> userAgencyMap = {};
                  if (agencySnapshot.hasData) {
                    for (final agencyDoc in agencySnapshot.data!.docs) {
                      final agencyData =
                          agencyDoc.data() as Map<String, dynamic>;
                      final agencyName = agencyData['agency_name'] as String? ??
                          agencyData['name'] as String? ??
                          agencyDoc.id;
                      final members = agencyData['members'] as List<dynamic>?;
                      if (members != null) {
                        for (final memberRef in members) {
                          if (memberRef is DocumentReference) {
                            userAgencyMap[memberRef.id] = agencyName;
                          }
                        }
                      }
                    }
                  }

                  // Use synchronous version for quick loading
                  allMembers = snapshot.data!.docs.map((doc) {
                    final memberData = doc.data() as Map<String, dynamic>;
                    final bool hasCoachAssignment =
                        assignedMemberIds.contains(doc.id);
                    final String? agencyFromMap = userAgencyMap[doc.id];
                    final String? coachId = memberToCoachMap[doc.id];
                    final String? coachName =
                        coachId != null ? coachIdToNameMap[coachId] : null;
                    return _AdminMemberRowData.fromFirestore(
                      doc.id,
                      memberData,
                      hasCoachAssignment: hasCoachAssignment,
                      agencyName: agencyFromMap,
                      coachName: coachName,
                      coachId: coachId,
                    );
                  }).toList();

                  // Asynchronously load progress data for each member
                  // We use microtask to avoid calling setState during build
                  if (!_isLoadingProgress) {
                    Future.microtask(() => _loadMemberProgress(
                        snapshot.data!.docs,
                        assignedMemberIds,
                        userAgencyMap,
                        memberToCoachMap,
                        coachIdToNameMap));
                  }
                }

                final visibleMembers = _getFilteredMembers(allMembers);
                final agencyGroups = _getAgencyRosterGroups(allMembers);

                if (_members.length != allMembers.length) {
                  WidgetsBinding.instance.addPostFrameCallback((_) {
                    if (mounted) {
                      setState(() {
                        _members = allMembers;
                      });
                    }
                  });
                }

                return _buildMainContent(context, snapshot, coachSnapshot,
                    allMembers, visibleMembers, agencyGroups);
              },
            );
          },
        );
      },
    );
  }

  Widget _buildMainContent(
    BuildContext context,
    AsyncSnapshot<QuerySnapshot> snapshot,
    AsyncSnapshot<QuerySnapshot> coachSnapshot,
    List<_AdminMemberRowData> allMembers,
    List<_AdminMemberRowData> visibleMembers,
    List<_AgencyRosterGroup> agencyGroups,
  ) {
    final Widget baseContent = Container(
      color: const Color(0xFFF8FAFC),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(32, 32, 32, 8),
            child: _buildHeroBanner(),
          ),
          Expanded(
            child: LayoutBuilder(
              builder: (context, constraints) {
                return SingleChildScrollView(
                  padding: const EdgeInsets.fromLTRB(32, 0, 32, 48),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const SizedBox(height: 16),
                      _buildMetricTiles(constraints.maxWidth),
                      const SizedBox(height: 32),
                      _buildControlsRow(),
                      const SizedBox(height: 24),
                      _buildTabSwitcher(),
                      const SizedBox(height: 24),
                      snapshot.connectionState == ConnectionState.waiting &&
                              allMembers.isEmpty
                          ? const Center(
                              child: Padding(
                                padding: EdgeInsets.all(48),
                                child: CircularProgressIndicator(),
                              ),
                            )
                          : _buildMemberTable(constraints.maxWidth),
                    ],
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );

    if (!_showByAgencyModal) {
      return baseContent;
    }

    return Stack(
      children: [
        baseContent,
        Positioned.fill(
          child: GestureDetector(
            behavior: HitTestBehavior.opaque,
            onTap: () => _closeByAgencyModal(),
            child: Container(
              color: Colors.black.withOpacity(0.55),
              alignment: Alignment.center,
              child: GestureDetector(
                onTap: () {},
                child: _ByAgencyModal(
                  groups: agencyGroups,
                  onClose: () => _closeByAgencyModal(),
                  onSelectAllMembers: () =>
                      _closeByAgencyModal(nextTab: _AdminMemberTab.all),
                  onSelectByCoach: () =>
                      _closeByAgencyModal(nextTab: _AdminMemberTab.byCoach),
                  onCreateUsers: widget.onCreateUsers,
                  onAddMember: (agency) => _showActionSnack(
                      'Add member flow for ${agency.name} is coming soon.'),
                  onRemoveMember: (member) =>
                      _showActionSnack('Remove ${member.name} is coming soon.'),
                  onUploadResults: (member) {
                    _closeByAgencyModal();
                    Future.microtask(() => _openUploadResultsPage(member));
                  },
                ),
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildTabSwitcher() {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(22),
        border: Border.all(color: const Color(0xFFE2E8F0)),
        boxShadow: const [
          BoxShadow(
              color: Color(0x141E293B), blurRadius: 18, offset: Offset(0, 10)),
        ],
      ),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
      child: LayoutBuilder(
        builder: (context, constraints) {
          final bool wrap = constraints.maxWidth < 720;
          final List<Widget> chips = [
            _buildTabChip(
              tab: _AdminMemberTab.all,
              label: 'All Members',
              icon: Icons.groups_rounded,
              count: _members.length,
            ),
            _buildTabChip(
              tab: _AdminMemberTab.byCoach,
              label: 'By Coach',
              icon: Icons.fact_check_outlined,
              count: _members.where((member) => member.coach.isNotEmpty).length,
            ),
            _buildTabChip(
              tab: _AdminMemberTab.byAgency,
              label: 'By Agency',
              icon: Icons.business_center_outlined,
              count: _members
                  .where((member) =>
                      member.agency.toLowerCase() != 'add to agency')
                  .length,
            ),
          ];

          if (wrap) {
            return Wrap(
              spacing: 12,
              runSpacing: 12,
              children: chips,
            );
          }

          return Row(
            children: [
              for (int i = 0; i < chips.length; i++)
                Padding(
                  padding:
                      EdgeInsets.only(right: i == chips.length - 1 ? 0 : 12),
                  child: chips[i],
                ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildTabChip({
    required _AdminMemberTab tab,
    required String label,
    required IconData icon,
    required int count,
  }) {
    final bool isActive = _activeTab == tab;
    return Material(
      color: Colors.transparent,
      child: InkWell(
        borderRadius: BorderRadius.circular(18),
        onTap: isActive
            ? null
            : () {
                if (tab == _AdminMemberTab.byAgency) {
                  _openByAgencyModal();
                } else {
                  setState(() {
                    _activeTab = tab;
                    // Clear agency filter when switching to "All Members" tab
                    if (tab == _AdminMemberTab.all) {
                      _appliedAgencyFilter = null;
                      widget.onClearAgencyFilter?.call();
                    }
                  });
                }
              },
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 220),
          padding: const EdgeInsets.symmetric(horizontal: 22, vertical: 14),
          decoration: BoxDecoration(
            gradient: isActive
                ? const LinearGradient(
                    colors: [Color(0xFF2563EB), Color(0xFF1D4ED8)],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                  )
                : null,
            color: isActive ? null : const Color(0xFFF8FAFC),
            borderRadius: BorderRadius.circular(18),
            border: Border.all(
                color: isActive ? Colors.transparent : const Color(0xFFE2E8F0)),
            boxShadow: isActive
                ? const [
                    BoxShadow(
                        color: Color(0x332563EB),
                        blurRadius: 18,
                        offset: Offset(0, 10)),
                  ]
                : null,
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(icon,
                  size: 18,
                  color: isActive ? Colors.white : const Color(0xFF2563EB)),
              const SizedBox(width: 10),
              Text(
                label,
                style: TextStyle(
                  color: isActive ? Colors.white : const Color(0xFF1F2937),
                  fontSize: 14,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(width: 12),
              AnimatedContainer(
                duration: const Duration(milliseconds: 220),
                padding:
                    const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                decoration: BoxDecoration(
                  color: isActive
                      ? Colors.white.withOpacity(0.2)
                      : const Color(0xFFE2E8F0),
                  borderRadius: BorderRadius.circular(999),
                ),
                child: Text(
                  count.toString(),
                  style: TextStyle(
                    color: isActive ? Colors.white : const Color(0xFF2563EB),
                    fontSize: 12,
                    fontWeight: FontWeight.w700,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMemberTable(double maxWidth) {
    final List<_AdminMemberRowData> rows = _getFilteredMembers(_members);
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: const [
          BoxShadow(
              color: Color(0x0A1E293B), blurRadius: 12, offset: Offset(0, 4)),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildHeaderRow(),
          const Divider(height: 1, color: Color(0xFFE5E7EB)),
          if (rows.isEmpty)
            Container(
              padding: const EdgeInsets.symmetric(vertical: 40),
              alignment: Alignment.center,
              child: const Text(
                'No members found for this view.',
                style: TextStyle(
                    color: Color(0xFF6B7280),
                    fontSize: 14,
                    fontWeight: FontWeight.w500),
              ),
            )
          else
            ...rows.map(_buildMemberRow),
        ],
      ),
    );
  }

  Widget _buildHeaderRow() {
    const TextStyle headerStyle = TextStyle(
      color: Color(0xFF6B7280),
      fontSize: 12,
      fontWeight: FontWeight.w700,
      letterSpacing: 0.6,
    );

    Widget buildCell(String label,
        {int flex = 1, Alignment alignment = Alignment.centerLeft}) {
      return Expanded(
        flex: flex,
        child: Align(
          alignment: alignment,
          child: Text(label.toUpperCase(), style: headerStyle),
        ),
      );
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 14),
      decoration: const BoxDecoration(
        color: Color(0xFFF9FAFB),
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      child: Row(
        children: [
          buildCell('Member', flex: 3),
          buildCell('Agency', flex: 2),
          buildCell('Coach', flex: 2),
          buildCell('Progress', flex: 2),
          buildCell('Actions', flex: 2, alignment: Alignment.centerRight),
        ],
      ),
    );
  }

  Widget _buildMemberRow(_AdminMemberRowData data) {
    return Container(
      key: ValueKey('member_row_${data.userId}'),
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
      decoration: const BoxDecoration(
        border: Border(
          bottom: BorderSide(color: Color(0xFFE5E7EB), width: 0.5),
        ),
      ),
      child: Row(
        children: [
          Expanded(flex: 3, child: _buildMemberCell(data)),
          Expanded(flex: 2, child: _buildAgencyDropdownCell(data)),
          Expanded(
            flex: 2,
            child: Text(
              data.coach.isEmpty ? '‚Äî' : data.coach,
              style: const TextStyle(
                  color: Color(0xFF4B5563),
                  fontSize: 13,
                  fontWeight: FontWeight.w500),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          Expanded(flex: 2, child: _buildProgressBar(data.progress, data)),
          Expanded(flex: 2, child: _buildActionCell(data)),
        ],
      ),
    );
  }

  Widget _buildMemberCell(_AdminMemberRowData data) {
    return Row(
      children: [
        Container(
          width: 36,
          height: 36,
          decoration: BoxDecoration(
            color: const Color(0xFFE5E7EB),
            shape: BoxShape.circle,
            image:
                data.profileImageUrl != null && data.profileImageUrl!.isNotEmpty
                    ? DecorationImage(
                        image: NetworkImage(data.profileImageUrl!),
                        fit: BoxFit.cover,
                      )
                    : null,
          ),
          child: data.profileImageUrl == null || data.profileImageUrl!.isEmpty
              ? const Icon(Icons.person_outline,
                  color: Color(0xFF4B5563), size: 18)
              : null,
        ),
        const SizedBox(width: 12),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                data.name,
                style: const TextStyle(
                  color: Color(0xFF1F2937),
                  fontSize: 13,
                  fontWeight: FontWeight.w600,
                ),
                overflow: TextOverflow.ellipsis,
              ),
              const SizedBox(height: 2),
              Text(
                data.email.isNotEmpty ? data.email : data.role,
                style: const TextStyle(
                    color: Color(0xFF6B7280),
                    fontSize: 11,
                    fontWeight: FontWeight.w500),
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildProgressBar(double value, _AdminMemberRowData data) {
    return GestureDetector(
      onTap: () => _showProgressDialog(data),
      child: MouseRegion(
        cursor: SystemMouseCursors.click,
        child: Container(
          height: 8,
          decoration: BoxDecoration(
            color: const Color(0xFFE5E7EB),
            borderRadius: BorderRadius.circular(999),
          ),
          alignment: Alignment.centerLeft,
          child: value > 0
              ? FractionallySizedBox(
                  widthFactor: value.clamp(0, 1),
                  child: Container(
                    decoration: BoxDecoration(
                      color: const Color(0xFF3CC7C9),
                      borderRadius: BorderRadius.circular(999),
                    ),
                  ),
                )
              : const SizedBox.shrink(),
        ),
      ),
    );
  }

  Widget _buildActionCell(_AdminMemberRowData data) {
    final bool isApprove = data.actionType == _AdminMemberActionType.approve;
    final bool needsCoach = data.approved &&
        !data.hasCoachAssignment &&
        data.role.toLowerCase() == 'member';
    final bool hasCoach = data.approved &&
        data.hasCoachAssignment &&
        data.role.toLowerCase() == 'member';

    // Build a list of action buttons based on member state
    final List<Widget> actionButtons = [];

    // Always add Edit and Delete buttons for all members
    actionButtons.add(
      SizedBox(
        height: 36,
        child: IconButton(
          style: IconButton.styleFrom(
            backgroundColor: const Color(0xFFF3F4F6),
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          ),
          onPressed: () {
            debugPrint('üîò Edit button PRESSED for ${data.name} (ID: ${data.userId})');
            _showEditMemberDialog(data);
          },
          icon: const Icon(Icons.edit_outlined,
              size: 18, color: Color(0xFF4B5563)),
          tooltip: 'Edit Member',
        ),
      ),
    );
    actionButtons.add(const SizedBox(width: 4));
    actionButtons.add(
      SizedBox(
        height: 36,
        child: IconButton(
          style: IconButton.styleFrom(
            backgroundColor: const Color(0xFFFEE2E2),
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          ),
          onPressed: () => _showDeleteMemberDialog(data),
          icon: const Icon(Icons.delete_outline,
              size: 18, color: Color(0xFFEF4444)),
          tooltip: 'Delete Member',
        ),
      ),
    );

    // For unapproved members: add "Approve" button
    if (isApprove) {
      actionButtons.add(const SizedBox(width: 6));
      actionButtons.add(
        SizedBox(
          height: 36,
          child: ElevatedButton.icon(
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF2563EB),
              foregroundColor: Colors.white,
              elevation: 0,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(10)),
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
            ),
            onPressed: () => _approveMember(data),
            icon: const Icon(Icons.check_circle_outline, size: 16),
            label: const Text(
              'Approve',
              style: TextStyle(fontSize: 12, fontWeight: FontWeight.w600),
            ),
          ),
        ),
      );
    }

    // For members without a coach: add "Assign Coach" button
    if (needsCoach) {
      actionButtons.add(const SizedBox(width: 6));
      actionButtons.add(
        SizedBox(
          height: 36,
          child: ElevatedButton.icon(
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF22C55E),
              foregroundColor: Colors.white,
              elevation: 0,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(10)),
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
            ),
            onPressed: () => _showAssignCoachDialog(data),
            icon: const Icon(Icons.person_add_outlined, size: 16),
            label: const Text(
              'Assign',
              style: TextStyle(fontSize: 12, fontWeight: FontWeight.w600),
            ),
          ),
        ),
      );
    }

    // For members with a coach: add "Reassign Coach" and "Upload Results" buttons
    if (hasCoach) {
      actionButtons.add(const SizedBox(width: 6));
      actionButtons.add(
        SizedBox(
          height: 36,
          child: ElevatedButton.icon(
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF3B82F6),
              foregroundColor: Colors.white,
              elevation: 0,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(10)),
              padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
            ),
            onPressed: () => _showReassignCoachDialog(data),
            icon: const Icon(Icons.swap_horiz, size: 16),
            label: const Text(
              'Reassign',
              style: TextStyle(fontSize: 12, fontWeight: FontWeight.w600),
            ),
          ),
        ),
      );
      actionButtons.add(const SizedBox(width: 6));
      actionButtons.add(
        SizedBox(
          height: 36,
          child: ElevatedButton.icon(
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF10B981),
              foregroundColor: Colors.white,
              elevation: 0,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(10)),
              padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
            ),
            onPressed: () => _openUploadResultsPage(data),
            icon: const Icon(Icons.upload_file, size: 16),
            label: const Text(
              'Results',
              style: TextStyle(fontSize: 12, fontWeight: FontWeight.w600),
            ),
          ),
        ),
      );
    }

    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: MainAxisAlignment.end,
        children: actionButtons,
      ),
    );
  }

  void _showEditMemberDialog(_AdminMemberRowData data) {
    debugPrint('üîò Edit button clicked for ${data.name}');
    
    // PRE-FILL LOGIC: Attempt to split the full name from the row data
    // so the user sees *something* immediately, even before the DB fetch.
    final nameParts = data.name.trim().split(' ');
    String initialFirstName = '';
    String initialLastName = '';
    if (nameParts.isNotEmpty) {
      initialFirstName = nameParts.first;
      if (nameParts.length > 1) {
        initialLastName = nameParts.sublist(1).join(' ');
      }
    }

    // Show dialog IMMEDIATELY
    showDialog(
      context: context,
      builder: (context) => _EditMemberDialog(
        data: data,
        initialFirstName: initialFirstName,
        initialLastName: initialLastName,
        availableAgencies: _availableAgencies, // Pass cached agencies
        onMemberUpdated: () => _forceRefresh(),
      ),
    );
  }



  Future<void> _showDeleteMemberDialog(_AdminMemberRowData data) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: const Text('Delete Member'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Are you sure you want to delete ${data.name}?'),
            const SizedBox(height: 12),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: const Color(0xFFFEE2E2),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: const [
                  Icon(Icons.warning_amber_rounded, color: Color(0xFFEF4444)),
                  SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'This action cannot be undone. The user will be permanently removed from the system.',
                      style: TextStyle(fontSize: 13, color: Color(0xFF991B1B)),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFFEF4444),
              foregroundColor: Colors.white,
            ),
            onPressed: () => Navigator.of(context).pop(true),
            child: const Text('Delete'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      try {
        // Remove user from any agency's members array
        final agenciesSnapshot = await FirebaseFirestore.instance
            .collection('agencies')
            .where('members',
                arrayContains: FirebaseFirestore.instance
                    .collection('users')
                    .doc(data.userId))
            .get();

        for (final agencyDoc in agenciesSnapshot.docs) {
          await agencyDoc.reference.update({
            'members': FieldValue.arrayRemove([
              FirebaseFirestore.instance.collection('users').doc(data.userId)
            ]),
            'active_members': FieldValue.arrayRemove([
              FirebaseFirestore.instance.collection('users').doc(data.userId)
            ]),
          });
        }

        // Delete the user document
        await FirebaseFirestore.instance
            .collection('users')
            .doc(data.userId)
            .delete();

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('${data.name} has been deleted successfully'),
              backgroundColor: const Color(0xFF22C55E),
            ),
          );
          _forceRefresh(); // Refresh the list after deletion
        }
      } catch (e) {
        debugPrint('Error deleting member: $e');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Failed to delete member: $e'),
              backgroundColor: const Color(0xFFEF4444),
            ),
          );
        }
      }
    }
  }

  Future<void> _approveMember(_AdminMemberRowData data) async {
    try {
      await FirebaseFirestore.instance
          .collection('users')
          .doc(data.userId)
          .update({'isApproved': true, 'accountStatus': 'approved'});

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${data.name} has been approved successfully!'),
            backgroundColor: const Color(0xFF22C55E),
          ),
        );
        _forceRefresh(); // Refresh the list to show updated status
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to approve member: $e'),
            backgroundColor: const Color(0xFFEF4444),
          ),
        );
      }
    }
  }

  Future<void> _showAssignCoachDialog(_AdminMemberRowData data) async {
    final coaches = <Map<String, String>>[];

    try {
      // Query users collection for all users with role 'Coach'
      final coachesSnapshot = await FirebaseFirestore.instance
          .collection('users')
          .where('role', isEqualTo: 'Coach')
          .get();

      // Extract coach details from each document
      for (final coachDoc in coachesSnapshot.docs) {
        final docData = coachDoc.data();
        
        // ROBUST NAME RESOLUTION
        final candidates = [
          docData['display_name'],
          docData['displayName'],
          docData['fullName'],
          docData['name'],
          docData['firstName'] != null || docData['lastName'] != null
              ? '${docData['firstName'] ?? ''} ${docData['lastName'] ?? ''}'.trim()
              : null,
          docData['first_name'] != null || docData['last_name'] != null
              ? '${docData['first_name'] ?? ''} ${docData['last_name'] ?? ''}'.trim()
              : null,
          docData['username'],
          docData['email'],
        ];
        
        String name = '';
        for (final candidate in candidates) {
          if (candidate != null && candidate is String && candidate.trim().isNotEmpty) {
            name = candidate.trim();
            break;
          }
        }
        
        if (name.isNotEmpty) {
          coaches.add({
            'id': coachDoc.id,
            'name': name,
          });
        } else {
          // Even if no name, show the user ID so admin can see them
          coaches.add({
            'id': coachDoc.id,
            'name': 'Coach (${coachDoc.id.substring(0, 8)}...)',
          });
        }
      }

      // Sort coaches by name
      coaches.sort((a, b) => (a['name'] ?? '').compareTo(b['name'] ?? ''));
      
      debugPrint('üîç Found ${coachesSnapshot.docs.length} users with role=Coach');
      debugPrint('üîç After name resolution: ${coaches.length} coaches available');
      if (coaches.isEmpty) {
        debugPrint('‚ö†Ô∏è No coaches found in dropdown!');
      }
    } catch (e) {
      debugPrint('Failed to load coaches: $e');
    }

    if (!mounted) return;

    String? selectedCoachId;

    await showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => Dialog(
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          child: Container(
            width: 400,
            padding: const EdgeInsets.all(24),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    const Expanded(
                      child: Text(
                        'Assign Coach',
                        style: TextStyle(
                          fontSize: 20,
                          fontWeight: FontWeight.w700,
                          color: Color(0xFF1F2937),
                        ),
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.close, color: Color(0xFF6B7280)),
                      onPressed: () => Navigator.of(context).pop(),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                Text(
                  'Select a coach for ${data.name}',
                  style: const TextStyle(
                    fontSize: 14,
                    color: Color(0xFF6B7280),
                  ),
                ),
                const SizedBox(height: 24),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  decoration: BoxDecoration(
                    border: Border.all(color: const Color(0xFFE5E7EB)),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: DropdownButtonHideUnderline(
                    child: DropdownButton<String>(
                      isExpanded: true,
                      value: selectedCoachId,
                      hint: const Text('Select a coach'),
                      items: coaches.map((coach) {
                        return DropdownMenuItem<String>(
                          value: coach['id'],
                          child: Text(coach['name'] ?? ''),
                        );
                      }).toList(),
                      onChanged: (value) {
                        setState(() {
                          selectedCoachId = value;
                        });
                      },
                    ),
                  ),
                ),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    TextButton(
                      onPressed: () => Navigator.of(context).pop(),
                      child: const Text('Cancel'),
                    ),
                    const SizedBox(width: 12),
                    ElevatedButton(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF22C55E),
                        foregroundColor: Colors.white,
                        elevation: 0,
                        shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8)),
                        padding: const EdgeInsets.symmetric(
                            horizontal: 24, vertical: 12),
                      ),
                      onPressed: selectedCoachId == null
                          ? null
                          : () async {
                              Navigator.of(context).pop();
                              await _assignCoach(
                                  data.userId, selectedCoachId!, data.name);
                            },
                      child: const Text('Assign'),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _assignCoach(
      String memberId, String coachId, String memberName) async {
    try {
      final memberRef =
          FirebaseFirestore.instance.collection('users').doc(memberId);
      final coachRef =
          FirebaseFirestore.instance.collection('users').doc(coachId);

      // Query for coach's document using either 'coachref' or 'coach' field
      final coachDocs = await _findCoachDocument(coachRef);

      if (coachDocs.isNotEmpty) {
        // Document exists - update membersAssigned array
        await coachDocs.first.reference.update({
          'membersAssigned': FieldValue.arrayUnion([memberRef]),
          'updated_at': FieldValue.serverTimestamp(),
        });
      } else {
        // No document exists - create new one
        await FirebaseFirestore.instance.collection('member_coach').add({
          'coachref': coachRef,
          'membersAssigned': [memberRef],
          'assigned_at': FieldValue.serverTimestamp(),
          'updated_at': FieldValue.serverTimestamp(),
        });
      }

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Coach assigned to $memberName successfully!'),
            backgroundColor: const Color(0xFF22C55E),
          ),
        );
        _forceRefresh(); // Refresh the list to show assigned coach
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to assign coach: $e'),
            backgroundColor: const Color(0xFFEF4444),
          ),
        );
      }
    }
  }

  // Helper method to find coach document
  Future<List<QueryDocumentSnapshot>> _findCoachDocument(
      DocumentReference coachRef) async {
    var docs = await FirebaseFirestore.instance
        .collection('member_coach')
        .where('coachref', isEqualTo: coachRef)
        .limit(1)
        .get();

    if (docs.docs.isEmpty) {
      docs = await FirebaseFirestore.instance
          .collection('member_coach')
          .where('coach', isEqualTo: coachRef)
          .limit(1)
          .get();
    }

    return docs.docs;
  }

  Future<void> _showReassignCoachDialog(_AdminMemberRowData data) async {
    final coaches = <Map<String, String>>[];

    try {
      // Query users collection for all users with role 'Coach'
      final coachesSnapshot = await FirebaseFirestore.instance
          .collection('users')
          .where('role', isEqualTo: 'Coach')
          .get();

      // Extract coach details from each document
      for (final coachDoc in coachesSnapshot.docs) {
        final docData = coachDoc.data();
        
        // ROBUST NAME RESOLUTION
        final candidates = [
          docData['display_name'],
          docData['displayName'],
          docData['fullName'],
          docData['name'],
          docData['firstName'] != null || docData['lastName'] != null
              ? '${docData['firstName'] ?? ''} ${docData['lastName'] ?? ''}'.trim()
              : null,
          docData['first_name'] != null || docData['last_name'] != null
              ? '${docData['first_name'] ?? ''} ${docData['last_name'] ?? ''}'.trim()
              : null,
          docData['username'],
          docData['email'],
        ];
        
        String name = '';
        for (final candidate in candidates) {
          if (candidate != null && candidate is String && candidate.trim().isNotEmpty) {
            name = candidate.trim();
            break;
          }
        }
        
        if (name.isNotEmpty) {
          coaches.add({
            'id': coachDoc.id,
            'name': name,
          });
        } else {
          // Even if no name, show the user ID so admin can see them
          coaches.add({
            'id': coachDoc.id,
            'name': 'Coach (${coachDoc.id.substring(0, 8)}...)',
          });
        }
      }

      // Sort coaches by name
      coaches.sort((a, b) => (a['name'] ?? '').compareTo(b['name'] ?? ''));
      
      debugPrint('üîç Found ${coachesSnapshot.docs.length} users with role=Coach');
      debugPrint('üîç After name resolution: ${coaches.length} coaches available');
      if (coaches.isEmpty) {
        debugPrint('‚ö†Ô∏è No coaches found in dropdown!');
      }
    } catch (e) {
      debugPrint('Failed to load coaches: $e');
    }

    if (!mounted) return;

    String? selectedCoachId = data.coachId;

    await showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => Dialog(
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          child: Container(
            width: 400,
            padding: const EdgeInsets.all(24),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    const Expanded(
                      child: Text(
                        'Reassign Coach',
                        style: TextStyle(
                          fontSize: 20,
                          fontWeight: FontWeight.w700,
                          color: Color(0xFF1F2937),
                        ),
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.close, color: Color(0xFF6B7280)),
                      onPressed: () => Navigator.of(context).pop(),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                Text(
                  'Select a new coach for ${data.name}',
                  style: const TextStyle(
                    fontSize: 14,
                    color: Color(0xFF6B7280),
                  ),
                ),
                const SizedBox(height: 24),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  decoration: BoxDecoration(
                    border: Border.all(color: const Color(0xFFE5E7EB)),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: DropdownButtonHideUnderline(
                    child: DropdownButton<String>(
                      isExpanded: true,
                      value: selectedCoachId,
                      hint: const Text('Select a new coach'),
                      items: coaches.map((coach) {
                        return DropdownMenuItem<String>(
                          value: coach['id'],
                          child: Text(coach['name'] ?? ''),
                        );
                      }).toList(),
                      onChanged: (value) {
                        setState(() {
                          selectedCoachId = value;
                        });
                      },
                    ),
                  ),
                ),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    TextButton(
                      onPressed: () => Navigator.of(context).pop(),
                      child: const Text('Cancel'),
                    ),
                    const SizedBox(width: 12),
                    ElevatedButton(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF3B82F6),
                        foregroundColor: Colors.white,
                        elevation: 0,
                        shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8)),
                        padding: const EdgeInsets.symmetric(
                            horizontal: 24, vertical: 12),
                      ),
                      onPressed: selectedCoachId == null
                          ? null
                          : () async {
                              Navigator.of(context).pop();
                              await _reassignCoach(
                                  data.userId, selectedCoachId!, data.name);
                            },
                      child: const Text('Reassign'),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _reassignCoach(
      String memberId, String newCoachId, String memberName) async {
    try {
      final memberRef =
          FirebaseFirestore.instance.collection('users').doc(memberId);
      final newCoachRef =
          FirebaseFirestore.instance.collection('users').doc(newCoachId);

      // STEP 1: Remove from any existing coach's membersAssigned list
      final existingRelations = await FirebaseFirestore.instance
          .collection('member_coach')
          .where('membersAssigned', arrayContains: memberRef)
          .get();

      final batch = FirebaseFirestore.instance.batch();
      for (final doc in existingRelations.docs) {
        batch.update(doc.reference, {
          'membersAssigned': FieldValue.arrayRemove([memberRef]),
          'updated_at': FieldValue.serverTimestamp(),
        });
      }
      await batch.commit();

      // STEP 2: Add to new coach's membersAssigned list
      final coachDocs = await _findCoachDocument(newCoachRef);

      if (coachDocs.isNotEmpty) {
        // Document exists - update membersAssigned array
        await coachDocs.first.reference.update({
          'membersAssigned': FieldValue.arrayUnion([memberRef]),
          'updated_at': FieldValue.serverTimestamp(),
        });
      } else {
        // No document exists - create new one
        await FirebaseFirestore.instance.collection('member_coach').add({
          'coachref': newCoachRef,
          'membersAssigned': [memberRef],
          'assigned_at': FieldValue.serverTimestamp(),
          'updated_at': FieldValue.serverTimestamp(),
        });
      }

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Coach reassigned for $memberName successfully!'),
            backgroundColor: const Color(0xFF22C55E),
          ),
        );
        _forceRefresh(); // Refresh the list to show updated coach
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to reassign coach: $e'),
            backgroundColor: const Color(0xFFEF4444),
          ),
        );
      }
    }
  }

  Future<void> _openUploadResultsPage(_AdminMemberRowData data) async {
    if (!mounted) return;

    await Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => UploadAssessmentResultsPage(
          memberId: data.userId,
          memberName: data.name.isEmpty ? 'Member' : data.name,
        ),
      ),
    );
  }

  Future<void> _showRemoveMemberDialog(_AdminMemberRowData data) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          width: 400,
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: const Color(0xFFFEE2E2),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Icon(
                      Icons.warning_amber_rounded,
                      color: Color(0xFFEF4444),
                      size: 24,
                    ),
                  ),
                  const SizedBox(width: 12),
                  const Expanded(
                    child: Text(
                      'Remove Member',
                      style: TextStyle(
                        fontSize: 20,
                        fontWeight: FontWeight.w700,
                        color: Color(0xFF1F2937),
                      ),
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close, color: Color(0xFF6B7280)),
                    onPressed: () => Navigator.of(context).pop(false),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              Text(
                'Are you sure you want to remove ${data.name}? This will delete the member-coach relationship.',
                style: const TextStyle(
                  fontSize: 14,
                  color: Color(0xFF6B7280),
                ),
              ),
              const SizedBox(height: 24),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Navigator.of(context).pop(false),
                    child: const Text('Cancel'),
                  ),
                  const SizedBox(width: 12),
                  ElevatedButton(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFFEF4444),
                      foregroundColor: Colors.white,
                      elevation: 0,
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8)),
                      padding: const EdgeInsets.symmetric(
                          horizontal: 24, vertical: 12),
                    ),
                    onPressed: () => Navigator.of(context).pop(true),
                    child: const Text('Remove'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );

    if (confirmed == true) {
      await _removeMember(data.userId, data.name);
    }
  }

  Future<void> _removeMember(String memberId, String memberName) async {
    try {
      final memberRef =
          FirebaseFirestore.instance.collection('users').doc(memberId);

      // Find all coach documents containing this member and remove them
      final existingRelations = await FirebaseFirestore.instance
          .collection('member_coach')
          .where('membersAssigned', arrayContains: memberRef)
          .get();

      final batch = FirebaseFirestore.instance.batch();
      for (final doc in existingRelations.docs) {
        batch.update(doc.reference, {
          'membersAssigned': FieldValue.arrayRemove([memberRef]),
          'updated_at': FieldValue.serverTimestamp(),
        });
      }
      await batch.commit();

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('$memberName has been removed successfully!'),
            backgroundColor: const Color(0xFF22C55E),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to remove member: $e'),
            backgroundColor: const Color(0xFFEF4444),
          ),
        );
      }
    }
  }

  void _showProgressDialog(_AdminMemberRowData data) {
    showDialog(
      context: context,
      builder: (context) => Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          width: 500,
          constraints: const BoxConstraints(maxHeight: 600),
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Expanded(
                    child: Text(
                      '${data.name}\'s Progress',
                      style: const TextStyle(
                        fontSize: 20,
                        fontWeight: FontWeight.w700,
                        color: Color(0xFF1F2937),
                      ),
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close, color: Color(0xFF6B7280)),
                    onPressed: () => Navigator.of(context).pop(),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Text(
                '${(data.progress * 100).toStringAsFixed(0)}% Complete',
                style: const TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                  color: Color(0xFF6B7280),
                ),
              ),
              const SizedBox(height: 16),
              Container(
                height: 8,
                decoration: BoxDecoration(
                  color: const Color(0xFFE5E7EB),
                  borderRadius: BorderRadius.circular(999),
                ),
                alignment: Alignment.centerLeft,
                child: data.progress > 0
                    ? FractionallySizedBox(
                        widthFactor: data.progress.clamp(0, 1),
                        child: Container(
                          decoration: BoxDecoration(
                            color: const Color(0xFF3CC7C9),
                            borderRadius: BorderRadius.circular(999),
                          ),
                        ),
                      )
                    : const SizedBox.shrink(),
              ),
              const SizedBox(height: 24),
              const Text(
                'Completed Modules',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w700,
                  color: Color(0xFF1F2937),
                ),
              ),
              const SizedBox(height: 12),
              Flexible(
                child: data.completedModules.isEmpty
                    ? const Center(
                        child: Padding(
                          padding: EdgeInsets.all(32),
                          child: Text(
                            'No modules completed yet',
                            style: TextStyle(
                              color: Color(0xFF9CA3AF),
                              fontSize: 14,
                            ),
                          ),
                        ),
                      )
                    : ListView.builder(
                        shrinkWrap: true,
                        itemCount: data.completedModules.length,
                        itemBuilder: (context, index) {
                          final module = data.completedModules[index];
                          final topic = module['topic'] ?? '';
                          final title = module['title'] ?? 'Module';
                          final color = topic == 'THINK'
                              ? const Color(0xFF3CC7C9)
                              : const Color(0xFF34D399);

                          return Container(
                            margin: const EdgeInsets.only(bottom: 8),
                            padding: const EdgeInsets.all(12),
                            decoration: BoxDecoration(
                              color: const Color(0xFFF9FAFB),
                              borderRadius: BorderRadius.circular(8),
                              border:
                                  Border.all(color: const Color(0xFFE5E7EB)),
                            ),
                            child: Row(
                              children: [
                                Container(
                                  padding: const EdgeInsets.symmetric(
                                      horizontal: 8, vertical: 4),
                                  decoration: BoxDecoration(
                                    color: color.withValues(alpha: 0.1),
                                    borderRadius: BorderRadius.circular(4),
                                  ),
                                  child: Text(
                                    topic,
                                    style: TextStyle(
                                      color: color,
                                      fontSize: 11,
                                      fontWeight: FontWeight.w700,
                                    ),
                                  ),
                                ),
                                const SizedBox(width: 12),
                                Expanded(
                                  child: Text(
                                    title,
                                    style: const TextStyle(
                                      color: Color(0xFF1F2937),
                                      fontSize: 13,
                                      fontWeight: FontWeight.w500,
                                    ),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                                const Icon(
                                  Icons.check_circle,
                                  color: Color(0xFF22C55E),
                                  size: 18,
                                ),
                              ],
                            ),
                          );
                        },
                      ),
              ),
              const SizedBox(height: 16),
              Align(
                alignment: Alignment.centerRight,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF2563EB),
                    foregroundColor: Colors.white,
                    elevation: 0,
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(8)),
                    padding: const EdgeInsets.symmetric(
                        horizontal: 24, vertical: 12),
                  ),
                  onPressed: () => Navigator.of(context).pop(),
                  child: const Text(
                    'Close',
                    style: TextStyle(fontSize: 14, fontWeight: FontWeight.w600),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildAgencyDropdownCell(_AdminMemberRowData data) {
    return GestureDetector(
      onTap: () => _showAgencySelectionDialog(data),
      child: MouseRegion(
        cursor: SystemMouseCursors.click,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          decoration: BoxDecoration(
            color: const Color(0xFFF9FAFB),
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: const Color(0xFFE5E7EB)),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Expanded(
                child: Text(
                  data.agency,
                  style: const TextStyle(
                    color: Color(0xFF4B5563),
                    fontSize: 13,
                    fontWeight: FontWeight.w500,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _showAgencySelectionDialog(_AdminMemberRowData data) async {
    final agencies = <Map<String, String>>[];

    try {
      // Query agencies collection
      final agenciesSnapshot =
          await FirebaseFirestore.instance.collection('agencies').get();

      // Extract agency details from each document
      for (final agencyDoc in agenciesSnapshot.docs) {
        final docData = agencyDoc.data();
        final agencyName = docData['agency_name'] as String? ??
            docData['name'] as String? ??
            agencyDoc.id;
        if (agencyName.isNotEmpty) {
          agencies.add({
            'id': agencyDoc.id,
            'name': agencyName,
          });
        }
      }

      // Sort agencies by name
      agencies.sort((a, b) => (a['name'] ?? '').compareTo(b['name'] ?? ''));
    } catch (e) {
      debugPrint('Failed to load agencies: $e');
    }

    if (!mounted) return;

    String? selectedAgencyId;
    String? selectedAgencyName;

    await showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => Dialog(
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          child: Container(
            width: 400,
            padding: const EdgeInsets.all(24),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    const Expanded(
                      child: Text(
                        'Select Agency',
                        style: TextStyle(
                          fontSize: 20,
                          fontWeight: FontWeight.w700,
                          color: Color(0xFF1F2937),
                        ),
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.close, color: Color(0xFF6B7280)),
                      onPressed: () => Navigator.of(context).pop(),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                Text(
                  'Select an agency for ${data.name}',
                  style: const TextStyle(
                    fontSize: 14,
                    color: Color(0xFF6B7280),
                  ),
                ),
                const SizedBox(height: 24),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 16),
                  decoration: BoxDecoration(
                    border: Border.all(color: const Color(0xFFE5E7EB)),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: DropdownButtonHideUnderline(
                    child: DropdownButton<String>(
                      isExpanded: true,
                      value: selectedAgencyId,
                      hint: const Text('Select an agency'),
                      menuMaxHeight: 300,
                      items: agencies.map((agency) {
                        return DropdownMenuItem<String>(
                          value: agency['id'],
                          child: Text(
                            agency['name'] ?? '',
                            overflow: TextOverflow.ellipsis,
                            maxLines: 1,
                          ),
                        );
                      }).toList(),
                      onChanged: (value) {
                        setState(() {
                          selectedAgencyId = value;
                          selectedAgencyName = agencies.firstWhere(
                            (a) => a['id'] == value,
                            orElse: () => {'name': ''},
                          )['name'];
                        });
                      },
                    ),
                  ),
                ),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    TextButton(
                      onPressed: () => Navigator.of(context).pop(),
                      child: const Text('Cancel'),
                    ),
                    const SizedBox(width: 12),
                    ElevatedButton(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF2563EB),
                        foregroundColor: Colors.white,
                        elevation: 0,
                        shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8)),
                        padding: const EdgeInsets.symmetric(
                            horizontal: 24, vertical: 12),
                      ),
                      onPressed: selectedAgencyId == null
                          ? null
                          : () async {
                              Navigator.of(context).pop();
                              await _assignAgency(
                                  data.userId,
                                  selectedAgencyId!,
                                  selectedAgencyName!,
                                  data.name);
                            },
                      child: const Text('Assign'),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _assignAgency(String userId, String agencyId, String agencyName,
      String userName) async {
    try {
      final memberRef =
          FirebaseFirestore.instance.collection('users').doc(userId);
      final agencyRef =
          FirebaseFirestore.instance.collection('agencies').doc(agencyId);

      // Add member reference to agency's members array
      await agencyRef.update({
        'members': FieldValue.arrayUnion([memberRef]),
      });

      // Optionally update user document with agency reference
      await memberRef.update({
        'agency': agencyRef,
        'agencyName': agencyName,
      });

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('$userName assigned to $agencyName successfully!'),
            backgroundColor: const Color(0xFF22C55E),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to assign agency: $e'),
            backgroundColor: const Color(0xFFEF4444),
          ),
        );
      }
    }
  }
}

class _AgencyRosterGroup {
  _AgencyRosterGroup({required this.name, required this.members});

  final String name;
  final List<_AdminMemberRowData> members;

  int get memberCount => members.length;

  String? get location {
    final List<String> parts = name.split(' - ');
    if (parts.length < 2) {
      return null;
    }
    final String resolved = parts.sublist(1).join(' - ').trim();
    return resolved.isEmpty ? null : resolved;
  }
}

class _ByAgencyModal extends StatelessWidget {
  const _ByAgencyModal({
    required this.groups,
    required this.onClose,
    required this.onSelectAllMembers,
    required this.onSelectByCoach,
    required this.onCreateUsers,
    required this.onAddMember,
    required this.onRemoveMember,
    required this.onUploadResults,
  });

  final List<_AgencyRosterGroup> groups;
  final VoidCallback onClose;
  final VoidCallback onSelectAllMembers;
  final VoidCallback onSelectByCoach;
  final VoidCallback onCreateUsers;
  final ValueChanged<_AgencyRosterGroup> onAddMember;
  final ValueChanged<_AdminMemberRowData> onRemoveMember;
  final ValueChanged<_AdminMemberRowData> onUploadResults;

  static const Color _titleColor = Color(0xFF0F172A);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE2E8F0);
  static const Color _accentBlue = Color(0xFF2563EB);

  @override
  Widget build(BuildContext context) {
    final double maxHeight =
        math.min(MediaQuery.of(context).size.height * 0.88, 820);

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 40),
      child: ConstrainedBox(
        constraints: BoxConstraints(
          maxWidth: 1120,
          maxHeight: maxHeight,
        ),
        child: Material(
          color: Colors.transparent,
          child: ClipRRect(
            borderRadius: BorderRadius.circular(32),
            child: Container(
              color: const Color(0xFFF5F7FB),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  _buildHeader(context),
                  const SizedBox(height: 16),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 32),
                    child: _buildTabRow(),
                  ),
                  const SizedBox(height: 20),
                  Expanded(
                    child: groups.isEmpty
                        ? _buildEmptyState()
                        : Scrollbar(
                            thumbVisibility: true,
                            child: SingleChildScrollView(
                              padding: const EdgeInsets.fromLTRB(32, 0, 32, 32),
                              child: Column(
                                children: groups
                                    .map(
                                      (group) => Padding(
                                        padding: EdgeInsets.only(
                                            bottom:
                                                group == groups.last ? 0 : 24),
                                        child: _AgencyGroupCard(
                                          group: group,
                                          onAddMember: () => onAddMember(group),
                                          onRemoveMember: onRemoveMember,
                                          onUploadResults: onUploadResults,
                                        ),
                                      ),
                                    )
                                    .toList(growable: false),
                              ),
                            ),
                          ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildHeader(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        gradient: LinearGradient(
          colors: [Color(0xFFF0F4FF), Color(0xFFF8FBFF)],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        border: Border(
          bottom: BorderSide(color: Color(0xFFE1E7F5)),
        ),
      ),
      padding: const EdgeInsets.fromLTRB(32, 28, 32, 24),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 14, vertical: 6),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(999),
                    border: Border.all(color: const Color(0xFFD7E2FF)),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: const [
                      Icon(Icons.domain_outlined, size: 16, color: _accentBlue),
                      SizedBox(width: 8),
                      Text(
                        'Agency roster',
                        style: TextStyle(
                            color: _accentBlue,
                            fontSize: 12,
                            fontWeight: FontWeight.w700),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 18),
                const Text(
                  'Member Management',
                  style: TextStyle(
                    color: _titleColor,
                    fontSize: 24,
                    fontWeight: FontWeight.w800,
                    letterSpacing: -0.2,
                  ),
                ),
                const SizedBox(height: 8),
                const Text(
                  'Review members grouped by agency, take action fast, and keep rosters sharp.',
                  style: TextStyle(
                      color: _mutedColor,
                      fontSize: 14,
                      height: 1.45,
                      fontWeight: FontWeight.w500),
                ),
              ],
            ),
          ),
          const SizedBox(width: 20),
          Column(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              SizedBox(
                height: 48,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: _accentBlue,
                    foregroundColor: Colors.white,
                    elevation: 0,
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(14)),
                    padding: const EdgeInsets.symmetric(horizontal: 24),
                    textStyle: const TextStyle(
                        fontSize: 15, fontWeight: FontWeight.w700),
                  ),
                  onPressed: onCreateUsers,
                  child: const Text('Create users'),
                ),
              ),
              const SizedBox(height: 12),
              _CloseButton(onPressed: onClose),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildTabRow() {
    return DecoratedBox(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: _borderColor),
        boxShadow: const [
          BoxShadow(
              color: Color(0x110F172A), blurRadius: 18, offset: Offset(0, 12)),
        ],
      ),
      child: Padding(
        padding: const EdgeInsets.all(8),
        child: LayoutBuilder(
          builder: (context, constraints) {
            final bool wrap = constraints.maxWidth < 560;
            final List<Widget> tabs = [
              _ModalTabButton(
                label: 'All Members',
                icon: Icons.groups_rounded,
                isActive: false,
                onTap: onSelectAllMembers,
              ),
              _ModalTabButton(
                label: 'By Coach',
                icon: Icons.fact_check_outlined,
                isActive: false,
                onTap: onSelectByCoach,
              ),
              const _ModalTabButton(
                label: 'By Agency',
                icon: Icons.business_outlined,
                isActive: true,
              ),
            ];

            if (wrap) {
              return Wrap(
                spacing: 8,
                runSpacing: 8,
                children: tabs,
              );
            }

            return Row(
              children: [
                for (int i = 0; i < tabs.length; i++) ...[
                  Expanded(child: tabs[i]),
                  if (i != tabs.length - 1) const SizedBox(width: 8),
                ],
              ],
            );
          },
        ),
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(40),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: const [
            Icon(Icons.apartment_outlined, size: 64, color: _accentBlue),
            SizedBox(height: 16),
            Text(
              'No agencies available yet',
              style: TextStyle(
                  color: _titleColor,
                  fontSize: 18,
                  fontWeight: FontWeight.w700),
            ),
            SizedBox(height: 8),
            SizedBox(
              width: 320,
              child: Text(
                'Agencies with assigned members will appear here automatically.',
                textAlign: TextAlign.center,
                style:
                    TextStyle(color: _mutedColor, fontSize: 14, height: 1.45),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _ModalTabButton extends StatelessWidget {
  const _ModalTabButton({
    required this.label,
    required this.icon,
    this.isActive = false,
    this.onTap,
  });

  final String label;
  final IconData icon;
  final bool isActive;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final Color activeColor = _ByAgencyModal._accentBlue;
    return Material(
      color: Colors.transparent,
      child: InkWell(
        borderRadius: BorderRadius.circular(16),
        onTap: isActive ? null : onTap,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
          decoration: BoxDecoration(
            gradient: isActive
                ? const LinearGradient(
                    colors: [Color(0xFF2563EB), Color(0xFF1D4ED8)],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                  )
                : null,
            color: isActive ? null : Colors.white,
            borderRadius: BorderRadius.circular(16),
            border: Border.all(
                color: isActive ? Colors.transparent : const Color(0xFFE2E8F0)),
            boxShadow: isActive
                ? const [
                    BoxShadow(
                        color: Color(0x332563EB),
                        blurRadius: 16,
                        offset: Offset(0, 10)),
                  ]
                : null,
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.center,
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(icon,
                  size: 18, color: isActive ? Colors.white : activeColor),
              const SizedBox(width: 10),
              Flexible(
                child: Text(
                  label,
                  overflow: TextOverflow.ellipsis,
                  style: TextStyle(
                    color: isActive ? Colors.white : const Color(0xFF1F2937),
                    fontSize: 14,
                    fontWeight: FontWeight.w700,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _CloseButton extends StatelessWidget {
  const _CloseButton({required this.onPressed});

  final VoidCallback onPressed;

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        borderRadius: BorderRadius.circular(14),
        onTap: onPressed,
        child: Container(
          width: 44,
          height: 44,
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(14),
            border: Border.all(color: const Color(0xFFE2E8F0)),
            boxShadow: const [
              BoxShadow(
                  color: Color(0x110F172A),
                  blurRadius: 14,
                  offset: Offset(0, 10)),
            ],
          ),
          child: const Icon(Icons.close, color: Color(0xFF111827)),
        ),
      ),
    );
  }
}

class _AgencyGroupCard extends StatelessWidget {
  const _AgencyGroupCard({
    required this.group,
    required this.onAddMember,
    required this.onRemoveMember,
    required this.onUploadResults,
  });

  final _AgencyRosterGroup group;
  final VoidCallback onAddMember;
  final ValueChanged<_AdminMemberRowData> onRemoveMember;
  final ValueChanged<_AdminMemberRowData> onUploadResults;

  static const Color _titleColor = Color(0xFF0F172A);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE2E8F0);
  static const Color _accentBlue = Color(0xFF2563EB);

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(26),
        border: Border.all(color: const Color(0xFFE8ECF7)),
        boxShadow: const [
          BoxShadow(
              color: Color(0x0F0F172A), blurRadius: 24, offset: Offset(0, 18)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(26, 24, 26, 18),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Container(
                  width: 48,
                  height: 48,
                  decoration: BoxDecoration(
                    color: const Color(0xFFE3E9FF),
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: const Icon(Icons.apartment_rounded,
                      color: _accentBlue, size: 26),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        group.name,
                        style: const TextStyle(
                          color: _titleColor,
                          fontSize: 18,
                          fontWeight: FontWeight.w700,
                        ),
                      ),
                      if (group.location != null) ...[
                        const SizedBox(height: 4),
                        Text(
                          group.location!,
                          style: const TextStyle(
                              color: _mutedColor,
                              fontSize: 13,
                              fontWeight: FontWeight.w500),
                        ),
                      ],
                    ],
                  ),
                ),
                const SizedBox(width: 16),
                Text(
                  '${group.memberCount} ${group.memberCount == 1 ? 'member' : 'members'}',
                  style: const TextStyle(
                      color: _mutedColor,
                      fontSize: 13,
                      fontWeight: FontWeight.w600),
                ),
                const SizedBox(width: 14),
                OutlinedButton(
                  style: OutlinedButton.styleFrom(
                    foregroundColor: _accentBlue,
                    side: const BorderSide(color: _accentBlue),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(14)),
                    padding: const EdgeInsets.symmetric(
                        horizontal: 18, vertical: 14),
                    textStyle: const TextStyle(
                        fontSize: 14, fontWeight: FontWeight.w600),
                  ),
                  onPressed: onAddMember,
                  child: const Text('Add member'),
                ),
              ],
            ),
          ),
          const Divider(height: 1, color: _borderColor),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24),
            child: _AgencyMemberTableHeader(),
          ),
          const SizedBox(height: 6),
          ...group.members.map(
            (member) => Padding(
              padding:
                  EdgeInsets.only(bottom: member == group.members.last ? 0 : 2),
              child: _AgencyMemberRow(
                data: member,
                onRemove: () => onRemoveMember(member),
                onUpload: () => onUploadResults(member),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _AgencyMemberTableHeader extends StatelessWidget {
  static const TextStyle _headerStyle = TextStyle(
    color: Color(0xFF6B7280),
    fontSize: 12,
    fontWeight: FontWeight.w700,
    letterSpacing: 0.6,
  );

  @override
  Widget build(BuildContext context) {
    Widget buildCell(String label,
        {int flex = 2, Alignment alignment = Alignment.centerLeft}) {
      return Expanded(
        flex: flex,
        child: Align(
            alignment: alignment,
            child: Text(label.toUpperCase(), style: _headerStyle)),
      );
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 16),
      decoration: BoxDecoration(
        color: const Color(0xFFF5F7FA),
        borderRadius: BorderRadius.circular(14),
      ),
      child: Row(
        children: [
          buildCell('Member', flex: 3),
          buildCell('Coach'),
          buildCell('Progress'),
          buildCell('Actions', alignment: Alignment.centerRight),
        ],
      ),
    );
  }
}

class _AgencyMemberRow extends StatelessWidget {
  const _AgencyMemberRow({
    required this.data,
    required this.onRemove,
    required this.onUpload,
  });

  final _AdminMemberRowData data;
  final VoidCallback onRemove;
  final VoidCallback onUpload;

  static const Color _titleColor = Color(0xFF1F2937);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE5E7EB);
  static const Color _accentBlue = Color(0xFF2563EB);

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 24),
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 18),
      decoration: BoxDecoration(
        border: const Border(bottom: BorderSide(color: _borderColor)),
        color: Colors.white,
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Expanded(
            flex: 3,
            child: Row(
              children: [
                Container(
                  width: 42,
                  height: 42,
                  decoration: const BoxDecoration(
                    shape: BoxShape.circle,
                    color: Color(0xFFE5E7EB),
                  ),
                  alignment: Alignment.center,
                  child: const Icon(Icons.person_outline,
                      color: Color(0xFF4B5563)),
                ),
                const SizedBox(width: 14),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        data.name,
                        style: const TextStyle(
                          color: _titleColor,
                          fontSize: 14,
                          fontWeight: FontWeight.w700,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                      const SizedBox(height: 4),
                      Text(
                        data.role,
                        style: const TextStyle(
                            color: _mutedColor,
                            fontSize: 12,
                            fontWeight: FontWeight.w500),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          Expanded(
            flex: 2,
            child: Text(
              data.coach.isEmpty ? '‚Äî' : data.coach,
              style: const TextStyle(
                  color: _mutedColor,
                  fontSize: 13,
                  fontWeight: FontWeight.w500),
            ),
          ),
          Expanded(flex: 2, child: _ProgressBar(value: data.progress)),
          Expanded(
            flex: 2,
            child: Align(
              alignment: Alignment.centerRight,
              child: Wrap(
                spacing: 10,
                runSpacing: 8,
                alignment: WrapAlignment.end,
                children: [
                  OutlinedButton(
                    style: OutlinedButton.styleFrom(
                      foregroundColor: _accentBlue,
                      side: const BorderSide(color: _accentBlue),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(14)),
                      padding: const EdgeInsets.symmetric(
                          horizontal: 18, vertical: 12),
                      textStyle: const TextStyle(
                          fontSize: 13, fontWeight: FontWeight.w600),
                    ),
                    onPressed: onRemove,
                    child: const Text('Remove'),
                  ),
                  ElevatedButton(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: _accentBlue,
                      foregroundColor: Colors.white,
                      elevation: 0,
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(14)),
                      padding: const EdgeInsets.symmetric(
                          horizontal: 18, vertical: 12),
                      textStyle: const TextStyle(
                          fontSize: 13, fontWeight: FontWeight.w600),
                    ),
                    onPressed: onUpload,
                    child: const Text('Upload Results'),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _ProgressBar extends StatelessWidget {
  const _ProgressBar({required this.value});

  final double value;

  @override
  Widget build(BuildContext context) {
    final double resolved = value.clamp(0, 1).toDouble();
    return Padding(
      padding: const EdgeInsets.only(right: 24),
      child: Container(
        height: 8,
        decoration: BoxDecoration(
          color: const Color(0xFFE5E7EB),
          borderRadius: BorderRadius.circular(999),
        ),
        alignment: Alignment.centerLeft,
        child: resolved <= 0
            ? const SizedBox.shrink()
            : FractionallySizedBox(
                widthFactor: resolved,
                child: Container(
                  decoration: BoxDecoration(
                    color: const Color(0xFFD1D5DB),
                    borderRadius: BorderRadius.circular(999),
                  ),
                ),
              ),
      ),
    );
  }
}

class _CreateUserFormData {
  const _CreateUserFormData({
    required this.username,
    required this.firstName,
    required this.lastName,
    required this.email,
    required this.role,
    required this.agency,
    required this.agencyName,
    required this.password,
    required this.confirmPassword,
  });

  final String username;
  final String firstName;
  final String lastName;
  final String email;
  final String role;
  final String agency;
  final String agencyName;
  final String password;
  final String confirmPassword;
}

class _AdminCreateUsersDialog extends StatefulWidget {
  const _AdminCreateUsersDialog({
    required this.onCancel,
    required this.onSubmit,
  });

  final VoidCallback onCancel;
  final ValueChanged<_CreateUserFormData> onSubmit;

  @override
  State<_AdminCreateUsersDialog> createState() =>
      _AdminCreateUsersDialogState();
}

class _AdminCreateUsersDialogState extends State<_AdminCreateUsersDialog> {
  final TextEditingController _usernameController = TextEditingController();
  final TextEditingController _firstNameController = TextEditingController();
  final TextEditingController _lastNameController = TextEditingController();
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  final TextEditingController _confirmPasswordController =
      TextEditingController();

  String? _selectedRole;
  String? _selectedAgency;
  List<Map<String, String>> _agencies = [];
  bool _loadingAgencies = true;

  @override
  void initState() {
    super.initState();
    _loadAgencies();
  }

  Future<void> _loadAgencies() async {
    debugPrint('üìÑ Loading agencies for Create User dialog...');
    setState(() => _loadingAgencies = true);

    try {
      // Use a timeout to prevent infinite loading
      final snapshot = await FirebaseFirestore.instance
          .collection('agencies')
          .snapshots()
          .take(1)
          .single
          .timeout(const Duration(seconds: 10));

      debugPrint('‚úÖ Agencies loaded: ${snapshot.docs.length} docs found.');

      if (mounted) {
        setState(() {
          _agencies = snapshot.docs.map((doc) {
            final data = doc.data();
            return {
              'id': doc.id,
              'name': (data['agency_name'] ?? data['name'] ?? 'Unknown Agency')
                  as String,
            };
          }).toList();

          // Sort agencies alphabetically
          _agencies.sort((a, b) => (a['name'] ?? '').compareTo(b['name'] ?? ''));

          _loadingAgencies = false;
        });
      }
    } catch (e) {
      debugPrint('‚ùå Error loading agencies: $e');
      if (mounted) {
        setState(() => _loadingAgencies = false);
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to load agencies: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

    }


  @override
  void dispose() {
    _usernameController.dispose();
    _firstNameController.dispose();
    _lastNameController.dispose();
    _emailController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  void _handleSubmit() {
    widget.onSubmit(
      _CreateUserFormData(
        username: _usernameController.text.trim(),
        firstName: _firstNameController.text.trim(),
        lastName: _lastNameController.text.trim(),
        email: _emailController.text.trim(),
        role: (_selectedRole ?? '').trim(),
        agency: (_selectedAgency ?? '').trim(),
        agencyName: (_selectedAgency != null
                ? _agencies.firstWhere(
                    (element) => element['id'] == _selectedAgency,
                    orElse: () => {'name': ''},
                  )['name']
                : '') ??
            '',
        password: _passwordController.text,
        confirmPassword: _confirmPasswordController.text,
      ),
    );
  }

  InputDecoration _decoration(String label) {
    return InputDecoration(
      hintText: label,
      filled: true,
      fillColor: Colors.white,
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: Color(0xFFE2E8F0)),
      ),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: Color(0xFFE2E8F0)),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: Color(0xFF2563EB), width: 1.4),
      ),
    );
  }

  Widget _labeledField({required String label, required Widget child}) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: const TextStyle(
            fontSize: 13,
            fontWeight: FontWeight.w600,
            color: Color(0xFF1F2937),
          ),
        ),
        const SizedBox(height: 6),
        child,
      ],
    );
  }

  Widget _textField({
    required String label,
    required TextEditingController controller,
    bool obscure = false,
    TextInputType keyboardType = TextInputType.text,
  }) {
    return _labeledField(
      label: label,
      child: TextField(
        controller: controller,
        obscureText: obscure,
        keyboardType: keyboardType,
        decoration: _decoration(label),
      ),
    );
  }

  Widget _twoColumn(
      {required bool stack, required Widget left, required Widget right}) {
    if (stack) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          left,
          const SizedBox(height: 20),
          right,
        ],
      );
    }
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Expanded(child: left),
        const SizedBox(width: 20),
        Expanded(child: right),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      insetPadding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: 720),
        child: LayoutBuilder(
          builder: (context, constraints) {
            final bool stack = constraints.maxWidth < 620;

            return SingleChildScrollView(
              padding: const EdgeInsets.all(32),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: const [
                            Text(
                              'Create User Account',
                              style: TextStyle(
                                fontSize: 20,
                                fontWeight: FontWeight.w700,
                                color: Color(0xFF111827),
                              ),
                            ),
                            SizedBox(height: 8),
                            Text(
                              'Invite a new teammate and set their initial credentials in a single step.',
                              style: TextStyle(
                                fontSize: 13,
                                fontWeight: FontWeight.w500,
                                color: Color(0xFF6B7280),
                                height: 1.4,
                              ),
                            ),
                          ],
                        ),
                      ),
                      IconButton(
                        onPressed: widget.onCancel,
                        icon: const Icon(Icons.close),
                        color: const Color(0xFF6B7280),
                      ),
                    ],
                  ),
                  const SizedBox(height: 24),
                  const Divider(height: 1, color: Color(0xFFE5E7EB)),
                  const SizedBox(height: 24),
                  _twoColumn(
                    stack: stack,
                    left: _textField(
                        label: 'Username', controller: _usernameController),
                    right: _textField(
                      label: 'Email',
                      controller: _emailController,
                      keyboardType: TextInputType.emailAddress,
                    ),
                  ),
                  const SizedBox(height: 20),
                  _twoColumn(
                    stack: stack,
                    left: _textField(
                        label: 'First name', controller: _firstNameController),
                    right: _textField(
                        label: 'Last name', controller: _lastNameController),
                  ),
                  const SizedBox(height: 20),
                  _twoColumn(
                    stack: stack,
                    left: _labeledField(
                      label: 'Role',
                      child: DropdownButtonFormField<String>(
                        value: _selectedRole,
                        decoration: _decoration('Select role'),
                        hint: const Text('Select role'),
                        items: const [
                          DropdownMenuItem(
                              value: 'Admin', child: Text('Admin')),
                          DropdownMenuItem(
                              value: 'Coach', child: Text('Coach')),
                          DropdownMenuItem(
                              value: 'Member', child: Text('Member')),
                        ],
                        onChanged: (value) => setState(() {
                          _selectedRole = value;
                          // Clear agency selection when Admin is selected
                          if (value == 'Admin') {
                            _selectedAgency = null;
                          }
                        }),
                      ),
                    ),
                    right: _selectedRole == 'Admin'
                        ? const SizedBox
                            .shrink() // Hide agency field for Admin role
                        : _labeledField(
                            label: 'Agency',
                            child: _loadingAgencies
                                ? Container(
                                    height: 48,
                                    alignment: Alignment.centerLeft,
                                    padding: const EdgeInsets.symmetric(
                                        horizontal: 16),
                                    decoration: BoxDecoration(
                                      color: Colors.white,
                                      border: Border.all(
                                          color: const Color(0xFFE2E8F0)),
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    child: const Text(
                                      'Loading agencies...',
                                      style:
                                          TextStyle(color: Color(0xFF9CA3AF)),
                                    ),
                                  )
                                : DropdownButtonFormField<String>(
                                    value: _selectedAgency,
                                    decoration: _decoration('Select agency'),
                                    hint: const Text('Select agency'),
                                    items: _agencies.map((agency) {
                                      return DropdownMenuItem(
                                        value: agency['id'],
                                        child: Text(agency['name']!),
                                      );
                                    }).toList(),
                                    onChanged: (value) =>
                                        setState(() => _selectedAgency = value),
                                  ),
                          ),
                  ),
                  const SizedBox(height: 20),
                  _twoColumn(
                    stack: stack,
                    left: _textField(
                      label: 'Password',
                      controller: _passwordController,
                      obscure: true,
                    ),
                    right: _textField(
                      label: 'Confirm password',
                      controller: _confirmPasswordController,
                      obscure: true,
                    ),
                  ),
                  const SizedBox(height: 28),
                  Row(
                    children: [
                      Container(
                        height: 44,
                        width: 44,
                        decoration: BoxDecoration(
                          color: const Color(0xFF2563EB).withOpacity(0.08),
                          shape: BoxShape.circle,
                        ),
                        alignment: Alignment.center,
                        child: const Icon(Icons.mark_email_read_outlined,
                            color: Color(0xFF2563EB)),
                      ),
                      const SizedBox(width: 12),
                      const Expanded(
                        child: Text(
                          'We will send a confirmation email after the account is created.',
                          style: TextStyle(
                            fontSize: 13,
                            fontWeight: FontWeight.w500,
                            color: Color(0xFF6B7280),
                          ),
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 28),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: widget.onCancel,
                        child: const Text('Cancel'),
                      ),
                      const SizedBox(width: 16),
                      ElevatedButton(
                        onPressed: _handleSubmit,
                        style: ElevatedButton.styleFrom(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 28, vertical: 14),
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(12)),
                        ),
                        child: const Text('Create account'),
                      ),
                    ],
                  ),
                ],
              ),
            );
          },
        ),
      ),
    );
  }
}

class _AdminUploadContentDialog extends StatefulWidget {
  const _AdminUploadContentDialog(
      {required this.onCancel, required this.onSubmit});

  final VoidCallback onCancel;
  final VoidCallback onSubmit;

  @override
  State<_AdminUploadContentDialog> createState() =>
      _AdminUploadContentDialogState();
}

class _AdminUploadContentDialogState extends State<_AdminUploadContentDialog> {
  static const Color _titleColor = Color(0xFF1F2937);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE5E7EB);
  static const Color _accentBlue = Color(0xFF2563EB);
  static const Color _accentTeal = Color(0xFF1BA4B8);

  final TextEditingController _courseNameController = TextEditingController();
  final TextEditingController _courseDescriptionController =
      TextEditingController();
  final TextEditingController _videoTitleController = TextEditingController();
  final TextEditingController _contentDescriptionController =
      TextEditingController();
  final TextEditingController _durationController = TextEditingController();
  final TextEditingController _documentNameController = TextEditingController();

  String? _selectedTopic;
  String? _selectedTag;

  // File upload state
  PlatformFile? _selectedVideoFile;
  PlatformFile? _selectedSupportingFile;
  PlatformFile? _selectedThumbnailFile;
  bool _isUploadingVideo = false;
  bool _isUploadingSupportingFile = false;
  double _videoUploadProgress = 0.0;
  double _supportingFileUploadProgress = 0.0;

  @override
  void dispose() {
    _courseNameController.dispose();
    _courseDescriptionController.dispose();
    _videoTitleController.dispose();
    _contentDescriptionController.dispose();
    _durationController.dispose();
    _documentNameController.dispose();
    super.dispose();
  }

  Future<void> _pickVideoFile() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.video,
        withData: kIsWeb, // Load into memory on web for duration extraction
        withReadStream:
            !kIsWeb, // Use stream for large files on non-web platforms
      );

      if (result != null && result.files.isNotEmpty) {
        setState(() {
          _selectedVideoFile = result.files.first;
          if (_videoTitleController.text.isEmpty) {
            _videoTitleController.text = _selectedVideoFile!.name;
          }
        });

        // Extract video duration
        await _extractVideoDuration();

        // Show warning for large files
        if (_selectedVideoFile!.size > 1 * 1024 * 1024 * 1024) {
          // > 1GB
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text(
                  'Large file detected (${_formatFileSize(_selectedVideoFile!.size)}). '
                  'This will be uploaded to Google Cloud Storage for optimal performance.',
                ),
                duration: const Duration(seconds: 4),
                backgroundColor: Colors.blue.shade700,
              ),
            );
          }
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error selecting video: $e')),
        );
      }
    }
  }

  Future<void> _extractVideoDuration() async {
    if (_selectedVideoFile == null) return;

    try {
      VideoPlayerController? videoController;

      // Create video controller based on platform
      if (kIsWeb) {
        // For web, create a blob URL from the file bytes
        if (_selectedVideoFile!.bytes != null) {
          final blob = html.Blob([_selectedVideoFile!.bytes!]);
          final url = html.Url.createObjectUrlFromBlob(blob);
          videoController = VideoPlayerController.networkUrl(Uri.parse(url));

          await videoController.initialize();

          final duration = videoController.value.duration;
          final minutes = duration.inMinutes;
          final seconds = duration.inSeconds % 60;

          setState(() {
            _durationController.text =
                '$minutes:${seconds.toString().padLeft(2, '0')}';
          });

          videoController.dispose();
          html.Url.revokeObjectUrl(url);
        }
      } else {
        // For mobile/desktop platforms with file path
        if (_selectedVideoFile!.path != null) {
          // Use networkUrl instead of file since we want to avoid dart:io
          videoController = VideoPlayerController.networkUrl(
              Uri.file(_selectedVideoFile!.path!));
          await videoController.initialize();

          final duration = videoController.value.duration;
          final minutes = duration.inMinutes;
          final seconds = duration.inSeconds % 60;

          setState(() {
            _durationController.text =
                '$minutes:${seconds.toString().padLeft(2, '0')}';
          });

          videoController.dispose();
        }
      }
    } catch (e) {
      print('Error extracting video duration: $e');
      // Don't show error to user, duration extraction is optional
    }
  }

  Future<void> _pickSupportingFile() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['pdf', 'ppt', 'pptx', 'doc', 'docx'],
        withData: true,
      );

      if (result != null && result.files.isNotEmpty) {
        setState(() {
          _selectedSupportingFile = result.files.first;
          // Auto-populate document name with uploaded filename
          _documentNameController.text = _selectedSupportingFile!.name;
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error selecting file: $e')),
        );
      }
    }
  }

  Future<void> _pickThumbnailFile() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        withData: true,
      );

      if (result != null && result.files.isNotEmpty) {
        setState(() {
          _selectedThumbnailFile = result.files.first;
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error selecting thumbnail: $e')),
        );
      }
    }
  }

  Future<String?> _uploadFile(PlatformFile file, String fileType) async {
    try {
      final fileName = '${DateTime.now().millisecondsSinceEpoch}_${file.name}';
      final contentType = _getContentType(file.extension);
      final isVideo = fileType == 'video';

      // Determine if we should use GCS (for files > 1GB)
      final useGCS = file.size > 1 * 1024 * 1024 * 1024;

      if (useGCS) {
        // Use GCS for large files
        final storagePath = '$fileType/$fileName';
        debugPrint(
            'üì§ [GCS] Starting upload to $storagePath (type=$contentType, size=${_formatFileSize(file.size)})');

        if (file.readStream != null) {
          // Use stream if available (non-web platforms)
          return await GCSService.uploadLargeFile(
            fileName: storagePath,
            fileStream: file.readStream!,
            fileSize: file.size,
            contentType: contentType,
            onProgress: (progress) {
              setState(() {
                if (isVideo) {
                  _videoUploadProgress = progress;
                } else {
                  _supportingFileUploadProgress = progress;
                }
              });
            },
          );
        } else if (file.bytes != null) {
          // For web, use bytes directly with GCS upload
          return await GCSService.uploadFile(
            fileName: storagePath,
            fileBytes: file.bytes!,
            contentType: contentType,
            onProgress: (progress) {
              setState(() {
                if (isVideo) {
                  _videoUploadProgress = progress;
                } else {
                  _supportingFileUploadProgress = progress;
                }
              });
            },
          );
        } else {
          throw Exception(
              'Cannot upload file: no data available. Please try re-selecting the file.');
        }
      } else {
        // Use Firebase Storage for smaller files
        if (file.bytes != null) {
          // Use the proper path based on file type (video/ or document/)
          final storagePath = '$fileType/$fileName';
          debugPrint(
              'üì§ [Firebase Storage] Starting upload to $storagePath (type=$contentType, size=${_formatFileSize(file.size)})');
          final storageRef = FirebaseStorage.instance.ref().child(storagePath);
          final uploadTask = storageRef.putData(
            file.bytes!,
            SettableMetadata(contentType: contentType),
          );

          uploadTask.snapshotEvents.listen((snapshot) {
            final progress = snapshot.bytesTransferred / snapshot.totalBytes;
            setState(() {
              if (isVideo) {
                _videoUploadProgress = progress;
              } else {
                _supportingFileUploadProgress = progress;
              }
            });
          });

          final snapshot = await uploadTask;
          final url = await snapshot.ref.getDownloadURL();
          debugPrint('‚úÖ Upload complete for $storagePath');
          return url;
        } else {
          throw Exception('File data not available');
        }
      }
    } catch (e) {
      debugPrint('‚ùå Error uploading $fileType: $e');
      rethrow;
    }
  }

  String _getContentType(String? extension) {
    if (extension == null) return 'application/octet-stream';

    final ext = extension.toLowerCase();
    switch (ext) {
      case 'pdf':
        return 'application/pdf';
      case 'doc':
      case 'docx':
        return 'application/msword';
      case 'ppt':
      case 'pptx':
        return 'application/vnd.ms-powerpoint';
      case 'mp4':
        return 'video/mp4';
      case 'mov':
        return 'video/quicktime';
      case 'avi':
        return 'video/x-msvideo';
      default:
        return 'application/octet-stream';
    }
  }

  String _formatFileSize(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    if (bytes < 1024 * 1024 * 1024) {
      return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
    }
    return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(2)} GB';
  }

  Future<void> _handleUploadWithFiles() async {
    // Validate required fields for Course Essentials
    if (_courseNameController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter a course name')),
      );
      return;
    }

    if (_selectedTopic == null || _selectedTopic!.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a topic')),
      );
      return;
    }

    if (_selectedTag == null || _selectedTag!.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a tag')),
      );
      return;
    }

    if (_courseDescriptionController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter a course description')),
      );
      return;
    }

    // Check if at least one media type is uploaded
    if (_selectedVideoFile == null && _selectedSupportingFile == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content:
                Text('Please upload at least a video or supporting material')),
      );
      return;
    }

    // Validate that if supporting file is uploaded, description is mandatory
    if (_selectedSupportingFile != null &&
        _contentDescriptionController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content:
                Text('Please enter a description for the supporting material')),
      );
      return;
    }

    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please log in to upload content')),
      );
      return;
    }

    setState(() {
      if (_selectedVideoFile != null) {
        _isUploadingVideo = true;
        _videoUploadProgress = 0.0;
      }
      if (_selectedSupportingFile != null) {
        _isUploadingSupportingFile = true;
        _supportingFileUploadProgress = 0.0;
      }
    });

    try {
      // Upload video if selected
      String? videoUrl;
      if (_selectedVideoFile != null) {
        videoUrl = await _uploadFile(_selectedVideoFile!, 'video');
        if (videoUrl == null) throw Exception('Video upload failed');
      }

      // Upload supporting file if selected
      String? supportingFileUrl;
      String? documentDocId;
      if (_selectedSupportingFile != null) {
        supportingFileUrl =
            await _uploadFile(_selectedSupportingFile!, 'document');
        if (supportingFileUrl == null) {
          throw Exception('Document upload failed');
        }

        // Create document in 'documents' collection
        final documentData = {
          'document_name': _documentNameController.text.trim(),
          'content_description': _contentDescriptionController.text.trim(),
          'supporting_file_url': supportingFileUrl,
          'supporting_file_name': _selectedSupportingFile!.name,
          'file_size': _selectedSupportingFile!.size,
          'uploaded_by': user.uid,
          'uploaded_by_email': user.email,
          'uploaded_at': FieldValue.serverTimestamp(),
        };

        final documentDoc = await FirebaseFirestore.instance
            .collection('documents')
            .add(documentData);
        documentDocId = documentDoc.id;
      }

      // Create a single document in 'video' collection for all content
      final videoData = {
        'course_name': _courseNameController.text.trim(),
        'title': _courseNameController.text.trim(),
        'description': _courseDescriptionController.text.trim(),
        'topic': _selectedTopic,
        'tags': _selectedTag != null ? [_selectedTag] : [],
        'series': _selectedTopic,
        'uploaded_by': user.uid,
        'uploaded_by_email': user.email,
        'uploaded_at': FieldValue.serverTimestamp(),
        'up_vote': 0,
      };

      // Add video-specific fields if video was uploaded
      if (videoUrl != null && _selectedVideoFile != null) {
        videoData['video_title'] = _videoTitleController.text.trim();
        videoData['video_url'] = videoUrl;
        videoData['video_file_name'] = _selectedVideoFile!.name;
        videoData['video_file_size'] = _selectedVideoFile!.size;
        videoData['storage_type'] =
            _selectedVideoFile!.size > 1 * 1024 * 1024 * 1024
                ? 'gcs'
                : 'firebase';
        videoData['has_video'] = true;
        if (_durationController.text.trim().isNotEmpty) {
          videoData['duration'] = _durationController.text.trim();
        }
      }

      // Add document reference if document was uploaded
      if (documentDocId != null) {
        videoData['document_ref'] = FirebaseFirestore.instance
            .collection('documents')
            .doc(documentDocId);
        videoData['document_id'] = documentDocId;
        videoData['has_document'] = true;
      }

      // Add thumbnail if uploaded
      if (_selectedThumbnailFile != null) {
        final thumbnailUrl =
            await _uploadFile(_selectedThumbnailFile!, 'thumbnail');
        if (thumbnailUrl != null) {
          videoData['thumbnailUrl'] = thumbnailUrl;
          videoData['thumbnail'] = thumbnailUrl;
        }
      }

      final videoDoc =
          await FirebaseFirestore.instance.collection('video').add(videoData);
      final videoDocId = videoDoc.id;

      // Create course document in 'courses' collection with references
      final courseData = {
        'course_name': _courseNameController.text.trim(),
        'title': _courseNameController.text.trim(),
        'description': _courseDescriptionController.text.trim(),
        'course_description': _courseDescriptionController.text.trim(),
        'topic': _selectedTopic,
        'tag': _selectedTag,
        'uploaded_by': user.uid,
        'uploaded_by_email': user.email,
        'created_at': FieldValue.serverTimestamp(),
        'updated_at': FieldValue.serverTimestamp(),
      };

      // Add video reference if video was uploaded
      courseData['video_ref'] =
          FirebaseFirestore.instance.collection('video').doc(videoDocId);
      courseData['video_id'] = videoDocId;
      courseData['has_video'] = true;
      if (_durationController.text.trim().isNotEmpty) {
        courseData['duration'] = _durationController.text.trim();
      }

      // Add document reference if document was uploaded
      if (documentDocId != null) {
        courseData['document_ref'] = FirebaseFirestore.instance
            .collection('documents')
            .doc(documentDocId);
        courseData['document_id'] = documentDocId;
        courseData['has_document'] = true;
      }

      await FirebaseFirestore.instance.collection('courses').add(courseData);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Content uploaded successfully!'),
            backgroundColor: Colors.green,
          ),
        );
        widget.onSubmit();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error uploading content: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isUploadingVideo = false;
          _isUploadingSupportingFile = false;
        });
      }
    }
  }

  InputDecoration _inputDecoration(String hint, {int minLines = 1}) {
    return InputDecoration(
      hintText: hint,
      filled: true,
      fillColor: Colors.white,
      contentPadding: EdgeInsets.symmetric(
        horizontal: 18,
        vertical: minLines > 1 ? 18 : 16,
      ),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(16),
        borderSide: const BorderSide(color: _borderColor),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(16),
        borderSide: const BorderSide(color: _accentBlue, width: 1.4),
      ),
    );
  }

  Widget _buildLabeledField(
      {required String label,
      required Widget child,
      EdgeInsetsGeometry? padding}) {
    return Padding(
      padding: padding ?? EdgeInsets.zero,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            label,
            style: const TextStyle(
              color: _titleColor,
              fontSize: 14,
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 8),
          child,
        ],
      ),
    );
  }

  Widget _dropZone({
    required IconData icon,
    required String title,
    required String caption,
    double height = 180,
    VoidCallback? onTap,
    PlatformFile? selectedFile,
    bool isUploading = false,
    double uploadProgress = 0.0,
  }) {
    return InkWell(
      onTap: isUploading ? null : onTap,
      borderRadius: BorderRadius.circular(24),
      child: Ink(
        height: height,
        decoration: BoxDecoration(
          color: selectedFile != null
              ? const Color(0xFFE6F7FF)
              : const Color(0xFFF9FAFF),
          borderRadius: BorderRadius.circular(24),
          border: Border.all(
            color: selectedFile != null
                ? const Color(0xFF91D5FF)
                : const Color(0xFFD5DAE5),
            width: 1.2,
          ),
          boxShadow: const [
            BoxShadow(
              color: Color(0x08000000),
              blurRadius: 20,
              offset: Offset(0, 12),
            ),
          ],
        ),
        child: isUploading
            ? Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const CircularProgressIndicator(),
                  const SizedBox(height: 16),
                  Text(
                    'Uploading: ${(uploadProgress * 100).toStringAsFixed(0)}%',
                    style: const TextStyle(
                      color: _accentBlue,
                      fontSize: 14,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 40),
                    child: LinearProgressIndicator(
                      value: uploadProgress,
                      backgroundColor: Colors.grey.shade200,
                      minHeight: 6,
                      borderRadius: BorderRadius.circular(3),
                    ),
                  ),
                ],
              )
            : selectedFile != null
                ? Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.check_circle, color: Colors.green, size: 48),
                      const SizedBox(height: 12),
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16),
                        child: Text(
                          selectedFile.name,
                          style: const TextStyle(
                            color: _titleColor,
                            fontSize: 14,
                            fontWeight: FontWeight.w600,
                          ),
                          textAlign: TextAlign.center,
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        _formatFileSize(selectedFile.size),
                        style: const TextStyle(
                          color: _mutedColor,
                          fontSize: 13,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        'Click to change file',
                        style: TextStyle(
                          color: _accentBlue,
                          fontSize: 12,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  )
                : Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Container(
                        width: 56,
                        height: 56,
                        decoration: BoxDecoration(
                          color: Colors.white,
                          shape: BoxShape.circle,
                          boxShadow: const [
                            BoxShadow(
                              color: Color(0x15000000),
                              blurRadius: 12,
                              offset: Offset(0, 6),
                            ),
                          ],
                        ),
                        alignment: Alignment.center,
                        child: Icon(icon, size: 26, color: _accentBlue),
                      ),
                      const SizedBox(height: 16),
                      Text(
                        title,
                        style: const TextStyle(
                          color: _titleColor,
                          fontSize: 15,
                          fontWeight: FontWeight.w700,
                        ),
                      ),
                      const SizedBox(height: 6),
                      Text(
                        caption,
                        textAlign: TextAlign.center,
                        style: const TextStyle(
                          color: _mutedColor,
                          fontSize: 13,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
      ),
    );
  }

  Widget _infoPill({required IconData icon, required String label}) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
      decoration: BoxDecoration(
        color: const Color(0xFFE8EEFF),
        borderRadius: BorderRadius.circular(999),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 18, color: _accentBlue),
          const SizedBox(width: 8),
          Text(
            label,
            style: const TextStyle(
              color: Color(0xFF1B3A8A),
              fontSize: 13,
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      ),
    );
  }

  Widget _stepChip(
      {required String label, required bool active, IconData? icon}) {
    final Color background = active ? const Color(0xFF1B4BD7) : Colors.white;
    final Color foreground = active ? Colors.white : const Color(0xFF1B3A8A);
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
      decoration: BoxDecoration(
        color: background,
        borderRadius: BorderRadius.circular(999),
        border: Border.all(color: const Color(0xFFCBD5F5)),
        boxShadow: active
            ? const [
                BoxShadow(
                  color: Color(0x331B4BD7),
                  blurRadius: 14,
                  offset: Offset(0, 10),
                ),
              ]
            : null,
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (icon != null) ...[
            Icon(icon, size: 16, color: foreground),
            const SizedBox(width: 6),
          ],
          Text(
            label,
            style: TextStyle(
              color: foreground,
              fontSize: 13,
              fontWeight: FontWeight.w700,
              letterSpacing: 0.3,
            ),
          ),
        ],
      ),
    );
  }

  Widget _sectionCard({
    required String title,
    String? subtitle,
    required List<Widget> children,
  }) {
    return Container(
      padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(28),
        border: Border.all(color: const Color(0xFFE5EAF5)),
        boxShadow: const [
          BoxShadow(
            color: Color(0x0F000000),
            blurRadius: 30,
            offset: Offset(0, 20),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: const TextStyle(
              color: _titleColor,
              fontSize: 18,
              fontWeight: FontWeight.w700,
            ),
          ),
          if (subtitle != null) ...[
            const SizedBox(height: 6),
            Text(
              subtitle,
              style: const TextStyle(
                color: _mutedColor,
                fontSize: 14,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
          const SizedBox(height: 24),
          ...children,
        ],
      ),
    );
  }

  Widget _buildHeroHeader(bool compactLayout) {
    return Container(
      padding: EdgeInsets.symmetric(
        horizontal: compactLayout ? 24 : 32,
        vertical: compactLayout ? 24 : 30,
      ),
      decoration: BoxDecoration(
        gradient: const LinearGradient(
          colors: [Color(0xFFE6EEFF), Color(0xFFD8F8F5)],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(28),
        border: Border.all(color: const Color(0xFFCCE1FF)),
        boxShadow: const [
          BoxShadow(
            color: Color(0x14000000),
            blurRadius: 24,
            offset: Offset(0, 18),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                width: 60,
                height: 60,
                decoration: BoxDecoration(
                  color: Colors.white,
                  shape: BoxShape.circle,
                  boxShadow: const [
                    BoxShadow(
                      color: Color(0x1A000000),
                      blurRadius: 16,
                      offset: Offset(0, 10),
                    ),
                  ],
                ),
                alignment: Alignment.center,
                child: const Icon(Icons.cloud_upload_outlined,
                    color: _accentBlue, size: 30),
              ),
              const SizedBox(width: 20),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: const [
                    Text(
                      'Upload Content',
                      style: TextStyle(
                        color: _titleColor,
                        fontSize: 24,
                        fontWeight: FontWeight.w800,
                      ),
                    ),
                    SizedBox(height: 8),
                    Text(
                      'Deliver a cinema-quality learning moment in minutes. Guided steps help you stay polished and consistent every time.',
                      style: TextStyle(
                        color: Color(0xFF1B3A8A),
                        fontSize: 15,
                        fontWeight: FontWeight.w500,
                        height: 1.4,
                      ),
                    ),
                  ],
                ),
              ),
              if (!compactLayout) ...[
                const SizedBox(width: 24),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: const [
                    Text(
                      'Need inspiration?',
                      style: TextStyle(
                        color: _titleColor,
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    SizedBox(height: 6),
                    Text(
                      'Browse top-performing courses in the library for best practices.',
                      textAlign: TextAlign.right,
                      style: TextStyle(
                        color: _mutedColor,
                        fontSize: 13,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ],
            ],
          ),
          const SizedBox(height: 22),
          Wrap(
            spacing: 12,
            runSpacing: 12,
            children: [
              _stepChip(
                  label: '1 ¬∑ Course Details',
                  active: true,
                  icon: Icons.check_circle),
              _stepChip(
                  label: '2 ¬∑ Media Uploads',
                  active: false,
                  icon: Icons.video_library_outlined),
              _stepChip(
                  label: '3 ¬∑ Publish Settings',
                  active: false,
                  icon: Icons.rocket_launch_outlined),
            ],
          ),
        ],
      ),
    );
  }

  SizedBox _primaryButton(
      {required String label, required VoidCallback onPressed}) {
    return SizedBox(
      height: 48,
      child: ElevatedButton(
        style: ElevatedButton.styleFrom(
          backgroundColor: _accentBlue,
          foregroundColor: Colors.white,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
          elevation: 0,
          padding: const EdgeInsets.symmetric(horizontal: 24),
          textStyle: const TextStyle(fontSize: 15, fontWeight: FontWeight.w600),
        ),
        onPressed: onPressed,
        child: Text(label),
      ),
    );
  }

  void _showComingSoon() {
    ScaffoldMessenger.of(context)
      ..hideCurrentSnackBar()
      ..showSnackBar(
        const SnackBar(
          content: Text('Thumbnail upload coming soon.'),
          duration: Duration(seconds: 2),
        ),
      );
  }

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final bool stackColumns = constraints.maxWidth < 1080;
          final bool compactLayout = constraints.maxWidth < 900;

          final Widget courseDetails = LayoutBuilder(
            builder: (context, sizeConstraints) {
              final bool wrapFields = sizeConstraints.maxWidth < 880;

              final Widget courseNameField = _buildLabeledField(
                label: 'Course Name',
                child: TextField(
                  controller: _courseNameController,
                  decoration:
                      _inputDecoration('Give your course a memorable name'),
                  textCapitalization: TextCapitalization.sentences,
                ),
              );

              final Widget topicField = _buildLabeledField(
                label: 'Topic',
                child: DropdownButtonFormField<String>(
                  value: _selectedTopic,
                  items: const [
                    DropdownMenuItem(value: 'THINK', child: Text('THINK')),
                    DropdownMenuItem(value: 'KEEP', child: Text('KEEP')),
                    DropdownMenuItem(
                        value: 'ACCELERATE', child: Text('ACCELERATE')),
                    DropdownMenuItem(
                        value: 'TRANSFORM', child: Text('TRANSFORM')),
                    DropdownMenuItem(
                        value: 'ABUNDANCE', child: Text('ABUNDANCE')),
                    DropdownMenuItem(
                        value: 'Expert Series', child: Text('Expert Series')),
                    DropdownMenuItem(
                        value: 'Immersive Footage',
                        child: Text('Immersive Footage')),
                  ],
                  decoration: _inputDecoration('Select...'),
                  onChanged: (value) => setState(() => _selectedTopic = value),
                ),
              );

              final Widget tagsField = _buildLabeledField(
                label: 'Tags',
                child: DropdownButtonFormField<String>(
                  value: _selectedTag,
                  items: const [
                    DropdownMenuItem(value: 'No Tags', child: Text('No Tags')),
                    DropdownMenuItem(
                        value: 'Featured', child: Text('Featured')),
                    DropdownMenuItem(value: 'New', child: Text('New')),
                    DropdownMenuItem(
                        value: 'Immersive', child: Text('Immersive')),
                  ],
                  decoration: _inputDecoration('No Tags'),
                  onChanged: (value) => setState(() => _selectedTag = value),
                ),
              );

              final Widget topFields = wrapFields
                  ? Column(
                      children: [
                        courseNameField,
                        const SizedBox(height: 20),
                        topicField,
                        const SizedBox(height: 20),
                        tagsField,
                      ],
                    )
                  : Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Expanded(flex: 2, child: courseNameField),
                        const SizedBox(width: 24),
                        Expanded(child: topicField),
                        const SizedBox(width: 24),
                        Expanded(child: tagsField),
                      ],
                    );

              final Widget descriptionSection = _buildLabeledField(
                label: 'Description',
                child: TextField(
                  controller: _courseDescriptionController,
                  minLines: 4,
                  maxLines: 6,
                  decoration: _inputDecoration(
                      'Tell learners what they will gain from this course',
                      minLines: 4),
                ),
              );

              return _sectionCard(
                title: 'Course Essentials',
                subtitle:
                    'Craft a compelling overview so members know they are in the right place.',
                children: [
                  topFields,
                  const SizedBox(height: 24),
                  descriptionSection,
                ],
              );
            },
          );

          final Widget videoColumn = Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Primary Video',
                style: TextStyle(
                  color: _titleColor,
                  fontSize: 16,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 12),
              _dropZone(
                icon: Icons.play_circle_outline,
                title: 'Drop video file here or click to browse',
                caption: _selectedVideoFile == null
                    ? 'MP4 or MOV ¬∑ Supports files up to 5TB via GCS'
                    : 'MP4 or MOV ¬∑ Large files uploaded via GCS',
                height: 200,
                onTap: _pickVideoFile,
                selectedFile: _selectedVideoFile,
                isUploading: _isUploadingVideo,
                uploadProgress: _videoUploadProgress,
              ),
              const SizedBox(height: 16),
              const Text(
                'Tip: Keep videos between 5‚Äì10 minutes for the best engagement.',
                style: TextStyle(
                    color: _mutedColor,
                    fontSize: 13,
                    fontWeight: FontWeight.w500),
              ),
              const SizedBox(height: 24),
              _buildLabeledField(
                label: 'Upload Thumbnail',
                child: GestureDetector(
                  onTap: _pickThumbnailFile,
                  child: Container(
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      color: _selectedThumbnailFile != null
                          ? Colors.green.shade50
                          : Colors.grey.shade50,
                      border: Border.all(
                        color: _selectedThumbnailFile != null
                            ? Colors.green
                            : Colors.grey.shade300,
                        width: 2,
                      ),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          _selectedThumbnailFile != null
                              ? Icons.check_circle
                              : Icons.image_outlined,
                          color: _selectedThumbnailFile != null
                              ? Colors.green
                              : Colors.grey.shade600,
                          size: 24,
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: Text(
                            _selectedThumbnailFile != null
                                ? _selectedThumbnailFile!.name
                                : 'Click to upload thumbnail image',
                            style: TextStyle(
                              color: _selectedThumbnailFile != null
                                  ? Colors.green.shade900
                                  : Colors.grey.shade700,
                              fontSize: 14,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 16),
              _buildLabeledField(
                label: 'Video Title',
                child: TextField(
                  controller: _videoTitleController,
                  decoration: _inputDecoration(
                      'Give the video a clear, descriptive name'),
                ),
              ),
            ],
          );

          final Widget fileColumn = Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Supporting Materials',
                style: TextStyle(
                  color: _titleColor,
                  fontSize: 16,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 12),
              _dropZone(
                icon: Icons.file_upload_outlined,
                title: 'Attach worksheets, slides, or notes',
                caption: _selectedSupportingFile == null
                    ? 'PDF, PPT, DOC ¬∑ up to 25 MB'
                    : 'PDF, PPT, DOC',
                height: 180,
                onTap: _pickSupportingFile,
                selectedFile: _selectedSupportingFile,
                isUploading: _isUploadingSupportingFile,
                uploadProgress: _supportingFileUploadProgress,
              ),
              const SizedBox(height: 24),
              _buildLabeledField(
                label: 'Document name',
                child: TextField(
                  controller: _documentNameController,
                  decoration:
                      _inputDecoration('Document title learners will see'),
                ),
              ),
              const SizedBox(height: 16),
              _buildLabeledField(
                label: 'Description',
                child: TextField(
                  controller: _contentDescriptionController,
                  minLines: 3,
                  maxLines: 5,
                  decoration: _inputDecoration(
                      'Briefly describe what learners should expect',
                      minLines: 3),
                ),
              ),
              const SizedBox(height: 16),
              _buildLabeledField(
                label: 'Duration',
                child: TextField(
                  controller: _durationController,
                  decoration: _inputDecoration('Video duration in minutes'),
                  keyboardType: TextInputType.text,
                  readOnly: true,
                ),
              ),
            ],
          );

          final Widget mediaSection = _sectionCard(
            title: 'Learning Assets',
            subtitle:
                'Upload the video lesson and any companion documents in one flow.',
            children: [
              stackColumns
                  ? Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        videoColumn,
                        const SizedBox(height: 32),
                        fileColumn,
                      ],
                    )
                  : Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Expanded(child: videoColumn),
                        const SizedBox(width: 32),
                        Expanded(child: fileColumn),
                      ],
                    ),
            ],
          );

          return ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 1120),
            child: DecoratedBox(
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(36),
                boxShadow: const [
                  BoxShadow(
                    color: Color(0x33000000),
                    blurRadius: 30,
                    offset: Offset(0, 24),
                  ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(36),
                child: Container(
                  color: const Color(0xFFF4F7FF),
                  padding: EdgeInsets.symmetric(
                    horizontal: compactLayout ? 28 : 40,
                    vertical: compactLayout ? 32 : 40,
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      _buildHeroHeader(compactLayout),
                      const SizedBox(height: 28),
                      Wrap(
                        spacing: 16,
                        runSpacing: 12,
                        children: [
                          _infoPill(
                              icon: Icons.security_outlined,
                              label: 'Secure cloud storage'),
                          _infoPill(
                              icon: Icons.hd_outlined,
                              label: '1080p streaming ready'),
                          _infoPill(
                              icon: Icons.timer_outlined,
                              label: 'Auto-saves as you go'),
                        ],
                      ),
                      const SizedBox(height: 28),
                      courseDetails,
                      const SizedBox(height: 28),
                      mediaSection,
                      const SizedBox(height: 32),
                      Row(
                        children: [
                          OutlinedButton.icon(
                            onPressed: _showComingSoon,
                            style: OutlinedButton.styleFrom(
                              foregroundColor: const Color(0xFF1B3A8A),
                              side: const BorderSide(color: Color(0xFFB8C6FF)),
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 22, vertical: 16),
                              textStyle: const TextStyle(
                                  fontSize: 14, fontWeight: FontWeight.w600),
                            ),
                            icon: const Icon(Icons.save_outlined, size: 18),
                            label: const Text('Save as Draft'),
                          ),
                          const Spacer(),
                          TextButton(
                            onPressed: widget.onCancel,
                            style: TextButton.styleFrom(
                              foregroundColor: _mutedColor,
                              textStyle: const TextStyle(
                                  fontSize: 15, fontWeight: FontWeight.w600),
                            ),
                            child: const Text('Cancel'),
                          ),
                          const SizedBox(width: 16),
                          SizedBox(
                            height: 50,
                            child: ElevatedButton(
                              style: ElevatedButton.styleFrom(
                                backgroundColor: _accentTeal,
                                foregroundColor: Colors.white,
                                shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(16)),
                                elevation: 0,
                                padding:
                                    const EdgeInsets.symmetric(horizontal: 30),
                                textStyle: const TextStyle(
                                    fontSize: 16, fontWeight: FontWeight.w700),
                              ),
                              onPressed: (_isUploadingVideo ||
                                      _isUploadingSupportingFile)
                                  ? null
                                  : _handleUploadWithFiles,
                              child: _isUploadingVideo ||
                                      _isUploadingSupportingFile
                                  ? const SizedBox(
                                      width: 20,
                                      height: 20,
                                      child: CircularProgressIndicator(
                                        strokeWidth: 2,
                                        valueColor:
                                            AlwaysStoppedAnimation<Color>(
                                                Colors.white),
                                      ),
                                    )
                                  : const Text('Upload Course'),
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

class _AdminPlaceholderView extends StatelessWidget {
  const _AdminPlaceholderView({
    required this.title,
    required this.onAction,
  });

  final String title;
  final VoidCallback onAction;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.fromLTRB(32, 32, 32, 16),
          child: Row(
            children: [
              Text(
                title,
                style: const TextStyle(
                  color: Color(0xFF1F2937),
                  fontSize: 22,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const Spacer(),
              ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF2563EB),
                  foregroundColor: Colors.white,
                  elevation: 0,
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12)),
                  padding:
                      const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
                  textStyle: const TextStyle(
                      fontWeight: FontWeight.w600, fontSize: 15),
                ),
                onPressed: onAction,
                child: const Text('New action'),
              ),
            ],
          ),
        ),
        const Divider(height: 1, color: Color(0xFFE2E8F0)),
        Expanded(
          child: Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: const [
                Icon(Icons.build, size: 64, color: Color(0xFFCBD5F5)),
                SizedBox(height: 16),
                Text(
                  'This section is under construction.',
                  style: TextStyle(
                      color: Color(0xFF6B7280),
                      fontSize: 15,
                      fontWeight: FontWeight.w500),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}

/// Dialog widget for editing existing course content and managing video modules.
class _AdminEditContentDialog extends StatefulWidget {
  const _AdminEditContentDialog({
    super.key,
    required this.course,
    required this.onCancel,
    required this.onSubmit,
  });

  final _LibraryCardData course;
  final VoidCallback onCancel;
  final VoidCallback onSubmit;

  @override
  State<_AdminEditContentDialog> createState() =>
      _AdminEditContentDialogState();
}

class _AdminEditContentDialogState extends State<_AdminEditContentDialog> {
  static const Color _titleColor = Color(0xFF0A1B47);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _accentBlue = Color(0xFF2563EB);

  late final TextEditingController _courseNameController;
  late final TextEditingController _descriptionController;
  String? _selectedTopic;

  bool _isSaving = false;
  String? _errorMessage;

  // Module management
  List<Map<String, dynamic>> _modules = [];
  bool _isLoadingModules = true;

  // Video upload state for modules
  Map<int, PlatformFile?> _moduleVideoFiles = {};
  Map<int, double> _moduleUploadProgress = {};
  Map<int, bool> _moduleUploading = {};

  @override
  void initState() {
    super.initState();
    final data = widget.course.originalData;
    _courseNameController =
        TextEditingController(text: data['course_name'] ?? data['title'] ?? '');
    _descriptionController =
        TextEditingController(text: data['description'] ?? '');
    _selectedTopic = data['topic'];

    // Load video modules asynchronously from DocumentReferences
    _loadVideoModules();
  }

  /// Loads video modules from the 'videos' field which contains DocumentReferences
  Future<void> _loadVideoModules() async {
    try {
      final videosField = widget.course.originalData['videos'];
      if (videosField is! List) {
        setState(() => _isLoadingModules = false);
        return;
      }

      // Extract video IDs from DocumentReferences
      List<String> videoIds = [];
      for (final item in videosField) {
        if (item is DocumentReference) {
          videoIds.add(item.id);
        } else if (item is String && item.isNotEmpty) {
          // Direct ID string
          if (item.startsWith('/video/') || item.startsWith('/videos/')) {
            videoIds.add(item.split('/').last);
          } else {
            videoIds.add(item);
          }
        }
      }

      // Fetch video documents
      final modules = <Map<String, dynamic>>[];
      final videoCollection = FirebaseFirestore.instance.collection('video');
      final videosCollection = FirebaseFirestore.instance.collection('videos');

      for (final id in videoIds) {
        try {
          // Try 'video' collection first
          var doc = await videoCollection.doc(id).get();
          if (!doc.exists) {
            // Try 'videos' collection
            doc = await videosCollection.doc(id).get();
          }
          if (doc.exists) {
            final data = doc.data()!;
            modules.add({
              'id': doc.id,
              'title': data['title'] ?? data['course_name'] ?? data['video_title'] ?? '',
              'videoUrl': data['videoUrl'] ?? data['video_url'] ?? '',
              'description': data['description'] ?? data['video_description'] ?? '',
            });
          }
        } catch (e) {
          debugPrint('Error fetching video module $id: $e');
        }
      }

      if (mounted) {
        setState(() {
          _modules = modules;
          _isLoadingModules = false;
        });
      }
    } catch (e) {
      debugPrint('Error loading video modules: $e');
      if (mounted) {
        setState(() => _isLoadingModules = false);
      }
    }
  }

  /// Pick a video file for a specific module
  Future<void> _pickVideoForModule(int index) async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.video,
        withData: true,
      );

      if (result != null && result.files.isNotEmpty) {
        setState(() {
          _moduleVideoFiles[index] = result.files.first;
        });
        // Start upload immediately after picking
        await _uploadVideoForModule(index);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error selecting video: $e')),
        );
      }
    }
  }

  /// Upload video for a specific module to Firebase Storage
  Future<void> _uploadVideoForModule(int index) async {
    final file = _moduleVideoFiles[index];
    if (file == null || file.bytes == null) return;

    setState(() {
      _moduleUploading[index] = true;
      _moduleUploadProgress[index] = 0;
    });

    try {
      final fileName = '${DateTime.now().millisecondsSinceEpoch}_${file.name}';
      final storagePath = 'video/$fileName';
      final contentType = _getVideoContentType(file.extension);

      debugPrint('üì§ Starting upload to $storagePath');
      final storageRef = FirebaseStorage.instance.ref().child(storagePath);
      final uploadTask = storageRef.putData(
        file.bytes!,
        SettableMetadata(contentType: contentType),
      );

      uploadTask.snapshotEvents.listen((snapshot) {
        final progress = snapshot.bytesTransferred / snapshot.totalBytes;
        if (mounted) {
          setState(() {
            _moduleUploadProgress[index] = progress;
          });
        }
      });

      final snapshot = await uploadTask;
      final url = await snapshot.ref.getDownloadURL();
      debugPrint('‚úÖ Upload complete: $url');

      if (mounted) {
        setState(() {
          _modules[index]['videoUrl'] = url;
          _moduleUploading[index] = false;
          _moduleVideoFiles[index] = null;
        });
      }
    } catch (e) {
      debugPrint('‚ùå Error uploading video: $e');
      if (mounted) {
        setState(() {
          _moduleUploading[index] = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to upload video: $e')),
        );
      }
    }
  }

  String _getVideoContentType(String? extension) {
    if (extension == null) return 'video/mp4';
    final ext = extension.toLowerCase();
    switch (ext) {
      case 'mp4':
        return 'video/mp4';
      case 'mov':
        return 'video/quicktime';
      case 'avi':
        return 'video/x-msvideo';
      case 'webm':
        return 'video/webm';
      default:
        return 'video/mp4';
    }
  }

  String _formatFileSize(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    if (bytes < 1024 * 1024 * 1024) {
      return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
    }
    return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(2)} GB';
  }

  /// Builds the video upload section for a module
  Widget _buildVideoUploadSection(int index, Map<String, dynamic> module) {
    final isUploading = _moduleUploading[index] == true;
    final progress = _moduleUploadProgress[index] ?? 0;
    final selectedFile = _moduleVideoFiles[index];
    final currentVideoUrl = module['videoUrl'] as String?;
    final hasVideo = currentVideoUrl != null && currentVideoUrl.isNotEmpty;

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: const Color(0xFFF1F5F9),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (isUploading) ...[
            // Uploading state
            Row(
              children: [
                const Icon(Icons.cloud_upload, color: _accentBlue, size: 20),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    'Uploading ${selectedFile?.name ?? "video"}...',
                    style: const TextStyle(
                      color: _titleColor,
                      fontSize: 13,
                      fontWeight: FontWeight.w500,
                    ),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                Text(
                  '${(progress * 100).toStringAsFixed(0)}%',
                  style: const TextStyle(
                    color: _accentBlue,
                    fontSize: 13,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),
            ClipRRect(
              borderRadius: BorderRadius.circular(4),
              child: LinearProgressIndicator(
                value: progress,
                backgroundColor: const Color(0xFFE2E8F0),
                valueColor: const AlwaysStoppedAnimation<Color>(_accentBlue),
                minHeight: 6,
              ),
            ),
          ] else if (hasVideo) ...[
            // Has existing video
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: const Color(0xFFDCFCE7),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: const Icon(Icons.videocam, color: Color(0xFF22C55E), size: 18),
                ),
                const SizedBox(width: 10),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Video uploaded',
                        style: TextStyle(
                          color: Color(0xFF22C55E),
                          fontSize: 12,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      Text(
                        _extractFilename(currentVideoUrl),
                        style: const TextStyle(
                          color: _mutedColor,
                          fontSize: 11,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ),
                ),
                TextButton.icon(
                  onPressed: () => _pickVideoForModule(index),
                  icon: const Icon(Icons.refresh, size: 16),
                  label: const Text('Replace'),
                  style: TextButton.styleFrom(
                    foregroundColor: _accentBlue,
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                  ),
                ),
              ],
            ),
          ] else ...[
            // No video - show upload button
            InkWell(
              onTap: () => _pickVideoForModule(index),
              borderRadius: BorderRadius.circular(8),
              child: Container(
                padding: const EdgeInsets.symmetric(vertical: 16),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Container(
                      padding: const EdgeInsets.all(8),
                      decoration: BoxDecoration(
                        color: const Color(0xFFDBEAFE),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: const Icon(Icons.add, color: _accentBlue, size: 20),
                    ),
                    const SizedBox(width: 12),
                    const Text(
                      'Upload Video',
                      style: TextStyle(
                        color: _accentBlue,
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  String _extractFilename(String url) {
    try {
      final uri = Uri.parse(url);
      final pathSegments = uri.pathSegments;
      if (pathSegments.isNotEmpty) {
        final filename = pathSegments.last;
        // Decode URL encoding and extract just the file name
        final decoded = Uri.decodeComponent(filename);
        // Remove timestamp prefix if present (e.g., "1234567890_video.mp4" -> "video.mp4")
        final parts = decoded.split('_');
        if (parts.length > 1 && int.tryParse(parts.first) != null) {
          return parts.sublist(1).join('_');
        }
        return decoded;
      }
    } catch (e) {
      debugPrint('Error extracting filename: $e');
    }
    return 'video';
  }

  @override
  void dispose() {
    _courseNameController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  InputDecoration _inputDecoration(String hint) {
    return InputDecoration(
      hintText: hint,
      hintStyle: const TextStyle(color: _mutedColor, fontSize: 14),
      contentPadding: const EdgeInsets.symmetric(horizontal: 18, vertical: 16),
      filled: true,
      fillColor: const Color(0xFFF8FAFC),
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(14),
        borderSide: const BorderSide(color: Color(0xFFE2E8F0)),
      ),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(14),
        borderSide: const BorderSide(color: Color(0xFFE2E8F0)),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(14),
        borderSide: const BorderSide(color: _accentBlue, width: 2),
      ),
    );
  }

  Widget _buildLabeledField({
    required String label,
    required Widget child,
    String? helperText,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: const TextStyle(
            color: _titleColor,
            fontSize: 14,
            fontWeight: FontWeight.w600,
          ),
        ),
        const SizedBox(height: 8),
        child,
        if (helperText != null) ...[
          const SizedBox(height: 6),
          Text(
            helperText,
            style: const TextStyle(color: _mutedColor, fontSize: 12),
          ),
        ],
      ],
    );
  }

  Future<void> _saveChanges() async {
    if (_courseNameController.text.trim().isEmpty) {
      setState(() {
        _errorMessage = 'Course name is required';
      });
      return;
    }

    setState(() {
      _isSaving = true;
      _errorMessage = null;
    });

    try {
      final updateData = <String, dynamic>{
        'course_name': _courseNameController.text.trim(),
        'title': _courseNameController.text.trim(),
        'description': _descriptionController.text.trim(),
        'topic': _selectedTopic,
        'modules': _modules,
        'updated_at': FieldValue.serverTimestamp(),
      };

      await FirebaseFirestore.instance
          .collection('video')
          .doc(widget.course.id)
          .update(updateData);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Course updated successfully!'),
            backgroundColor: Color(0xFF10B981),
          ),
        );
        widget.onSubmit();
      }
    } catch (e) {
      debugPrint('Error saving course: $e');
      setState(() {
        _errorMessage = 'Failed to save changes. Please try again.';
        _isSaving = false;
      });
    }
  }

  void _addModule() {
    setState(() {
      _modules.add({
        'title': 'New Module ${_modules.length + 1}',
        'description': '',
        'videoUrl': '',
        'duration': '',
      });
    });
  }

  void _removeModule(int index) {
    setState(() {
      _modules.removeAt(index);
    });
  }

  void _updateModule(int index, String field, String value) {
    setState(() {
      _modules[index][field] = value;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: Container(
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(24),
          boxShadow: const [
            BoxShadow(
              color: Color(0x1A000000),
              blurRadius: 40,
              offset: Offset(0, 20),
            ),
          ],
        ),
        child: Column(
          children: [
            // Header
            Container(
              padding: const EdgeInsets.all(24),
              decoration: const BoxDecoration(
                gradient: LinearGradient(
                  colors: [Color(0xFFE6EEFF), Color(0xFFD8F8F5)],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                ),
                borderRadius: BorderRadius.only(
                  topLeft: Radius.circular(24),
                  topRight: Radius.circular(24),
                ),
              ),
              child: Row(
                children: [
                  Container(
                    width: 48,
                    height: 48,
                    decoration: BoxDecoration(
                      color: Colors.white,
                      shape: BoxShape.circle,
                      boxShadow: const [
                        BoxShadow(
                          color: Color(0x1A000000),
                          blurRadius: 12,
                          offset: Offset(0, 6),
                        ),
                      ],
                    ),
                    alignment: Alignment.center,
                    child: const Icon(Icons.edit_outlined,
                        color: _accentBlue, size: 24),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text(
                          'Edit Course',
                          style: TextStyle(
                            color: _titleColor,
                            fontSize: 20,
                            fontWeight: FontWeight.w800,
                          ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          'Update course details and manage video modules',
                          style: TextStyle(
                            color: _titleColor.withOpacity(0.7),
                            fontSize: 14,
                          ),
                        ),
                      ],
                    ),
                  ),
                  IconButton(
                    onPressed: widget.onCancel,
                    icon: const Icon(Icons.close, color: _mutedColor),
                  ),
                ],
              ),
            ),
            // Content
            Expanded(
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(24),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    if (_errorMessage != null)
                      Container(
                        padding: const EdgeInsets.all(12),
                        margin: const EdgeInsets.only(bottom: 16),
                        decoration: BoxDecoration(
                          color: const Color(0xFFFEE2E2),
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Row(
                          children: [
                            const Icon(Icons.error_outline,
                                color: Color(0xFFEF4444), size: 20),
                            const SizedBox(width: 8),
                            Expanded(
                              child: Text(
                                _errorMessage!,
                                style: const TextStyle(
                                    color: Color(0xFFEF4444), fontSize: 14),
                              ),
                            ),
                          ],
                        ),
                      ),
                    // Course details section
                    _buildLabeledField(
                      label: 'Course Name',
                      child: TextField(
                        controller: _courseNameController,
                        decoration: _inputDecoration('Enter course name'),
                      ),
                    ),
                    const SizedBox(height: 20),
                    _buildLabeledField(
                      label: 'Topic',
                      child: DropdownButtonFormField<String>(
                        value: _selectedTopic,
                        items: const [
                          DropdownMenuItem(value: 'THINK', child: Text('THINK')),
                          DropdownMenuItem(value: 'KEEP', child: Text('KEEP')),
                          DropdownMenuItem(value: 'ACCELERATE', child: Text('ACCELERATE')),
                          DropdownMenuItem(value: 'TRANSFORM', child: Text('TRANSFORM')),
                          DropdownMenuItem(value: 'ABUNDANCE', child: Text('ABUNDANCE')),
                          DropdownMenuItem(value: 'Expert Series', child: Text('Expert Series')),
                          DropdownMenuItem(value: 'Immersive Footage', child: Text('Immersive Footage')),
                        ],
                        decoration: _inputDecoration('Select topic'),
                        onChanged: (value) {
                          setState(() {
                            _selectedTopic = value;
                          });
                        },
                      ),
                    ),
                    const SizedBox(height: 20),
                    _buildLabeledField(
                      label: 'Description',
                      child: TextField(
                        controller: _descriptionController,
                        decoration: _inputDecoration('Enter course description'),
                        maxLines: 3,
                      ),
                    ),
                    const SizedBox(height: 32),
                    // Modules section
                    Row(
                      children: [
                        const Text(
                          'Video Modules',
                          style: TextStyle(
                            color: _titleColor,
                            fontSize: 16,
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                        const Spacer(),
                        TextButton.icon(
                          onPressed: _addModule,
                          icon: const Icon(Icons.add, size: 18),
                          label: const Text('Add Module'),
                          style: TextButton.styleFrom(
                            foregroundColor: _accentBlue,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    if (_isLoadingModules)
                      Container(
                        padding: const EdgeInsets.all(32),
                        decoration: BoxDecoration(
                          color: const Color(0xFFF8FAFC),
                          borderRadius: BorderRadius.circular(16),
                          border: Border.all(color: const Color(0xFFE2E8F0)),
                        ),
                        child: Center(
                          child: Column(
                            children: const [
                              SizedBox(
                                width: 32,
                                height: 32,
                                child: CircularProgressIndicator(strokeWidth: 2),
                              ),
                              SizedBox(height: 12),
                              Text(
                                'Loading video modules...',
                                style: TextStyle(
                                  color: _mutedColor,
                                  fontSize: 14,
                                ),
                              ),
                            ],
                          ),
                        ),
                      )
                    else if (_modules.isEmpty)
                      Container(
                        padding: const EdgeInsets.all(32),
                        decoration: BoxDecoration(
                          color: const Color(0xFFF8FAFC),
                          borderRadius: BorderRadius.circular(16),
                          border: Border.all(color: const Color(0xFFE2E8F0)),
                        ),
                        child: Center(
                          child: Column(
                            children: [
                              const Icon(Icons.video_library_outlined,
                                  size: 48, color: _mutedColor),
                              const SizedBox(height: 12),
                              const Text(
                                'No modules yet',
                                style: TextStyle(
                                  color: _mutedColor,
                                  fontSize: 14,
                                ),
                              ),
                              const SizedBox(height: 8),
                              TextButton(
                                onPressed: _addModule,
                                child: const Text('Add your first module'),
                              ),
                            ],
                          ),
                        ),
                      )
                    else
                      ...List.generate(_modules.length, (index) {
                        final module = _modules[index];
                        return Container(
                          margin: const EdgeInsets.only(bottom: 12),
                          padding: const EdgeInsets.all(16),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF8FAFC),
                            borderRadius: BorderRadius.circular(16),
                            border: Border.all(color: const Color(0xFFE2E8F0)),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  Container(
                                    width: 32,
                                    height: 32,
                                    decoration: BoxDecoration(
                                      color: _accentBlue.withOpacity(0.1),
                                      borderRadius: BorderRadius.circular(8),
                                    ),
                                    alignment: Alignment.center,
                                    child: Text(
                                      '${index + 1}',
                                      style: const TextStyle(
                                        color: _accentBlue,
                                        fontWeight: FontWeight.w700,
                                      ),
                                    ),
                                  ),
                                  const SizedBox(width: 12),
                                  Expanded(
                                    child: TextField(
                                      controller: TextEditingController(
                                          text: module['title'] ?? ''),
                                      decoration: _inputDecoration('Module title'),
                                      onChanged: (value) =>
                                          _updateModule(index, 'title', value),
                                    ),
                                  ),
                                  const SizedBox(width: 8),
                                  IconButton(
                                    onPressed: () => _removeModule(index),
                                    icon: const Icon(Icons.delete_outline,
                                        color: Color(0xFFEF4444)),
                                    tooltip: 'Remove module',
                                  ),
                                ],
                              ),
                              const SizedBox(height: 12),
                              // Video upload section instead of URL field
                              _buildVideoUploadSection(index, module),
                              const SizedBox(height: 12),
                              TextField(
                                controller: TextEditingController(
                                    text: module['description'] ?? ''),
                                decoration: _inputDecoration('Module description'),
                                maxLines: 2,
                                onChanged: (value) =>
                                    _updateModule(index, 'description', value),
                              ),
                            ],
                          ),
                        );
                      }),
                  ],
                ),
              ),
            ),
            // Footer
            Container(
              padding: const EdgeInsets.all(20),
              decoration: const BoxDecoration(
                border: Border(
                  top: BorderSide(color: Color(0xFFE2E8F0)),
                ),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: widget.onCancel,
                    style: TextButton.styleFrom(
                      foregroundColor: _mutedColor,
                      padding: const EdgeInsets.symmetric(
                          horizontal: 24, vertical: 14),
                    ),
                    child: const Text('Cancel'),
                  ),
                  const SizedBox(width: 12),
                  ElevatedButton(
                    onPressed: _isSaving ? null : _saveChanges,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: _accentBlue,
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(
                          horizontal: 28, vertical: 14),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      elevation: 0,
                    ),
                    child: _isSaving
                        ? const SizedBox(
                            width: 20,
                            height: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              valueColor:
                                  AlwaysStoppedAnimation<Color>(Colors.white),
                            ),
                          )
                        : const Text(
                            'Save Changes',
                            style: TextStyle(fontWeight: FontWeight.w600),
                          ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _AdminAgencyCardData {
  const _AdminAgencyCardData({
    this.id,
    required this.name,
    required this.location,
    required this.members,
    this.logoAsset,
    this.logoUrl,
  });

  final String? id;
  final String name;
  final String location;
  final int members;
  final String? logoAsset;
  final String? logoUrl;

  _AdminAgencyCardData copyWith({
    String? id,
    String? name,
    String? location,
    int? members,
    String? logoAsset,
    String? logoUrl,
  }) {
    return _AdminAgencyCardData(
      id: id ?? this.id,
      name: name ?? this.name,
      location: location ?? this.location,
      members: members ?? this.members,
      logoAsset: logoAsset ?? this.logoAsset,
      logoUrl: logoUrl ?? this.logoUrl,
    );
  }

  factory _AdminAgencyCardData.fromFirestore(
      DocumentSnapshot<Map<String, dynamic>> doc) {
    final data = doc.data() ?? {};

    // Get agency name from 'agency_name' field
    final agencyName =
        data['agency_name'] as String? ?? data['name'] as String? ?? '';

    // Get member count - members is stored as an array of DocumentReferences
    int memberCount = 0;
    final membersField = data['members'];
    if (membersField is List) {
      memberCount = membersField.length;
    } else if (membersField is int) {
      memberCount = membersField;
    }

    return _AdminAgencyCardData(
      id: doc.id,
      name: agencyName,
      location: data['location'] as String? ?? '',
      members: memberCount,
      logoAsset: data['logoAsset'] as String?,
      logoUrl: data['profile_image'] as String? ?? data['logoUrl'] as String?,
    );
  }
}

class _AgencyDetailSnapshot {
  const _AgencyDetailSnapshot({
    required this.summary,
    required this.startDate,
    required this.endDate,
    required this.programUtilization,
    required this.memberEngagement,
    required this.goalCompletion,
    required this.totalMembers,
    required this.activeMembers,
    required this.pendingInvites,
    required this.healthStatus,
  });

  final String summary;
  final String startDate;
  final String endDate;
  final double programUtilization;
  final double memberEngagement;
  final double goalCompletion;
  final int totalMembers;
  final int activeMembers;
  final int pendingInvites;
  final String healthStatus;

  int get inactiveMembers => math.max(totalMembers - activeMembers, 0);
  double get utilizationPercent {
    final double bounded = programUtilization.clamp(0.0, 1.0);
    return (bounded * 100).clamp(0.0, 100.0);
  }

  double get engagementPercent {
    final double bounded = memberEngagement.clamp(0.0, 1.0);
    return (bounded * 100).clamp(0.0, 100.0);
  }

  double get goalCompletionPercent {
    final double bounded = goalCompletion.clamp(0.0, 1.0);
    return (bounded * 100).clamp(0.0, 100.0);
  }
}

class _AgencyDetailDialog extends StatelessWidget {
  const _AgencyDetailDialog({
    required this.agency,
    required this.snapshot,
    required this.onClose,
    required this.onManageMembers,
    required this.onDelete,
  });

  static const Color _titleColor = Color(0xFF0F172A);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _accentBlue = Color(0xFF2563EB);
  static const Color _accentIndigo = Color(0xFF1D4ED8);

  final _AdminAgencyCardData agency;
  final _AgencyDetailSnapshot snapshot;
  final VoidCallback onClose;
  final VoidCallback onManageMembers;
  final VoidCallback onDelete;

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: 960),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(32),
          child: Container(
            decoration: const BoxDecoration(
              color: Colors.white,
              boxShadow: [
                BoxShadow(
                    color: Color(0x33000000),
                    blurRadius: 30,
                    offset: Offset(0, 20)),
              ],
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                _buildHeader(context),
                Padding(
                  padding: const EdgeInsets.fromLTRB(32, 24, 32, 0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      _buildSummaryCard(),
                      const SizedBox(height: 28),
                      _buildMetricGrid(),
                      const SizedBox(height: 28),
                      _buildSnapshotDetails(),
                    ],
                  ),
                ),
                const SizedBox(height: 12),
                const Divider(height: 1, color: Color(0xFFE2E8F0)),
                Padding(
                  padding: const EdgeInsets.fromLTRB(32, 18, 32, 28),
                  child: Row(
                    children: [
                      TextButton.icon(
                        onPressed: onDelete,
                        icon: const Icon(Icons.delete_outline),
                        style: TextButton.styleFrom(
                          foregroundColor: const Color(0xFFB91C1C),
                        ),
                        label: const Text('Delete agency'),
                      ),
                      const Spacer(),
                      OutlinedButton.icon(
                        onPressed: onManageMembers,
                        icon: const Icon(Icons.people_alt_outlined),
                        style: OutlinedButton.styleFrom(
                          foregroundColor: _accentBlue,
                          side: const BorderSide(color: _accentBlue),
                          padding: const EdgeInsets.symmetric(
                              horizontal: 22, vertical: 14),
                          textStyle: const TextStyle(
                              fontSize: 14, fontWeight: FontWeight.w600),
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(16)),
                        ),
                        label: const Text('Manage members'),
                      ),
                      const SizedBox(width: 12),
                      ElevatedButton(
                        onPressed: onClose,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: _accentBlue,
                          foregroundColor: Colors.white,
                          elevation: 0,
                          padding: const EdgeInsets.symmetric(
                              horizontal: 26, vertical: 16),
                          textStyle: const TextStyle(
                              fontSize: 15, fontWeight: FontWeight.w700),
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(16)),
                        ),
                        child: const Text('Close'),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildHeader(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        gradient: LinearGradient(
          colors: [_accentIndigo, _accentBlue],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
      ),
      padding: const EdgeInsets.fromLTRB(32, 32, 24, 28),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: 68,
            height: 68,
            decoration: BoxDecoration(
              color: Colors.white,
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(
                    color: Colors.black.withOpacity(0.15),
                    blurRadius: 16,
                    offset: const Offset(0, 8)),
              ],
            ),
            child: ClipOval(child: _buildAvatar()),
          ),
          const SizedBox(width: 20),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  agency.name,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 24,
                    fontWeight: FontWeight.w800,
                    height: 1.3,
                  ),
                ),
                const SizedBox(height: 8),
                Row(
                  children: [
                    const Icon(Icons.location_on_outlined,
                        color: Colors.white70, size: 18),
                    const SizedBox(width: 6),
                    Expanded(
                      child: Text(
                        agency.location,
                        style: const TextStyle(
                            color: Colors.white70,
                            fontSize: 14,
                            fontWeight: FontWeight.w600),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 12, vertical: 6),
                      decoration: BoxDecoration(
                        color: Colors.white.withOpacity(0.18),
                        borderRadius: BorderRadius.circular(999),
                      ),
                      child: Text(
                        '${snapshot.totalMembers} member${snapshot.totalMembers == 1 ? '' : 's'}',
                        style: const TextStyle(
                            color: Colors.white,
                            fontSize: 12,
                            fontWeight: FontWeight.w700),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
          IconButton(
            onPressed: onClose,
            tooltip: 'Close',
            icon: const Icon(Icons.close, color: Colors.white),
          ),
        ],
      ),
    );
  }

  Widget _buildSummaryCard() {
    return Container(
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: const Color(0xFFF5F7FF),
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: const Color(0xFFE0E7FF)),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: 42,
            height: 42,
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(14),
              boxShadow: const [
                BoxShadow(
                    color: Color(0x14000000),
                    blurRadius: 12,
                    offset: Offset(0, 8)),
              ],
            ),
            child: const Icon(Icons.insights_outlined, color: _accentBlue),
          ),
          const SizedBox(width: 18),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Agency summary',
                  style: TextStyle(
                      color: _titleColor,
                      fontSize: 16,
                      fontWeight: FontWeight.w700),
                ),
                const SizedBox(height: 8),
                Text(
                  snapshot.summary,
                  style: const TextStyle(
                      color: _mutedColor,
                      fontSize: 14,
                      height: 1.5,
                      fontWeight: FontWeight.w500),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMetricGrid() {
    final List<_MetricData> metrics = [
      _MetricData(
        title: 'Program utilization',
        percent: snapshot.utilizationPercent,
        caption: 'Active participation in curriculum',
        color: const Color(0xFF2DD4BF),
      ),
      _MetricData(
        title: 'Member engagement',
        percent: snapshot.engagementPercent,
        caption: 'Learners interacting weekly',
        color: const Color(0xFF60A5FA),
      ),
      _MetricData(
        title: 'Goal completion',
        percent: snapshot.goalCompletionPercent,
        caption: 'Milestones reached to date',
        color: const Color(0xFFFBBF24),
      ),
    ];

    return LayoutBuilder(
      builder: (context, constraints) {
        final bool stack = constraints.maxWidth < 840;

        if (stack) {
          return Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: metrics
                .map((metric) => Padding(
                      padding: EdgeInsets.only(
                          bottom: metric == metrics.last ? 0 : 18),
                      child: _MetricCard(data: metric),
                    ))
                .toList(growable: false),
          );
        }

        return Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            for (int i = 0; i < metrics.length; i++)
              Flexible(
                child: Padding(
                  padding:
                      EdgeInsets.only(right: i == metrics.length - 1 ? 0 : 18),
                  child: _MetricCard(data: metrics[i]),
                ),
              ),
          ],
        );
      },
    );
  }

  Widget _buildSnapshotDetails() {
    final List<_SnapshotFact> facts = [
      _SnapshotFact(
          label: 'Partnership start',
          value: snapshot.startDate,
          icon: Icons.calendar_today_outlined),
      _SnapshotFact(
          label: 'Engagement thru',
          value: snapshot.endDate,
          icon: Icons.schedule_outlined),
      _SnapshotFact(
          label: 'Active members',
          value: '${snapshot.activeMembers}',
          icon: Icons.verified_outlined),
      _SnapshotFact(
          label: 'Inactive members',
          value: '${snapshot.inactiveMembers}',
          icon: Icons.hourglass_empty_outlined),
      _SnapshotFact(
          label: 'Pending invites',
          value: '${snapshot.pendingInvites}',
          icon: Icons.mark_email_unread_outlined),
      _SnapshotFact(
          label: 'Health status',
          value: snapshot.healthStatus,
          icon: Icons.health_and_safety_outlined),
    ];

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Roster insights',
          style: TextStyle(
              color: _titleColor, fontSize: 16, fontWeight: FontWeight.w700),
        ),
        const SizedBox(height: 16),
        LayoutBuilder(
          builder: (context, constraints) {
            final int columns = constraints.maxWidth < 640
                ? 1
                : constraints.maxWidth < 960
                    ? 2
                    : 3;
            final double itemWidth = columns <= 1
                ? constraints.maxWidth
                : (constraints.maxWidth - (columns - 1) * 18) / columns;
            return Wrap(
              spacing: 18,
              runSpacing: 18,
              children: facts
                  .map((fact) => SizedBox(
                        width: itemWidth,
                        child: _SnapshotFactTile(fact: fact),
                      ))
                  .toList(growable: false),
            );
          },
        ),
      ],
    );
  }

  Widget _buildAvatar() {
    Widget buildInitials() {
      final initials = _resolveInitials(agency.name);
      return Container(
        color: Colors.white,
        alignment: Alignment.center,
        child: Text(
          initials,
          style: const TextStyle(
              color: _accentBlue, fontSize: 20, fontWeight: FontWeight.w700),
        ),
      );
    }

    if (agency.logoUrl != null && agency.logoUrl!.isNotEmpty) {
      return Image.network(
        agency.logoUrl!,
        fit: BoxFit.cover,
        errorBuilder: (_, __, ___) => buildInitials(),
      );
    }
    if (agency.logoAsset != null && agency.logoAsset!.isNotEmpty) {
      return Image.asset(
        agency.logoAsset!,
        fit: BoxFit.cover,
      );
    }
    return buildInitials();
  }

  String _resolveInitials(String value) {
    final parts = value
        .split(RegExp(r'\s+'))
        .where((part) => part.isNotEmpty)
        .toList(growable: false);
    if (parts.isEmpty) {
      return 'BA';
    }
    if (parts.length == 1) {
      return parts.first.substring(0, 1).toUpperCase();
    }
    return (parts[0][0] + parts[1][0]).toUpperCase();
  }
}

class _MetricData {
  const _MetricData({
    required this.title,
    required this.percent,
    required this.caption,
    required this.color,
  });

  final String title;
  final double percent;
  final String caption;
  final Color color;
}

class _MetricCard extends StatelessWidget {
  const _MetricCard({required this.data});

  final _MetricData data;

  @override
  Widget build(BuildContext context) {
    final double progress = (data.percent / 100).clamp(0.0, 1.0);
    return Container(
      padding: const EdgeInsets.all(22),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(22),
        border: Border.all(color: const Color(0xFFE5EAF5)),
        boxShadow: const [
          BoxShadow(
              color: Color(0x110F172A), blurRadius: 20, offset: Offset(0, 14)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: 42,
            height: 42,
            decoration: BoxDecoration(
              color: data.color.withOpacity(0.1),
              borderRadius: BorderRadius.circular(14),
            ),
            alignment: Alignment.center,
            child: Text(
              '${data.percent.toStringAsFixed(0)}%',
              style: TextStyle(
                  color: data.color, fontSize: 14, fontWeight: FontWeight.w700),
            ),
          ),
          const SizedBox(height: 16),
          Text(
            data.title,
            style: const TextStyle(
                color: _AgencyDetailDialog._titleColor,
                fontSize: 15,
                fontWeight: FontWeight.w700),
          ),
          const SizedBox(height: 6),
          Text(
            data.caption,
            style: const TextStyle(
                color: _AgencyDetailDialog._mutedColor,
                fontSize: 13,
                fontWeight: FontWeight.w500),
          ),
          const SizedBox(height: 18),
          ClipRRect(
            borderRadius: BorderRadius.circular(999),
            child: LinearProgressIndicator(
              value: progress,
              minHeight: 8,
              backgroundColor: data.color.withOpacity(0.14),
              valueColor: AlwaysStoppedAnimation<Color>(data.color),
            ),
          ),
        ],
      ),
    );
  }
}

class _SnapshotFact {
  const _SnapshotFact(
      {required this.label, required this.value, required this.icon});

  final String label;
  final String value;
  final IconData icon;
}

class _SnapshotFactTile extends StatelessWidget {
  const _SnapshotFactTile({required this.fact});

  final _SnapshotFact fact;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(18),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: const Color(0xFFE5E7EB)),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: 36,
            height: 36,
            decoration: BoxDecoration(
              color: const Color(0xFFF1F5FF),
              borderRadius: BorderRadius.circular(12),
            ),
            alignment: Alignment.center,
            child: Icon(fact.icon,
                size: 18, color: _AgencyDetailDialog._accentBlue),
          ),
          const SizedBox(width: 14),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  fact.label,
                  style: const TextStyle(
                      color: _AgencyDetailDialog._mutedColor,
                      fontSize: 12,
                      fontWeight: FontWeight.w600),
                ),
                const SizedBox(height: 4),
                Text(
                  fact.value,
                  style: const TextStyle(
                      color: _AgencyDetailDialog._titleColor,
                      fontSize: 15,
                      fontWeight: FontWeight.w700),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _AgencyMembersDialog extends StatelessWidget {
  const _AgencyMembersDialog({
    required this.agencyName,
    required this.allMembers,
    required this.onClose,
  });

  final String agencyName;
  final List<_AdminMemberRowData> allMembers;
  final VoidCallback onClose;

  static const Color _titleColor = Color(0xFF0F172A);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _accentBlue = Color(0xFF2563EB);
  static const Color _accentIndigo = Color(0xFF1D4ED8);

  @override
  Widget build(BuildContext context) {
    final List<_AdminMemberRowData> members = allMembers
        .where((m) =>
            m.agency.trim().toLowerCase() == agencyName.trim().toLowerCase())
        .toList(growable: false);

    return Material(
      color: Colors.transparent,
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: 920),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(28),
          child: Container(
            decoration: const BoxDecoration(
              color: Colors.white,
              boxShadow: [
                BoxShadow(
                    color: Color(0x33000000),
                    blurRadius: 30,
                    offset: Offset(0, 20)),
              ],
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                _buildHeader(context, members.length),
                Padding(
                  padding: const EdgeInsets.fromLTRB(24, 20, 24, 8),
                  child: members.isEmpty
                      ? _buildEmptyState()
                      : _buildMembersList(context, members),
                ),
                const SizedBox(height: 8),
                const Divider(height: 1, color: Color(0xFFE2E8F0)),
                Padding(
                  padding: const EdgeInsets.fromLTRB(24, 16, 24, 24),
                  child: Row(
                    children: [
                      TextButton.icon(
                        onPressed: onClose,
                        icon: const Icon(Icons.close),
                        style:
                            TextButton.styleFrom(foregroundColor: _accentBlue),
                        label: const Text('Close'),
                      ),
                      const Spacer(),
                      ElevatedButton.icon(
                        onPressed: onClose,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: _accentBlue,
                          foregroundColor: Colors.white,
                          elevation: 0,
                          padding: const EdgeInsets.symmetric(
                              horizontal: 22, vertical: 14),
                          textStyle: const TextStyle(
                              fontSize: 14, fontWeight: FontWeight.w700),
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(16)),
                        ),
                        icon: const Icon(Icons.check_circle_outline),
                        label: const Text('Done'),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildHeader(BuildContext context, int count) {
    final String membersLabel = count == 1 ? 'member' : 'members';
    return Container(
      decoration: const BoxDecoration(
        gradient: LinearGradient(
          colors: [_accentIndigo, _accentBlue],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
      ),
      padding: const EdgeInsets.fromLTRB(24, 24, 8, 22),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(10),
            decoration: BoxDecoration(
              color: Colors.white.withValues(alpha: 0.18),
              borderRadius: BorderRadius.circular(16),
            ),
            child: const Icon(Icons.people_alt_outlined, color: Colors.white),
          ),
          const SizedBox(width: 14),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  agencyName,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 20,
                    fontWeight: FontWeight.w800,
                    height: 1.3,
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 6),
                Text(
                  '$count $membersLabel',
                  style: const TextStyle(
                      color: Colors.white70,
                      fontSize: 13,
                      fontWeight: FontWeight.w600),
                ),
              ],
            ),
          ),
          IconButton(
            onPressed: onClose,
            tooltip: 'Close',
            icon: const Icon(Icons.close, color: Colors.white),
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState() {
    return Container(
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: const Color(0xFFF5F7FF),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: const Color(0xFFE0E7FF)),
      ),
      child: Row(
        children: const [
          Icon(Icons.person_off_outlined, color: _accentBlue),
          SizedBox(width: 12),
          Expanded(
            child: Text(
              'No members found for this agency yet.',
              style: TextStyle(
                  color: _mutedColor,
                  fontSize: 14,
                  fontWeight: FontWeight.w600),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMembersList(
      BuildContext context, List<_AdminMemberRowData> members) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        for (int i = 0; i < members.length; i++)
          Padding(
            padding: EdgeInsets.only(bottom: i == members.length - 1 ? 0 : 14),
            child: _MemberTile(data: members[i]),
          ),
      ],
    );
  }
}

class _MemberTile extends StatelessWidget {
  const _MemberTile({required this.data});

  final _AdminMemberRowData data;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: const Color(0xFFE5E7EB)),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          _buildAvatar(),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        data.name,
                        style: const TextStyle(
                          color: _AgencyMembersDialog._titleColor,
                          fontSize: 15,
                          fontWeight: FontWeight.w700,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    const SizedBox(width: 8),
                    _RolePill(role: data.role),
                  ],
                ),
                const SizedBox(height: 6),
                Row(
                  children: [
                    Icon(
                      data.coach.isNotEmpty
                          ? Icons.verified_outlined
                          : Icons.person_search_outlined,
                      size: 16,
                      color: data.coach.isNotEmpty
                          ? const Color(0xFF059669)
                          : const Color(0xFF6B7280),
                    ),
                    const SizedBox(width: 6),
                    Expanded(
                      child: Text(
                        data.coach.isNotEmpty
                            ? 'Coach: ${data.coach}'
                            : 'Unassigned coach',
                        style: TextStyle(
                          color: data.coach.isNotEmpty
                              ? const Color(0xFF059669)
                              : const Color(0xFF6B7280),
                          fontSize: 12,
                          fontWeight: FontWeight.w600,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
          const SizedBox(width: 12),
          _ProgressPill(progress: data.progress),
        ],
      ),
    );
  }

  Widget _buildAvatar() {
    final String initials = _initials(data.name);
    return Container(
      width: 42,
      height: 42,
      decoration: BoxDecoration(
        color: const Color(0xFFEEF2FF),
        borderRadius: BorderRadius.circular(12),
      ),
      alignment: Alignment.center,
      child: Text(
        initials,
        style: const TextStyle(
            color: _AgencyMembersDialog._accentBlue,
            fontSize: 14,
            fontWeight: FontWeight.w800),
      ),
    );
  }

  String _initials(String value) {
    final parts = value
        .split(RegExp(r"\s+"))
        .where((p) => p.isNotEmpty)
        .toList(growable: false);
    if (parts.isEmpty) return 'BA';
    if (parts.length == 1) return parts.first.substring(0, 1).toUpperCase();
    return (parts[0][0] + parts[1][0]).toUpperCase();
  }
}

class _RolePill extends StatelessWidget {
  const _RolePill({required this.role});

  final String role;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: const Color(0xFFF1F5FF),
        borderRadius: BorderRadius.circular(999),
        border: Border.all(color: const Color(0xFFE0E7FF)),
      ),
      child: Text(
        role,
        style: const TextStyle(
            color: _AgencyMembersDialog._accentBlue,
            fontSize: 11,
            fontWeight: FontWeight.w800),
      ),
    );
  }
}

class _ProgressPill extends StatelessWidget {
  const _ProgressPill({required this.progress});

  final double progress; // 0..1

  @override
  Widget build(BuildContext context) {
    final double bounded = progress.clamp(0.0, 1.0);
    final percentText = '${(bounded * 100).round()}%';
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: const Color(0xFFF3F4F6),
        borderRadius: BorderRadius.circular(999),
        border: Border.all(color: const Color(0xFFE5E7EB)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          SizedBox(
            width: 56,
            child: ClipRRect(
              borderRadius: BorderRadius.circular(999),
              child: LinearProgressIndicator(
                value: bounded,
                minHeight: 6,
                backgroundColor: const Color(0xFFE5E7EB),
                valueColor:
                    const AlwaysStoppedAnimation<Color>(Color(0xFF10B981)),
              ),
            ),
          ),
          const SizedBox(width: 8),
          Text(
            percentText,
            style: const TextStyle(
                color: Color(0xFF111827),
                fontSize: 11,
                fontWeight: FontWeight.w800),
          ),
        ],
      ),
    );
  }
}

class _AgencyFilterOption {
  const _AgencyFilterOption({
    required this.label,
    required this.minMembers,
    this.maxMembers,
  });

  final String label;
  final int minMembers;
  final int? maxMembers;
}

class _AdminAgencyCard extends StatelessWidget {
  const _AdminAgencyCard({
    required this.data,
    required this.onViewDetails,
    required this.onManageMembers,
    required this.accentColor,
  });

  final _AdminAgencyCardData data;
  final VoidCallback onViewDetails;
  final VoidCallback onManageMembers;
  final Color accentColor;

  @override
  Widget build(BuildContext context) {
    Widget buildInitialsAvatar(String initials) {
      return Container(
        alignment: Alignment.center,
        decoration: BoxDecoration(
          color: accentColor.withOpacity(0.12),
          shape: BoxShape.circle,
        ),
        child: Text(
          initials,
          style: TextStyle(
            color: accentColor,
            fontSize: 20,
            fontWeight: FontWeight.w700,
          ),
        ),
      );
    }

    String initials(String value) {
      final parts = value
          .split(RegExp(r'\s+'))
          .where((part) => part.isNotEmpty)
          .toList(growable: false);
      if (parts.isEmpty) {
        return 'BA';
      }
      if (parts.length == 1) {
        return parts.first[0].toUpperCase();
      }
      return (parts[0][0] + parts[1][0]).toUpperCase();
    }

    Widget buildLogo() {
      if (data.logoUrl != null && data.logoUrl!.isNotEmpty) {
        return ClipOval(
          child: Image.network(
            data.logoUrl!,
            width: 60,
            height: 60,
            fit: BoxFit.cover,
            errorBuilder: (_, __, ___) =>
                buildInitialsAvatar(initials(data.name)),
          ),
        );
      }
      if (data.logoAsset != null && data.logoAsset!.isNotEmpty) {
        return ClipOval(
          child: Image.asset(
            data.logoAsset!,
            width: 60,
            height: 60,
            fit: BoxFit.cover,
          ),
        );
      }
      return buildInitialsAvatar(initials(data.name));
    }

    final String membersLabel = data.members == 1 ? 'Member' : 'Members';

    return Container(
      padding: const EdgeInsets.fromLTRB(26, 26, 26, 24),
      decoration: BoxDecoration(
        color: accentColor,
        borderRadius: BorderRadius.circular(28),
        boxShadow: [
          BoxShadow(
            color: accentColor.withValues(alpha: 0.22),
            blurRadius: 30,
            offset: const Offset(0, 20),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                padding: const EdgeInsets.all(4),
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: Colors.white.withValues(alpha: 0.25),
                ),
                child: Container(
                  width: 60,
                  height: 60,
                  decoration: const BoxDecoration(
                    color: Colors.white,
                    shape: BoxShape.circle,
                  ),
                  alignment: Alignment.center,
                  child: buildLogo(),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      data.name,
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 16,
                        fontWeight: FontWeight.w800,
                        height: 1.35,
                      ),
                      softWrap: true,
                      overflow: TextOverflow.visible,
                    ),
                    const SizedBox(height: 6),
                    Row(
                      children: [
                        const Icon(Icons.location_on_outlined,
                            size: 16, color: Colors.white),
                        const SizedBox(width: 6),
                        Expanded(
                          child: Text(
                            data.location,
                            style: const TextStyle(
                              color: Colors.white,
                              fontSize: 13,
                              fontWeight: FontWeight.w600,
                            ),
                            softWrap: true,
                            overflow: TextOverflow.visible,
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 20),
          Container(
            padding: const EdgeInsets.all(18),
            decoration: BoxDecoration(
              color: Colors.white.withValues(alpha: 0.15),
              borderRadius: BorderRadius.circular(20),
            ),
            child: Row(
              children: [
                Container(
                  width: 44,
                  height: 44,
                  decoration: const BoxDecoration(
                    shape: BoxShape.circle,
                    color: Colors.white,
                  ),
                  alignment: Alignment.center,
                  child: Icon(Icons.groups, color: accentColor, size: 22),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        '${data.members} $membersLabel',
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 15,
                          fontWeight: FontWeight.w700,
                        ),
                      ),
                      const SizedBox(height: 4),
                      const Text(
                        'Member roster syncs with coaching assignments in real time.',
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 12,
                          fontWeight: FontWeight.w500,
                        ),
                        softWrap: true,
                        overflow: TextOverflow.visible,
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 18),
          const Text(
            'Quick actions',
            style: TextStyle(
              color: Colors.white,
              fontSize: 12,
              fontWeight: FontWeight.w700,
              letterSpacing: 0.4,
            ),
          ),
          const SizedBox(height: 12),
          Row(
            children: [
              Expanded(
                child: OutlinedButton.icon(
                  style: OutlinedButton.styleFrom(
                    foregroundColor: Colors.white,
                    side: const BorderSide(color: Colors.white),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(16)),
                    padding: const EdgeInsets.symmetric(
                        vertical: 16, horizontal: 18),
                    textStyle: const TextStyle(
                        fontSize: 14, fontWeight: FontWeight.w600),
                  ),
                  onPressed: onViewDetails,
                  icon: const Icon(Icons.visibility_outlined, size: 18),
                  label: const Text('View details'),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: ElevatedButton.icon(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.white,
                    foregroundColor: accentColor,
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(16)),
                    padding: const EdgeInsets.symmetric(
                        vertical: 16, horizontal: 18),
                    textStyle: const TextStyle(
                        fontSize: 14, fontWeight: FontWeight.w700),
                    elevation: 0,
                  ),
                  onPressed: onManageMembers,
                  icon: const Icon(Icons.people_alt_outlined, size: 18),
                  label: const Text('Manage members'),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class CoachDashboardShell extends StatefulWidget {
  const CoachDashboardShell({super.key});

  static const Color background = Color(0xFFF6F7FB);

  @override
  State<CoachDashboardShell> createState() => _CoachDashboardShellState();
}

enum CoachNavigationItem {
  dashboard,
  library,
  profile,
  coachingTools,
  coachingNotes,
  analytics,
  aiCoach,
  messages,
  forums,
  notifications,
  settings,
}

class _CoachDashboardShellState extends State<CoachDashboardShell> {
  CoachNavigationItem _selected = CoachNavigationItem.dashboard;
  int _navigationCounter = 0;

  void _handleSelection(CoachNavigationItem item) {
    // Always trigger setState to reset to root view even if same item
    setState(() {
      _selected = item;
      _navigationCounter++;
    });
  }

  Future<void> _handleLogout() async {
    try {
      await FirebaseAuth.instance.signOut();
    } on FirebaseAuthException catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          SnackBar(
            content: Text(e.message ?? 'Failed to log out.'),
            backgroundColor: const Color(0xFFDC2626),
          ),
        );
      return;
    } catch (_) {
      if (!mounted) return;
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          const SnackBar(
            content: Text('Failed to log out. Please try again.'),
            backgroundColor: Color(0xFFDC2626),
          ),
        );
      return;
    }

    if (!mounted) return;
    Navigator.of(context).pushAndRemoveUntil(
      MaterialPageRoute(builder: (_) => const AuthLandingPage()),
      (route) => false,
    );
  }

  Widget _buildContent() {
    final key = ValueKey('coach_nav_$_navigationCounter');
    switch (_selected) {
      case CoachNavigationItem.dashboard:
        return CoachDashboardView(key: key);
      case CoachNavigationItem.library:
        return ContentLibraryPage(key: key);
      case CoachNavigationItem.profile:
        return _DashboardNavigationProvider(
          onNavigate: _handleSelection,
          child: ProfilePage(key: key),
        );
      case CoachNavigationItem.messages:
        return MessagesPage(key: key);
      case CoachNavigationItem.coachingTools:
        return CoachCoachingToolsPage(key: key);
      case CoachNavigationItem.coachingNotes:
        return CoachCoachingNotesPage(key: key);
      case CoachNavigationItem.analytics:
        return CoachAnalyticsPage(key: key);
      case CoachNavigationItem.aiCoach:
        return AICoachView(
          key: key,
          url:
              'https://app.gpt-trainer.com/widget/e75aedf2ab3541c28943d0094e09547f',
        );
      case CoachNavigationItem.forums:
        return DiscussionForumPage(key: key);
      case CoachNavigationItem.notifications:
        return NotificationsPage(key: key);
      case CoachNavigationItem.settings:
        return CoachPlaceholderPage(key: key, title: 'Settings');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: CoachDashboardShell.background,
      body: Column(
        children: [
          const AnnouncementMarquee(),
          Expanded(
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(
                  width: 252,
                  child: _CoachSideNavigation(
                    selected: _selected,
                    onItemSelected: _handleSelection,
                    onLogout: _handleLogout,
                  ),
                ),
                Expanded(
                  child: Column(
                    children: [
                      _NotificationBar(
                          onNotificationTap: () => _handleSelection(
                              CoachNavigationItem.notifications)),
                      Expanded(child: _buildContent()),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _DashboardNavigationProvider extends InheritedWidget {
  const _DashboardNavigationProvider({
    required this.onNavigate,
    required super.child,
  });

  final ValueChanged<CoachNavigationItem> onNavigate;

  static _DashboardNavigationProvider? of(BuildContext context) => context
      .dependOnInheritedWidgetOfExactType<_DashboardNavigationProvider>();

  @override
  bool updateShouldNotify(_DashboardNavigationProvider oldWidget) =>
      onNavigate != oldWidget.onNavigate;
}

class _CoachSideNavigation extends StatelessWidget {
  const _CoachSideNavigation({
    required this.selected,
    required this.onItemSelected,
    this.onLogout,
  });

  static const Color _sectionColor = Color(0xFF9CA3AF);
  static const Color _itemColor = Color(0xFF1F2937);
  static const Color _activeColor = Color(0xFF2563EB);
  static const Color _activeBackground = Color(0xFFE4ECFF);

  final CoachNavigationItem selected;
  final ValueChanged<CoachNavigationItem> onItemSelected;
  final VoidCallback? onLogout;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
      decoration: const BoxDecoration(
        color: Colors.white,
        border: Border(
          right: BorderSide(color: Color(0xFFE5E7EB)),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            child: SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _brandLockup(),
                  const SizedBox(height: 32),
                  const _CoachSectionLabel('MAIN'),
                  _navItem(
                    item: CoachNavigationItem.dashboard,
                    icon: Icons.dashboard_outlined,
                    label: 'Dashboard',
                  ),
                  _navItem(
                    item: CoachNavigationItem.library,
                    icon: Icons.menu_book_outlined,
                    label: '365 Library',
                  ),
                  _navItem(
                    item: CoachNavigationItem.profile,
                    icon: Icons.person_outline,
                    label: 'My Profile',
                  ),
                  const SizedBox(height: 24),
                  const Divider(color: Color(0xFFE5E7EB)),
                  const SizedBox(height: 24),
                  const _CoachSectionLabel('LEARNING'),
                  _navItem(
                    item: CoachNavigationItem.coachingTools,
                    icon: Icons.text_snippet_outlined,
                    label: 'Coaching Tools',
                  ),
                  _navItem(
                    item: CoachNavigationItem.coachingNotes,
                    icon: Icons.folder_open_outlined,
                    label: 'Coaching Notes',
                  ),
                  _navItem(
                    item: CoachNavigationItem.analytics,
                    icon: Icons.insights_outlined,
                    label: 'Analytics',
                  ),
                  _navItem(
                    item: CoachNavigationItem.aiCoach,
                    icon: Icons.smart_toy_outlined,
                    label: 'AI Coach',
                  ),
                  const SizedBox(height: 24),
                  const Divider(color: Color(0xFFE5E7EB)),
                  const SizedBox(height: 24),
                  const _CoachSectionLabel('COMMUNITY'),
                  _navItem(
                    item: CoachNavigationItem.messages,
                    icon: Icons.mail_outline,
                    label: 'Messages',
                  ),
                  _navItem(
                    item: CoachNavigationItem.forums,
                    icon: Icons.forum_outlined,
                    label: 'Forums',
                  ),
                  const SizedBox(height: 24),
                  const Divider(color: Color(0xFFE5E7EB)),
                  const SizedBox(height: 24),
                  const _CoachSectionLabel('SETTINGS'),
                  _navItem(
                    item: CoachNavigationItem.settings,
                    icon: Icons.settings_outlined,
                    label: 'Settings',
                  ),
                  const SizedBox(height: 24),
                ],
              ),
            ),
          ),
          Container(
            width: 56,
            height: 56,
            decoration: BoxDecoration(
              color: const Color(0xFFF1EEFF),
              borderRadius: BorderRadius.circular(18),
            ),
            child: const Icon(Icons.emoji_events_outlined,
                color: Color(0xFF4C1D95)),
          ),
          const SizedBox(height: 20),
          InkWell(
            borderRadius: BorderRadius.circular(14),
            onTap: onLogout,
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: const [
                  Icon(Icons.logout, color: Color(0xFFDC2626)),
                  SizedBox(width: 10),
                  Text(
                    'Logout',
                    style: TextStyle(
                      color: Color(0xFFDC2626),
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _brandLockup() {
    return SizedBox(
      height: 52,
      child: Image.asset(
        'assets/images/Breakaway365_small_white.png',
        fit: BoxFit.contain,
      ),
    );
  }

  Widget _navItem({
    required CoachNavigationItem item,
    required IconData icon,
    required String label,
  }) {
    final bool isActive = selected == item;
    final Color color = isActive ? _activeColor : _itemColor;

    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: InkWell(
        borderRadius: BorderRadius.circular(12),
        onTap: () => onItemSelected(item),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
          decoration: BoxDecoration(
            color: isActive ? _activeBackground : Colors.transparent,
            borderRadius: BorderRadius.circular(12),
          ),
          child: Row(
            children: [
              Icon(icon, color: color),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  label,
                  style: TextStyle(
                    color: color,
                    fontWeight: isActive ? FontWeight.w700 : FontWeight.w500,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _CoachSectionLabel extends StatelessWidget {
  const _CoachSectionLabel(this.label);

  final String label;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Text(
        label,
        style: const TextStyle(
          color: _CoachSideNavigation._sectionColor,
          fontSize: 12,
          letterSpacing: 1.2,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }
}

class NotificationService {
  static Future<void> createNotification({
    required String recipientId,
    required String type,
    required String title,
    required String message,
    String? actorId,
    String? actorName,
    String? actorImageUrl,
  }) async {
    try {
      await FirebaseFirestore.instance.collection('notifications').add({
        'recipientId': recipientId,
        'type': type,
        'title': title,
        'message': message,
        'actorId': actorId,
        'actorName': actorName,
        'actorImageUrl': actorImageUrl,
        'read': false,
        'createdAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      debugPrint('Failed to create notification: $e');
    }
  }

  static Future<void> notifyCoachOfModuleCompletion({
    required String coachId,
    required String memberName,
    required String moduleName,
  }) async {
    await createNotification(
      recipientId: coachId,
      type: 'module_completed',
      title: 'Module Completed',
      message: '$memberName has completed the "$moduleName" module',
      actorName: memberName,
    );
  }

  static Future<void> notifyProfileUpdate({
    required String userId,
    required String updatedField,
  }) async {
    await createNotification(
      recipientId: userId,
      type: 'profile_updated',
      title: 'Profile Updated',
      message: 'Your $updatedField has been successfully updated',
    );
  }

  static Future<void> notifySessionScheduled({
    required String recipientId,
    required String sessionDate,
    required String sessionTime,
  }) async {
    await createNotification(
      recipientId: recipientId,
      type: 'session_scheduled',
      title: 'Session Scheduled',
      message:
          'Your coaching session has been scheduled for $sessionDate at $sessionTime',
    );
  }

  static Future<void> notifyNewContent({
    required String recipientId,
    required String contentTitle,
    required String contentType,
  }) async {
    await createNotification(
      recipientId: recipientId,
      type: 'new_content',
      title: 'New Content Available',
      message: 'New $contentType "$contentTitle" is now available for you',
    );
  }

  static Future<void> notifyAchievement({
    required String recipientId,
    required String achievementName,
    required String description,
  }) async {
    await createNotification(
      recipientId: recipientId,
      type: 'achievement',
      title: 'Achievement Unlocked!',
      message: '$achievementName - $description',
    );
  }

  static Future<void> notifyScorecardSubmission({
    required String recipientId,
    required String metricName,
  }) async {
    await createNotification(
      recipientId: recipientId,
      type: 'scorecard_submitted',
      title: 'Scorecard Submitted',
      message: 'Your $metricName scorecard has been successfully submitted',
    );
  }

  static Future<void> notifyWelcome({required String recipientId}) async {
    await createNotification(
      recipientId: recipientId,
      type: 'welcome',
      title: 'Welcome to Breakaway365!',
      message:
          'Thank you for joining us. Explore your dashboard to get started on your journey.',
    );
  }

  /// Creates initial welcome notifications for new users
  static Future<void> ensureWelcomeNotifications(String userId) async {
    try {
      final existing = await FirebaseFirestore.instance
          .collection('notifications')
          .where('recipientId', isEqualTo: userId)
          .where('type', isEqualTo: 'welcome')
          .limit(1)
          .get();

      if (existing.docs.isEmpty) {
        await notifyWelcome(recipientId: userId);
      }
    } catch (e) {
      debugPrint('Error checking welcome notifications: $e');
    }
  }
}

class _NotificationBar extends StatelessWidget {
  const _NotificationBar({required this.onNotificationTap});

  final VoidCallback onNotificationTap;

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 64,
      padding: const EdgeInsets.symmetric(horizontal: 32),
      decoration: const BoxDecoration(
        color: Colors.white,
        border: Border(bottom: BorderSide(color: Color(0xFFE5E7EB))),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          StreamBuilder<QuerySnapshot>(
            stream: FirebaseFirestore.instance
                .collection('notifications')
                .where('recipientId',
                    isEqualTo: FirebaseAuth.instance.currentUser?.uid)
                .where('read', isEqualTo: false)
                .snapshots(),
            builder: (context, snapshot) {
              final unreadCount =
                  snapshot.hasData ? snapshot.data!.docs.length : 0;
              return Stack(
                clipBehavior: Clip.none,
                children: [
                  IconButton(
                    icon: const Icon(Icons.notifications_outlined, size: 24),
                    color: const Color(0xFF374151),
                    onPressed: onNotificationTap,
                  ),
                  if (unreadCount > 0)
                    Positioned(
                      right: 8,
                      top: 8,
                      child: Container(
                        padding: const EdgeInsets.all(4),
                        decoration: const BoxDecoration(
                          color: Color(0xFFDC2626),
                          shape: BoxShape.circle,
                        ),
                        constraints:
                            const BoxConstraints(minWidth: 18, minHeight: 18),
                        child: Center(
                          child: Text(
                            unreadCount > 9 ? '9+' : unreadCount.toString(),
                            style: const TextStyle(
                                color: Colors.white,
                                fontSize: 10,
                                fontWeight: FontWeight.w700),
                          ),
                        ),
                      ),
                    ),
                ],
              );
            },
          ),
        ],
      ),
    );
  }
}

class NotificationsPage extends StatefulWidget {
  const NotificationsPage({super.key});

  @override
  State<NotificationsPage> createState() => _NotificationsPageState();
}

class _NotificationsPageState extends State<NotificationsPage> {
  @override
  void initState() {
    super.initState();
    // Ensure user has at least a welcome notification
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser != null) {
      NotificationService.ensureWelcomeNotifications(currentUser.uid);
    }
  }

  @override
  Widget build(BuildContext context) {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      return const Center(child: Text('Please log in to view notifications'));
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        final double horizontalPadding =
            constraints.maxWidth > 1180 ? 60.0 : 32.0;
        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  const Expanded(
                    child: Text(
                      'Notifications',
                      style: TextStyle(
                          color: Color(0xFF111827),
                          fontSize: 24,
                          fontWeight: FontWeight.w700),
                    ),
                  ),
                  TextButton.icon(
                    onPressed: () => _markAllAsRead(currentUser.uid),
                    icon: const Icon(Icons.done_all, size: 18),
                    label: const Text('Mark all as read'),
                    style: TextButton.styleFrom(
                        foregroundColor: const Color(0xFF2563EB)),
                  ),
                ],
              ),
              const SizedBox(height: 24),
              StreamBuilder<QuerySnapshot>(
                stream: FirebaseFirestore.instance
                    .collection('notifications')
                    .where('recipientId', isEqualTo: currentUser.uid)
                    .orderBy('createdAt', descending: true)
                    .limit(50)
                    .snapshots(),
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const Center(child: CircularProgressIndicator());
                  }

                  if (snapshot.hasError) {
                    return Center(child: Text('Error: ${snapshot.error}'));
                  }

                  final notifications = snapshot.data?.docs ?? [];

                  if (notifications.isEmpty) {
                    return _buildEmptyState();
                  }

                  return Column(
                    children: notifications.map((doc) {
                      final data = doc.data() as Map<String, dynamic>;
                      return _NotificationItem(
                        notificationId: doc.id,
                        type: data['type'] as String? ?? 'info',
                        title: data['title'] as String? ?? 'Notification',
                        message: data['message'] as String? ?? '',
                        timestamp:
                            (data['createdAt'] as Timestamp?)?.toDate() ??
                                DateTime.now(),
                        isRead: data['read'] as bool? ?? false,
                        actorName: data['actorName'] as String?,
                        actorImageUrl: data['actorImageUrl'] as String?,
                      );
                    }).toList(),
                  );
                },
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildEmptyState() => Container(
        padding: const EdgeInsets.all(48),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: const Color(0xFFE5E7EB)),
        ),
        child: Center(
          child: Column(
            children: [
              Icon(Icons.notifications_none, size: 64, color: Colors.grey[300]),
              const SizedBox(height: 16),
              const Text(
                'No notifications yet',
                style: TextStyle(
                    color: Color(0xFF6B7280),
                    fontSize: 16,
                    fontWeight: FontWeight.w600),
              ),
              const SizedBox(height: 8),
              const Text(
                'When you receive notifications, they will appear here',
                style: TextStyle(color: Color(0xFF9CA3AF), fontSize: 14),
              ),
            ],
          ),
        ),
      );

  Future<void> _markAllAsRead(String userId) async {
    final batch = FirebaseFirestore.instance.batch();
    final notifications = await FirebaseFirestore.instance
        .collection('notifications')
        .where('recipientId', isEqualTo: userId)
        .where('read', isEqualTo: false)
        .get();

    for (final doc in notifications.docs) {
      batch.update(doc.reference, {'read': true});
    }

    await batch.commit();
  }
}

class _NotificationItem extends StatelessWidget {
  const _NotificationItem({
    required this.notificationId,
    required this.type,
    required this.title,
    required this.message,
    required this.timestamp,
    required this.isRead,
    this.actorName,
    this.actorImageUrl,
  });

  final String notificationId;
  final String type;
  final String title;
  final String message;
  final DateTime timestamp;
  final bool isRead;
  final String? actorName;
  final String? actorImageUrl;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: () => _markAsRead(),
      child: Container(
        margin: const EdgeInsets.only(bottom: 12),
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: isRead ? Colors.white : const Color(0xFFF0F9FF),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
              color:
                  isRead ? const Color(0xFFE5E7EB) : const Color(0xFFBFDBFE)),
        ),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildIcon(),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Expanded(
                        child: Text(
                          title,
                          style: TextStyle(
                            color: const Color(0xFF111827),
                            fontSize: 15,
                            fontWeight:
                                isRead ? FontWeight.w600 : FontWeight.w700,
                          ),
                        ),
                      ),
                      Text(
                        _formatTimestamp(timestamp),
                        style: const TextStyle(
                            color: Color(0xFF9CA3AF), fontSize: 12),
                      ),
                    ],
                  ),
                  const SizedBox(height: 6),
                  Text(
                    message,
                    style:
                        const TextStyle(color: Color(0xFF6B7280), fontSize: 14),
                  ),
                  if (actorName != null) ...[
                    const SizedBox(height: 8),
                    Text(
                      actorName!,
                      style: const TextStyle(
                          color: Color(0xFF2563EB),
                          fontSize: 13,
                          fontWeight: FontWeight.w600),
                    ),
                  ],
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildIcon() {
    IconData iconData;
    Color iconColor;

    switch (type) {
      case 'module_completed':
        iconData = Icons.check_circle;
        iconColor = const Color(0xFF10B981);
        break;
      case 'profile_updated':
        iconData = Icons.person;
        iconColor = const Color(0xFF3B82F6);
        break;
      case 'session_scheduled':
        iconData = Icons.event;
        iconColor = const Color(0xFF8B5CF6);
        break;
      case 'message':
        iconData = Icons.mail;
        iconColor = const Color(0xFF06B6D4);
        break;
      case 'new_content':
        iconData = Icons.library_books;
        iconColor = const Color(0xFFF59E0B);
        break;
      case 'achievement':
        iconData = Icons.emoji_events;
        iconColor = const Color(0xFFEAB308);
        break;
      case 'scorecard_submitted':
        iconData = Icons.assessment;
        iconColor = const Color(0xFF14B8A6);
        break;
      case 'welcome':
        iconData = Icons.celebration;
        iconColor = const Color(0xFFEC4899);
        break;
      default:
        iconData = Icons.info;
        iconColor = const Color(0xFF6B7280);
    }

    return Container(
      padding: const EdgeInsets.all(10),
      decoration: BoxDecoration(
        color: iconColor.withValues(alpha: 0.1),
        shape: BoxShape.circle,
      ),
      child: Icon(iconData, color: iconColor, size: 24),
    );
  }

  String _formatTimestamp(DateTime dt) {
    final now = DateTime.now();
    final diff = now.difference(dt);

    if (diff.inMinutes < 1) return 'Just now';
    if (diff.inMinutes < 60) return '${diff.inMinutes}m ago';
    if (diff.inHours < 24) return '${diff.inHours}h ago';
    if (diff.inDays < 7) return '${diff.inDays}d ago';
    return '${dt.day}/${dt.month}/${dt.year}';
  }

  Future<void> _markAsRead() async {
    if (!isRead) {
      await FirebaseFirestore.instance
          .collection('notifications')
          .doc(notificationId)
          .update({'read': true});
    }
  }
}

class CoachDashboardView extends StatefulWidget {
  const CoachDashboardView({super.key});

  static const Color _border = Color(0xFFE5E7EB);

  @override
  State<CoachDashboardView> createState() => _CoachDashboardViewState();
}

class _CoachDashboardViewState extends State<CoachDashboardView> {
  int _activeMembersCount = 0;
  int _upcomingSessionsCount = 0;
  double _avgEngagement = 0.0;
  int _unreadMessagesCount = 0;

  @override
  void initState() {
    super.initState();
    _loadDashboardData();
  }

  Future<void> _loadDashboardData() async {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) return;

    final firestore = FirebaseFirestore.instance;
    final coachRef = firestore.collection('users').doc(currentUser.uid);

    // Count active members assigned to this coach from member_coach collection
    final memberCoachSnapshot = await firestore
        .collection('member_coach')
        .where('coach', isEqualTo: coachRef)
        .get();

    final List<String> memberIds = [];
    for (final doc in memberCoachSnapshot.docs) {
      final memberRef = doc.data()['member'] as DocumentReference?;
      if (memberRef != null) {
        memberIds.add(memberRef.id);
      }
    }
    final activeMembersCount = memberIds.length;

    // Count upcoming sessions for this coach
    final sessionsSnapshot = await firestore
        .collection('sessions')
        .where('coachId', isEqualTo: currentUser.uid)
        .where('date', isGreaterThanOrEqualTo: Timestamp.now())
        .get();

    final upcomingSessionsCount = sessionsSnapshot.docs.length;

    // Calculate average engagement from module completions for assigned members
    double totalEngagement = 0.0;
    if (memberIds.isNotEmpty) {
      int totalCompletions = 0;
      for (final memberId in memberIds) {
        // Count THINK module completions
        final thinkCompletions = await firestore
            .collection('users')
            .doc(memberId)
            .collection('completions')
            .where('moduleType', isEqualTo: 'THINK')
            .get();
        totalCompletions += thinkCompletions.docs.length;

        // Count KEEP module completions
        final keepCompletions = await firestore
            .collection('users')
            .doc(memberId)
            .collection('completions')
            .where('moduleType', isEqualTo: 'KEEP')
            .get();
        totalCompletions += keepCompletions.docs.length;
      }
      // Average engagement as percentage (assuming ~10 total modules per member: 5 THINK + 5 KEEP)
      totalEngagement = (totalCompletions / memberIds.length / 10) * 100;
      if (totalEngagement > 100) totalEngagement = 100;
    }

    // Count unread messages in chats where coach is a member
    final chatsSnapshot = await firestore
        .collection('chats')
        .where('members', arrayContains: currentUser.uid)
        .get();

    int unreadCount = 0;
    for (final chatDoc in chatsSnapshot.docs) {
      final chatData = chatDoc.data();
      // Check unreadCounts map for current user's unread count
      final unreadCounts = chatData['unreadCounts'] as Map<String, dynamic>?;
      if (unreadCounts != null) {
        final userUnread = unreadCounts[currentUser.uid];
        if (userUnread is int && userUnread > 0) {
          unreadCount += userUnread;
        } else if (userUnread is num && userUnread > 0) {
          unreadCount += userUnread.toInt();
        }
      }
      // Also check unreadBy array as fallback
      final unreadBy = chatData['unreadBy'] as List<dynamic>?;
      if (unreadBy != null &&
          unreadBy.contains(currentUser.uid) &&
          unreadCounts == null) {
        unreadCount++;
      }
    }

    if (mounted) {
      setState(() {
        _activeMembersCount = activeMembersCount;
        _upcomingSessionsCount = upcomingSessionsCount;
        _avgEngagement = totalEngagement;
        _unreadMessagesCount = unreadCount;
      });
    }
  }

  List<_CoachStatCardData> get _coreStats => [
        _CoachStatCardData(
          title: 'Active Members',
          value: '$_activeMembersCount',
          icon: Icons.group_outlined,
          iconColor: const Color(0xFF1D4ED8),
          iconBackground: const Color(0xFFE8EEFF),
        ),
        _CoachStatCardData(
          title: 'Upcoming Sessions',
          value: '$_upcomingSessionsCount',
          icon: Icons.event_available_outlined,
          iconColor: const Color(0xFF059669),
          iconBackground: const Color(0xFFE6F8F1),
        ),
        _CoachStatCardData(
          title: 'Avg. Engagement',
          value: '${_avgEngagement.toStringAsFixed(0)}%',
          icon: Icons.trending_up,
          iconColor: const Color(0xFFF59E0B),
          iconBackground: const Color(0xFFFDF6E7),
        ),
        _CoachStatCardData(
          title: 'Unread Messages',
          value: '$_unreadMessagesCount',
          icon: Icons.mark_chat_unread_outlined,
          iconColor: const Color(0xFF2563EB),
          iconBackground: const Color(0xFFE4ECFF),
        ),
      ];

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final double horizontalPadding =
            constraints.maxWidth > 1320 ? 64.0 : 36.0;
        final bool stackStats = constraints.maxWidth < 1100;
        final bool stackLower = constraints.maxWidth < 1180;

        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  const Expanded(
                    child: Text(
                      'Coach Dashboard',
                      style: TextStyle(
                        fontSize: 24,
                        fontWeight: FontWeight.w700,
                        color: Color(0xFF111827),
                      ),
                    ),
                  ),
                  ElevatedButton.icon(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF2563EB),
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(
                          horizontal: 24, vertical: 16),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(14)),
                      elevation: 0,
                    ),
                    onPressed: () {},
                    icon: const Icon(Icons.add),
                    label: const Text(
                      'New Session',
                      style: TextStyle(fontWeight: FontWeight.w600),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 28),
              stackStats
                  ? Column(
                      children: [
                        for (var i = 0; i < _coreStats.length; i++) ...[
                          _CoachStatCard(data: _coreStats[i]),
                          if (i != _coreStats.length - 1)
                            const SizedBox(height: 16),
                        ],
                      ],
                    )
                  : Row(
                      children: [
                        for (var i = 0; i < _coreStats.length; i++) ...[
                          Expanded(child: _CoachStatCard(data: _coreStats[i])),
                          if (i != _coreStats.length - 1)
                            const SizedBox(width: 20),
                        ],
                      ],
                    ),
              const SizedBox(height: 32),
              stackLower
                  ? const Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        _CoachUpcomingSessionsCard(),
                        SizedBox(height: 24),
                        _CoachMemberProgressCard(),
                      ],
                    )
                  : const Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Expanded(flex: 3, child: _CoachUpcomingSessionsCard()),
                        SizedBox(width: 24),
                        Expanded(flex: 2, child: _CoachMemberProgressCard()),
                      ],
                    ),
            ],
          ),
        );
      },
    );
  }
}

class _CoachStatCardData {
  const _CoachStatCardData({
    required this.title,
    required this.value,
    required this.icon,
    required this.iconColor,
    required this.iconBackground,
  });

  final String title;
  final String value;
  final IconData icon;
  final Color iconColor;
  final Color iconBackground;
}

class _CoachStatCard extends StatelessWidget {
  const _CoachStatCard({required this.data});

  final _CoachStatCardData data;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 24),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: CoachDashboardView._border),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: data.iconBackground,
              borderRadius: BorderRadius.circular(14),
            ),
            child: Icon(data.icon, color: data.iconColor, size: 28),
          ),
          const SizedBox(height: 18),
          Text(
            data.title,
            style: const TextStyle(
              color: Color(0xFF111827),
              fontSize: 15,
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 12),
          Text(
            data.value,
            style: const TextStyle(
              color: Color(0xFF111827),
              fontSize: 28,
              fontWeight: FontWeight.w700,
            ),
          ),
        ],
      ),
    );
  }
}

class _CoachUpcomingSessionsCard extends StatefulWidget {
  const _CoachUpcomingSessionsCard();

  @override
  State<_CoachUpcomingSessionsCard> createState() => _CoachUpcomingSessionsCardState();
}

class _CoachUpcomingSessionsCardState extends State<_CoachUpcomingSessionsCard> {
  static const Color _border = Color(0xFFE5E7EB);
  static const Color _muted = Color(0xFF6B7280);

  void _showSessionCreationDialog() {
    showDialog(
      context: context,
      builder: (context) => const _SessionCreationDialog(),
    );
  }

  @override
  Widget build(BuildContext context) {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      return const SizedBox.shrink();
    }

    return Container(
      padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: _border),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'Upcoming Sessions',
                style: TextStyle(
                  color: Color(0xFF111827),
                  fontSize: 18,
                  fontWeight: FontWeight.w700,
                ),
              ),
              ElevatedButton.icon(
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFFE1E9FF),
                  foregroundColor: const Color(0xFF2563EB),
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12)),
                  elevation: 0,
                ),
                onPressed: _showSessionCreationDialog,
                icon: const Icon(Icons.add, size: 18),
                label: const Text(
                  'New Session',
                  style: TextStyle(fontWeight: FontWeight.w600, fontSize: 14),
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          StreamBuilder<QuerySnapshot>(
            stream: FirebaseFirestore.instance
                .collection('coachingNotes')
                .where('coachId', isEqualTo: currentUser.uid)
                .where('noteType', isEqualTo: 'Session Note')
                .snapshots(),
            builder: (context, snapshot) {
              if (snapshot.connectionState == ConnectionState.waiting) {
                return const Center(
                  child: Padding(
                    padding: EdgeInsets.all(24),
                    child: CircularProgressIndicator(strokeWidth: 2),
                  ),
                );
              }

              if (snapshot.hasError) {
                return Container(
                  padding: const EdgeInsets.all(24),
                  child: Text(
                    'Error loading sessions',
                    style: TextStyle(color: Colors.red.shade400, fontSize: 14),
                  ),
                );
              }

              var sessions = snapshot.data?.docs ?? [];

              // Sort by session date
              sessions.sort((a, b) {
                final aData = a.data() as Map<String, dynamic>;
                final bData = b.data() as Map<String, dynamic>;
                final aDate = aData['sessionDate'] as Timestamp?;
                final bDate = bData['sessionDate'] as Timestamp?;
                if (aDate == null && bDate == null) return 0;
                if (aDate == null) return 1;
                if (bDate == null) return -1;
                return aDate.compareTo(bDate); // Ascending order
              });

              if (sessions.isEmpty) {
                return Container(
                  width: double.infinity,
                  padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 40),
                  decoration: BoxDecoration(
                    color: const Color(0xFFF9FAFB),
                    borderRadius: BorderRadius.circular(20),
                    border: Border.all(color: _border),
                  ),
                  child: const Center(
                    child: Text(
                      'No sessions scheduled.',
                      style: TextStyle(color: _muted, fontSize: 14),
                    ),
                  ),
                );
              }

              return ConstrainedBox(
                constraints: const BoxConstraints(maxHeight: 300),
                child: SingleChildScrollView(
                  child: Column(
                    children: sessions.map((doc) {
                      final data = doc.data() as Map<String, dynamic>;
                      return _SessionCard(
                        noteId: doc.id,
                        data: data,
                      );
                    }).toList(),
                  ),
                ),
              );
            },
          ),
        ],
      ),
    );
  }
}

// Session Card Widget - displays individual session with proper formatting
class _SessionCard extends StatelessWidget {
  const _SessionCard({
    required this.noteId,
    required this.data,
  });

  final String noteId;
  final Map<String, dynamic> data;

  @override
  Widget build(BuildContext context) {
    final sessionType = data['tag'] as String? ?? 'Session';
    final memberName = data['memberName'] as String? ?? 'Unknown';
    final sessionDate = data['sessionDate'] as Timestamp?;
    final now = DateTime.now();
    final isPast = sessionDate != null && sessionDate.toDate().isBefore(now);

    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: InkWell(
        onTap: () {
          showDialog(
            context: context,
            builder: (context) => _NoteDetailDialog(noteId: noteId, data: data),
          );
        },
        borderRadius: BorderRadius.circular(16),
        child: Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: isPast ? const Color(0xFFF9FAFB) : const Color(0xFFEFF6FF),
            borderRadius: BorderRadius.circular(16),
            border: Border.all(
              color: isPast ? const Color(0xFFE5E7EB) : const Color(0xFFBFDBFE),
            ),
          ),
          child: Row(
            children: [
              Container(
                padding: const EdgeInsets.all(10),
                decoration: BoxDecoration(
                  color: isPast
                      ? const Color(0xFFE5E7EB)
                      : const Color(0xFF3B82F6).withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  Icons.event_note_outlined,
                  color: isPast ? const Color(0xFF6B7280) : const Color(0xFF3B82F6),
                  size: 20,
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                        child: memberName != null && memberName != 'Unknown' && memberName.isNotEmpty
                            ? RichText(
                                text: TextSpan(
                                  style: const TextStyle(
                                    fontSize: 14,
                                    color: Color(0xFF1F2937),
                                  ),
                                  children: [
                                    TextSpan(
                                      text: sessionType,
                                      style: const TextStyle(fontWeight: FontWeight.w600),
                                    ),
                                    const TextSpan(text: ' with '),
                                    TextSpan(
                                      text: memberName,
                                      style: const TextStyle(fontWeight: FontWeight.w600),
                                    ),
                                  ],
                                ),
                              )
                            : Text(
                                sessionType,
                                style: const TextStyle(
                                  fontSize: 14,
                                  color: Color(0xFF1F2937),
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                      ),
                        if (isPast)
                          Container(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 8, vertical: 4),
                            decoration: BoxDecoration(
                              color: const Color(0xFF6B7280).withOpacity(0.1),
                              borderRadius: BorderRadius.circular(6),
                            ),
                            child: const Text(
                              'Completed',
                              style: TextStyle(
                                color: Color(0xFF6B7280),
                                fontSize: 11,
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                          ),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        const Icon(Icons.calendar_today,
                            size: 12, color: Color(0xFF9CA3AF)),
                        const SizedBox(width: 4),
                        Text(
                          sessionDate != null
                              ? _formatSessionDate(sessionDate)
                              : 'No date set',
                          style: const TextStyle(
                            color: Color(0xFF6B7280),
                            fontSize: 12,
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatSessionDate(Timestamp timestamp) {
    final date = timestamp.toDate();
    return '${date.month}/${date.day}/${date.year}';
  }
}

// Session Creation Dialog - allows creating session notes from dashboard
class _SessionCreationDialog extends StatefulWidget {
  const _SessionCreationDialog();

  @override
  State<_SessionCreationDialog> createState() => _SessionCreationDialogState();
}

class _SessionCreationDialogState extends State<_SessionCreationDialog> {
  final _sessionTypeController = TextEditingController();
  final _sessionFocusController = TextEditingController();
  String? _selectedMemberId;
  String? _selectedMemberName;
  DateTime? _sessionDate;
  List<Map<String, dynamic>> _members = [];
  bool _isLoadingMembers = true;
  bool _isCreating = false;

  @override
  void initState() {
    super.initState();
    _loadMembers();
  }

  @override
  void dispose() {
    _sessionTypeController.dispose();
    _sessionFocusController.dispose();
    super.dispose();
  }

  Future<void> _loadMembers() async {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      setState(() => _isLoadingMembers = false);
      return;
    }

    try {
      final currentUserRef = FirebaseFirestore.instance
          .collection('users')
          .doc(currentUser.uid);

      var coachDocs = await FirebaseFirestore.instance
          .collection('member_coach')
          .where('coachref', isEqualTo: currentUserRef)
          .get();

      if (coachDocs.docs.isEmpty) {
        coachDocs = await FirebaseFirestore.instance
            .collection('member_coach')
            .where('coach', isEqualTo: currentUserRef)
            .get();
      }

      final Set<String> memberIds = {};

      for (final coachDoc in coachDocs.docs) {
        final data = coachDoc.data();
        final memberRef = data['memberref'] as DocumentReference?
            ?? data['member'] as DocumentReference?;
        if (memberRef != null) {
          memberIds.add(memberRef.id);
        }

        final membersAssigned = data['membersAssigned'] as List<dynamic>?;
        if (membersAssigned != null) {
          for (final memberRefItem in membersAssigned) {
            if (memberRefItem is DocumentReference) {
              memberIds.add(memberRefItem.id);
            }
          }
        }
      }

      final List<Map<String, dynamic>> members = [];
      for (final memberId in memberIds) {
        try {
          final memberDoc = await FirebaseFirestore.instance
              .collection('users')
              .doc(memberId)
              .get();
          
          if (memberDoc.exists) {
            final data = memberDoc.data()!;
            final firstName = data['firstName'] as String? ?? '';
            final lastName = data['lastName'] as String? ?? '';
            final displayName =
                data['displayName'] as String? ?? '$firstName $lastName'.trim();
            members.add({
              'id': memberId,
              'name': displayName.isNotEmpty ? displayName : 'Member',
            });
          }
        } catch (e) {
          debugPrint('Error loading member $memberId: $e');
        }
      }

      if (mounted) {
        setState(() {
          _members = members;
          _isLoadingMembers = false;
        });
      }
    } catch (e) {
      debugPrint('Error loading members: $e');
      if (mounted) {
        setState(() {
          _members = [];
          _isLoadingMembers = false;
        });
      }
    }
  }

  Future<void> _selectDate() async {
    final now = DateTime.now();
    final picked = await showDatePicker(
      context: context,
      initialDate: _sessionDate ?? now,
      firstDate: now.subtract(const Duration(days: 365)),
      lastDate: now.add(const Duration(days: 365)),
    );
    if (picked != null && mounted) {
      setState(() => _sessionDate = picked);
    }
  }

  Future<void> _createSession() async {
    if (_sessionFocusController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter session focus')),
      );
      return;
    }

    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please sign in to create session notes')),
      );
      return;
    }

    setState(() => _isCreating = true);

    try {
      final sessionType = _sessionTypeController.text.trim().isNotEmpty
          ? _sessionTypeController.text.trim()
          : 'Coaching Session';
      final sessionFocus = _sessionFocusController.text.trim();

      final noteContent = '''Session Type: $sessionType
Focus Areas: $sessionFocus

Key Discussion Points:
‚Ä¢ Review of progress since last session
‚Ä¢ Current challenges and opportunities
‚Ä¢ Action items and next steps

Next Steps:
‚Ä¢ Follow up on discussed items
‚Ä¢ Schedule next session''';

      await FirebaseFirestore.instance.collection('coachingNotes').add({
        'title': 'Session Note - $sessionType',
        'content': noteContent,
        'coachId': currentUser.uid,
        'memberId': _selectedMemberId,
        'memberName': _selectedMemberName ?? 'Unknown',
        'noteType': 'Session Note',
        'tag': sessionType,
        'isDraft': false,
        'sessionDate':
            _sessionDate != null ? Timestamp.fromDate(_sessionDate!) : null,
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      });

      if (mounted) {
        Navigator.of(context).pop();
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Session note created successfully'),
            backgroundColor: Color(0xFF22C55E),
          ),
        );
      }
    } catch (e) {
      debugPrint('Error creating session note: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to create session: $e')),
        );
      }
    } finally {
      if (mounted) setState(() => _isCreating = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      child: Container(
        width: 600,
        constraints: const BoxConstraints(maxHeight: 650),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(24),
              decoration: const BoxDecoration(
                color: Color(0xFF2563EB),
                borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
              ),
              child: Row(
                children: [
                  const Icon(Icons.event_note, color: Colors.white, size: 28),
                  const SizedBox(width: 12),
                  const Expanded(
                    child: Text(
                      'Create Session',
                      style: TextStyle(
                          color: Colors.white,
                          fontSize: 20,
                          fontWeight: FontWeight.w700),
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close, color: Colors.white),
                    onPressed: () => Navigator.of(context).pop(),
                  ),
                ],
              ),
            ),
            Flexible(
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(24),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    _buildLabel('Member'),
                    const SizedBox(height: 8),
                    _isLoadingMembers
                        ? const CircularProgressIndicator(strokeWidth: 2)
                        : DropdownButtonFormField<String>(
                            value: _selectedMemberId,
                            items: _members
                                .map((m) => DropdownMenuItem(
                                      value: m['id'] as String,
                                      child: Text(m['name'] as String),
                                    ))
                                .toList(),
                            onChanged: (value) {
                              final member = _members.firstWhere(
                                  (m) => m['id'] == value,
                                  orElse: () => {});
                              setState(() {
                                _selectedMemberId = value;
                                _selectedMemberName = member['name'] as String?;
                              });
                            },
                            decoration: _inputDecoration('Select member'),
                          ),
                    const SizedBox(height: 20),
                    _buildLabel('Session Type'),
                    const SizedBox(height: 8),
                    TextField(
                      controller: _sessionTypeController,
                      decoration: _inputDecoration('e.g., Check-in, Strategy, Review'),
                    ),
                    const SizedBox(height: 20),
                    _buildLabel('Session Focus'),
                    const SizedBox(height: 8),
                    TextField(
                      controller: _sessionFocusController,
                      minLines: 3,
                      maxLines: 5,
                      decoration: _inputDecoration(
                          'Key areas to focus on during this session'),
                    ),
                    const SizedBox(height: 20),
                    _buildLabel('Session Date'),
                    const SizedBox(height: 8),
                    InkWell(
                      onTap: _selectDate,
                      child: Container(
                        padding: const EdgeInsets.symmetric(
                            horizontal: 16, vertical: 14),
                        decoration: BoxDecoration(
                          border: Border.all(color: const Color(0xFFE5E7EB)),
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Row(
                          children: [
                            const Icon(Icons.calendar_today,
                                color: Color(0xFF6B7280), size: 18),
                            const SizedBox(width: 12),
                            Text(
                              _sessionDate != null
                                  ? '${_sessionDate!.month}/${_sessionDate!.day}/${_sessionDate!.year}'
                                  : 'Select date',
                              style: TextStyle(
                                color: _sessionDate != null
                                    ? const Color(0xFF374151)
                                    : const Color(0xFF9CA3AF),
                                fontSize: 14,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                    const SizedBox(height: 24),
                    SizedBox(
                      width: double.infinity,
                      height: 50,
                      child: ElevatedButton(
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF2563EB),
                          foregroundColor: Colors.white,
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(12)),
                          elevation: 0,
                        ),
                        onPressed: _isCreating ? null : _createSession,
                        child: _isCreating
                            ? const SizedBox(
                                width: 20,
                                height: 20,
                                child: CircularProgressIndicator(
                                    color: Colors.white, strokeWidth: 2))
                            : const Text(
                                'Create Session',
                                style: TextStyle(
                                    fontSize: 15, fontWeight: FontWeight.w600),
                              ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildLabel(String text) {
    return Text(
      text,
      style: const TextStyle(
        color: Color(0xFF374151),
        fontSize: 14,
        fontWeight: FontWeight.w600,
      ),
    );
  }

  InputDecoration _inputDecoration(String hint) {
    return InputDecoration(
      hintText: hint,
      hintStyle: const TextStyle(color: Color(0xFF9CA3AF)),
      filled: true,
      fillColor: const Color(0xFFFAFAFA),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: Color(0xFFE5E7EB)),
      ),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: Color(0xFFE5E7EB)),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: Color(0xFF3B82F6), width: 2),
      ),
    );
  }
}


class _CoachMemberProgressCard extends StatefulWidget {
  const _CoachMemberProgressCard();

  @override
  State<_CoachMemberProgressCard> createState() =>
      _CoachMemberProgressCardState();
}

class _CoachMemberProgressCardState extends State<_CoachMemberProgressCard> {
  List<_MemberProgressData> _memberProgress = [];
  bool _loading = true;

  @override
  void initState() {
    super.initState();
    _loadMemberProgress();
  }

  Future<void> _loadMemberProgress() async {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) return;

    final firestore = FirebaseFirestore.instance;
    final currentUserRef = firestore.collection('users').doc(currentUser.uid);

    try {
      // Query member_coach collection
      var coachDocs = await firestore
          .collection('member_coach')
          .where('coachref', isEqualTo: currentUserRef)
          .get();

      // Also check for 'coach' field as fallback
      if (coachDocs.docs.isEmpty) {
        coachDocs = await firestore
            .collection('member_coach')
            .where('coach', isEqualTo: currentUserRef)
            .get();
      }

      final Set<String> memberIds = {};

      for (final coachDoc in coachDocs.docs) {
        final data = coachDoc.data();
        
        // Get single member reference (legacy)
        final memberRef = data['memberref'] as DocumentReference?
            ?? data['member'] as DocumentReference?;
        if (memberRef != null) {
          memberIds.add(memberRef.id);
        }

        // Get multiple members from array
        final membersAssigned = data['membersAssigned'] as List<dynamic>?;
        if (membersAssigned != null) {
          for (final memberRefItem in membersAssigned) {
            if (memberRefItem is DocumentReference) {
              memberIds.add(memberRefItem.id);
            }
          }
        }
      }

      final List<_MemberProgressData> progressList = [];

      for (final memberId in memberIds) {
        try {
          // Get member details
          final memberDoc = await firestore.collection('users').doc(memberId).get();
          
          if (!memberDoc.exists) continue;

          final memberData = memberDoc.data()!;
          final String firstName = memberData['firstName'] as String? ?? '';
          final String lastName = memberData['lastName'] as String? ?? '';
          final String displayName = memberData['displayName'] as String? ?? '';
          final String memberName =
              displayName.isNotEmpty ? displayName : '$firstName $lastName'.trim();

          // Get next session date from coachingNotes
          final sessionsSnapshot = await firestore
              .collection('coachingNotes')
              .where('coachId', isEqualTo: currentUser.uid)
              .where('memberId', isEqualTo: memberId)
              .where('noteType', isEqualTo: 'Session Note')
              .get();

          String nextSessionDate = 'None';
          DateTime? closestDate;

          for (final sessionDoc in sessionsSnapshot.docs) {
            final sessionData = sessionDoc.data();
            final Timestamp? sessionTimestamp = sessionData['sessionDate'] as Timestamp?;
            if (sessionTimestamp != null) {
              final DateTime sessionDate = sessionTimestamp.toDate();
              final now = DateTime.now();
              
              // Only consider future sessions
              if (sessionDate.isAfter(now)) {
                if (closestDate == null || sessionDate.isBefore(closestDate)) {
                  closestDate = sessionDate;
                }
              }
            }
          }

          if (closestDate != null) {
            nextSessionDate =
                '${closestDate.month}/${closestDate.day}/${closestDate.year}';
          }

          progressList.add(_MemberProgressData(
            name: memberName.isEmpty ? 'Unnamed Member' : memberName,
            progress: 0.0, // Not used anymore
            nextSession: nextSessionDate,
          ));
        } catch (e) {
          debugPrint('Error loading member $memberId: $e');
        }
      }

      if (mounted) {
        setState(() {
          _memberProgress = progressList;
          _loading = false;
        });
      }
    } catch (e) {
      debugPrint('Error loading member progress: $e');
      if (mounted) {
        setState(() {
          _memberProgress = [];
          _loading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.fromLTRB(24, 24, 24, 28),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: const Color(0xFFE5E7EB)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Member Progress',
            style: TextStyle(
              color: Color(0xFF111827),
              fontSize: 18,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 16),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
            decoration: BoxDecoration(
              color: const Color(0xFFF3F4F6),
              borderRadius: BorderRadius.circular(18),
            ),
            child: Row(
              children: [
                Expanded(
                  flex: 2,
                  child: Text(
                    'MEMBER',
                    style: TextStyle(
                      color: Color(0xFF6B7280),
                      fontSize: 13,
                      fontWeight: FontWeight.w700,
                      letterSpacing: 0.6,
                    ),
                  ),
                ),
                Expanded(
                  child: Text(
                    'NEXT SESSION',
                    style: TextStyle(
                      color: Color(0xFF6B7280),
                      fontSize: 13,
                      fontWeight: FontWeight.w700,
                      letterSpacing: 0.6,
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 16),
          if (_loading)
            Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(vertical: 24),
              child: const Center(
                child: CircularProgressIndicator(),
              ),
            )
          else if (_memberProgress.isEmpty)
            Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(vertical: 24),
              decoration: BoxDecoration(
                color: const Color(0xFFF9FAFB),
                borderRadius: BorderRadius.circular(18),
                border: Border.all(color: const Color(0xFFE5E7EB)),
              ),
              child: const Center(
                child: Text(
                  'No member progress to display yet.',
                  style: TextStyle(color: Color(0xFF9CA3AF), fontSize: 13),
                ),
              ),
            )
          else
            Column(
              children: _memberProgress
                  .map((member) => _MemberProgressRow(data: member))
                  .toList(),
            ),
        ],
      ),
    );
  }
}

class _MemberProgressData {
  const _MemberProgressData({
    required this.name,
    required this.progress,
    required this.nextSession,
  });

  final String name;
  final double progress;
  final String nextSession;
}

class _MemberProgressRow extends StatelessWidget {
  const _MemberProgressRow({required this.data});

  final _MemberProgressData data;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: const Color(0xFFE5E7EB)),
        ),
        child: Row(
          children: [
            Expanded(
              flex: 2,
              child: Row(
                children: [
                  Container(
                    width: 36,
                    height: 36,
                    decoration: BoxDecoration(
                      color: const Color(0xFF3B82F6).withOpacity(0.1),
                      borderRadius: BorderRadius.circular(10),
                    ),
                    child: const Icon(
                      Icons.person_outline,
                      color: Color(0xFF3B82F6),
                      size: 18,
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      data.name,
                      style: const TextStyle(
                        color: Color(0xFF1F2937),
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
            ),
            Expanded(
              child: Text(
                data.nextSession,
                style: const TextStyle(
                  color: Color(0xFF6B7280),
                  fontSize: 13,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class CoachAnalyticsPage extends StatefulWidget {
  const CoachAnalyticsPage({super.key});

  @override
  State<CoachAnalyticsPage> createState() => _CoachAnalyticsPageState();
}

class _CoachAnalyticsPageState extends State<CoachAnalyticsPage> {
  static const List<_FrameworkProgressData> _frameworks = [
    _FrameworkProgressData(label: 'Accelerate', progress: 0.68),
    _FrameworkProgressData(label: 'Transform', progress: 0.52),
    _FrameworkProgressData(label: 'Think', progress: 0.41),
    _FrameworkProgressData(label: 'Keep', progress: 0.36),
  ];

  int _activeMembersCount = 0;
  int _upcomingSessionsCount = 0;
  double _avgEngagement = 0.0;
  int _unreadMessagesCount = 0;

  @override
  void initState() {
    super.initState();
    _loadDashboardData();
  }

  Future<void> _loadDashboardData() async {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) return;

    final firestore = FirebaseFirestore.instance;

    // Count active members assigned to this coach
    final membersSnapshot = await firestore
        .collection('users')
        .where('coach',
            isEqualTo: firestore.collection('users').doc(currentUser.uid))
        .get();

    final members = membersSnapshot.docs;
    final activeMembersCount = members.length;

    // Count upcoming sessions for this coach
    final sessionsSnapshot = await firestore
        .collection('sessions')
        .where('coachId', isEqualTo: currentUser.uid)
        .where('date', isGreaterThanOrEqualTo: Timestamp.now())
        .get();

    final upcomingSessionsCount = sessionsSnapshot.docs.length;

    // Calculate average engagement from module completions
    double totalEngagement = 0.0;
    if (members.isNotEmpty) {
      for (final memberDoc in members) {
        final completions = await firestore
            .collection('users')
            .doc(memberDoc.id)
            .collection('completions')
            .get();

        if (completions.docs.isNotEmpty) {
          totalEngagement += completions.docs.length;
        }
      }
      totalEngagement = (totalEngagement / members.length / 10) * 100;
      if (totalEngagement > 100) totalEngagement = 100;
    }

    // Count unread messages in chats where coach is a member
    final chatsSnapshot = await firestore
        .collection('chats')
        .where('members', arrayContains: currentUser.uid)
        .get();

    int unreadCount = 0;
    for (final chatDoc in chatsSnapshot.docs) {
      final chatData = chatDoc.data();
      final lastMessageTime = chatData['lastMessageTime'] as Timestamp?;
      final lastReadTime =
          chatData['lastRead_${currentUser.uid}'] as Timestamp?;

      if (lastMessageTime != null &&
          (lastReadTime == null ||
              lastMessageTime.compareTo(lastReadTime) > 0)) {
        unreadCount++;
      }
    }

    if (mounted) {
      setState(() {
        _activeMembersCount = activeMembersCount;
        _upcomingSessionsCount = upcomingSessionsCount;
        _avgEngagement = totalEngagement;
        _unreadMessagesCount = unreadCount;
      });
    }
  }

  List<_CoachStatCardData> get _coreStats => [
        _CoachStatCardData(
          title: 'Active Members',
          value: '$_activeMembersCount',
          icon: Icons.group_outlined,
          iconColor: const Color(0xFF1D4ED8),
          iconBackground: const Color(0xFFE8EEFF),
        ),
        _CoachStatCardData(
          title: 'Upcoming Sessions',
          value: '$_upcomingSessionsCount',
          icon: Icons.event_available_outlined,
          iconColor: const Color(0xFF059669),
          iconBackground: const Color(0xFFE6F8F1),
        ),
        _CoachStatCardData(
          title: 'Avg. Engagement',
          value: '${_avgEngagement.toStringAsFixed(0)}%',
          icon: Icons.trending_up,
          iconColor: const Color(0xFFF59E0B),
          iconBackground: const Color(0xFFFDF6E7),
        ),
        _CoachStatCardData(
          title: 'Unread Messages',
          value: '$_unreadMessagesCount',
          icon: Icons.mark_chat_unread_outlined,
          iconColor: const Color(0xFF2563EB),
          iconBackground: const Color(0xFFE4ECFF),
        ),
      ];

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final double horizontalPadding =
            constraints.maxWidth > 1320 ? 64.0 : 36.0;
        final bool stackStats = constraints.maxWidth < 1100;

        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Analytics',
                style: TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.w700,
                  color: Color(0xFF111827),
                ),
              ),
              const SizedBox(height: 28),
              stackStats
                  ? Column(
                      children: [
                        for (var i = 0; i < _coreStats.length; i++) ...[
                          _CoachStatCard(data: _coreStats[i]),
                          if (i != _coreStats.length - 1)
                            const SizedBox(height: 16),
                        ],
                      ],
                    )
                  : Row(
                      children: [
                        for (var i = 0; i < _coreStats.length; i++) ...[
                          Expanded(child: _CoachStatCard(data: _coreStats[i])),
                          if (i != _coreStats.length - 1)
                            const SizedBox(width: 20),
                        ],
                      ],
                    ),
              const SizedBox(height: 28),
              const _MembersProgressFrameworkCard(frameworks: _frameworks),
            ],
          ),
        );
      },
    );
  }
}

class _FrameworkProgressData {
  const _FrameworkProgressData({required this.label, required this.progress});

  final String label;
  final double progress;
}

class _MembersProgressFrameworkCard extends StatelessWidget {
  const _MembersProgressFrameworkCard({required this.frameworks});

  final List<_FrameworkProgressData> frameworks;

  static const TextStyle _titleStyle = TextStyle(
    color: Color(0xFF111827),
    fontSize: 18,
    fontWeight: FontWeight.w700,
  );

  static const TextStyle _labelStyle = TextStyle(
    color: Color(0xFF111827),
    fontSize: 15,
    fontWeight: FontWeight.w600,
  );

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: CoachDashboardView._border),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('Members Progress By Framework', style: _titleStyle),
          const SizedBox(height: 20),
          for (var i = 0; i < frameworks.length; i++) ...[
            _FrameworkProgressRow(data: frameworks[i]),
            if (i != frameworks.length - 1)
              const Padding(
                padding: EdgeInsets.symmetric(vertical: 24),
                child: _DashedDivider(),
              )
            else
              const SizedBox(height: 4),
          ],
        ],
      ),
    );
  }
}

class _FrameworkProgressRow extends StatelessWidget {
  const _FrameworkProgressRow({required this.data});

  final _FrameworkProgressData data;

  static const Color _trackColor = Color(0xFFF3F4F6);
  static const Color _fillColor = Color(0xFFD1D5DB);

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(data.label, style: _MembersProgressFrameworkCard._labelStyle),
        const SizedBox(height: 12),
        ClipRRect(
          borderRadius: BorderRadius.circular(18),
          child: LinearProgressIndicator(
            value: data.progress,
            minHeight: 22,
            backgroundColor: _trackColor,
            valueColor: const AlwaysStoppedAnimation<Color>(_fillColor),
          ),
        ),
      ],
    );
  }
}

class _DashedDivider extends StatelessWidget {
  const _DashedDivider();

  static const Color _dashColor = Color(0xFFD1D5DB);

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final dashWidth = 6.0;
        final dashSpace = 6.0;
        final dashCount =
            (constraints.maxWidth / (dashWidth + dashSpace)).floor();

        return Row(
          children: List.generate(dashCount, (index) {
            return Padding(
              padding: EdgeInsets.only(
                  right: index == dashCount - 1 ? 0 : dashSpace),
              child: SizedBox(
                width: dashWidth,
                height: 1,
                child: const DecoratedBox(
                  decoration: BoxDecoration(color: _dashColor),
                ),
              ),
            );
          }),
        );
      },
    );
  }
}

enum CoachToolsTab { goalSettings, sessionTimer }

const Color _coachToolsTitleColor = Color(0xFF111827);
const Color _coachToolsMutedColor = Color(0xFF6B7280);
const Color _coachToolsBorderColor = Color(0xFFE5E7EB);
const Color _coachToolsTabBackground = Color(0xFFF5F6FA);
const Color _coachToolsTabActiveBackground = Colors.white;
const Color _coachToolsPrimaryBlue = Color(0xFF2F55EE);
const Color _coachToolsSecondaryBlue = Color(0xFF2563EB);

InputDecoration _coachToolsInputDecoration(String hint) {
  return InputDecoration(
    hintText: hint,
    filled: true,
    fillColor: const Color(0xFFF9FAFB),
    contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 18),
    enabledBorder: OutlineInputBorder(
      borderRadius: BorderRadius.circular(16),
      borderSide: const BorderSide(color: _coachToolsBorderColor),
    ),
    focusedBorder: OutlineInputBorder(
      borderRadius: BorderRadius.circular(16),
      borderSide: const BorderSide(color: _coachToolsPrimaryBlue, width: 1.4),
    ),
  );
}

BoxDecoration _coachToolsCardDecoration() {
  return BoxDecoration(
    color: Colors.white,
    borderRadius: BorderRadius.circular(24),
    border: Border.all(color: _coachToolsBorderColor),
    boxShadow: [
      BoxShadow(
        color: Colors.black.withOpacity(0.03),
        blurRadius: 12,
        offset: const Offset(0, 6),
      ),
    ],
  );
}

class CoachCoachingToolsPage extends StatefulWidget {
  const CoachCoachingToolsPage({super.key});

  @override
  State<CoachCoachingToolsPage> createState() => _CoachCoachingToolsPageState();
}

class _CoachCoachingToolsPageState extends State<CoachCoachingToolsPage> {
  CoachToolsTab _activeTab = CoachToolsTab.goalSettings;

  void _handleTabSelection(CoachToolsTab tab) {
    if (_activeTab == tab) return;
    setState(() => _activeTab = tab);
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final double horizontalPadding =
            constraints.maxWidth > 1180 ? 60.0 : 32.0;
        final bool stackColumns = constraints.maxWidth < 1200;

        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                _activeTab == CoachToolsTab.goalSettings
                    ? 'Goal Settings'
                    : 'Session Timer',
                style: const TextStyle(
                  color: _coachToolsTitleColor,
                  fontSize: 24,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 6),
              Text(
                _activeTab == CoachToolsTab.goalSettings
                    ? 'Resources and tools enhance your coaching sessions'
                    : 'Track and manage your coaching session workflow',
                style: const TextStyle(
                  color: _coachToolsMutedColor,
                  fontSize: 15,
                ),
              ),
              const SizedBox(height: 24),
              _CoachToolsTabBar(
                activeTab: _activeTab,
                onSelected: _handleTabSelection,
              ),
              const SizedBox(height: 28),
              if (_activeTab == CoachToolsTab.goalSettings)
                stackColumns
                    ? const Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          _GoalSettingToolCard(),
                          SizedBox(height: 24),
                          _CoachToolsRightColumn(),
                        ],
                      )
                    : Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: const [
                          Expanded(flex: 3, child: _GoalSettingToolCard()),
                          SizedBox(width: 24),
                          Expanded(flex: 2, child: _CoachToolsRightColumn()),
                        ],
                      )
              else
                _SessionTimerView(isCompact: stackColumns),
            ],
          ),
        );
      },
    );
  }
}

class _CoachToolsTabBar extends StatelessWidget {
  const _CoachToolsTabBar({required this.activeTab, required this.onSelected});

  final CoachToolsTab activeTab;
  final ValueChanged<CoachToolsTab> onSelected;

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: _coachToolsTabBackground,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: _coachToolsBorderColor),
      ),
      child: Row(
        children: [
          Expanded(
            child: _CoachToolsTab(
              label: 'Goal Settings',
              isActive: activeTab == CoachToolsTab.goalSettings,
              onTap: () => onSelected(CoachToolsTab.goalSettings),
            ),
          ),
          const SizedBox(
            height: 52,
            child: VerticalDivider(
                color: _coachToolsBorderColor, thickness: 1, width: 1),
          ),
          Expanded(
            child: _CoachToolsTab(
              label: 'Session Timer',
              isActive: activeTab == CoachToolsTab.sessionTimer,
              onTap: () => onSelected(CoachToolsTab.sessionTimer),
            ),
          ),
        ],
      ),
    );
  }
}

class _CoachToolsTab extends StatelessWidget {
  const _CoachToolsTab(
      {required this.label, this.isActive = false, this.onTap});

  final String label;
  final bool isActive;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final Color background =
        isActive ? _coachToolsTabActiveBackground : Colors.transparent;
    final Color textColor =
        isActive ? _coachToolsTitleColor : _coachToolsMutedColor;

    return Material(
      color: Colors.transparent,
      child: InkWell(
        borderRadius: BorderRadius.circular(16),
        onTap: isActive ? null : onTap,
        child: Container(
          decoration: BoxDecoration(
            color: background,
            borderRadius: BorderRadius.circular(16),
          ),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 18),
          alignment: Alignment.center,
          child: Text(
            label,
            style: TextStyle(
              color: textColor,
              fontSize: 15,
              fontWeight: isActive ? FontWeight.w700 : FontWeight.w600,
            ),
          ),
        ),
      ),
    );
  }
}

class _GoalSettingToolCard extends StatefulWidget {
  const _GoalSettingToolCard();

  @override
  State<_GoalSettingToolCard> createState() => _GoalSettingToolCardState();
}

class _GoalSettingToolCardState extends State<_GoalSettingToolCard> {
  static const TextStyle _labelStyle = TextStyle(
    color: _coachToolsTitleColor,
    fontSize: 14,
    fontWeight: FontWeight.w600,
  );

  final _titleController = TextEditingController();
  final _descriptionController = TextEditingController();
  String? _selectedMemberId;
  String? _selectedMemberName;
  String? _selectedGoalType;
  DateTime? _startDate;
  DateTime? _endDate;
  bool _isLoading = false;
  List<Map<String, dynamic>> _members = [];

  @override
  void initState() {
    super.initState();
    _loadMembers();
  }

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  Future<void> _loadMembers() async {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) return;

    try {
      final currentUserRef = FirebaseFirestore.instance
          .collection('users')
          .doc(currentUser.uid);

      // Query member_coach collection for documents where coach is current user
      var coachDocs = await FirebaseFirestore.instance
          .collection('member_coach')
          .where('coachref', isEqualTo: currentUserRef)
          .get();

      // Also check for 'coach' field as a fallback
      if (coachDocs.docs.isEmpty) {
        coachDocs = await FirebaseFirestore.instance
            .collection('member_coach')
            .where('coach', isEqualTo: currentUserRef)
            .get();
      }

      final Set<String> memberIds = {};

      // Extract member IDs from all matching coach documents
      for (final coachDoc in coachDocs.docs) {
        final data = coachDoc.data();
        
        // Handle single member reference (legacy)
        final memberRef = data['memberref'] as DocumentReference?
            ?? data['member'] as DocumentReference?;
        if (memberRef != null) {
          memberIds.add(memberRef.id);
        }

        // Handle multiple members assigned (current structure)
        final membersAssigned = data['membersAssigned'] as List<dynamic>?;
        if (membersAssigned != null) {
          for (final memberRefItem in membersAssigned) {
            if (memberRefItem is DocumentReference) {
              memberIds.add(memberRefItem.id);
            }
          }
        }
      }

      // Fetch user details for each member
      final List<Map<String, dynamic>> members = [];
      for (final memberId in memberIds) {
        try {
          final memberDoc = await FirebaseFirestore.instance
              .collection('users')
              .doc(memberId)
              .get();
          
          if (memberDoc.exists) {
            final data = memberDoc.data()!;
            final firstName = data['firstName'] as String? ?? '';
            final lastName = data['lastName'] as String? ?? '';
            final displayName =
                data['displayName'] as String? ?? '$firstName $lastName'.trim();
            members.add({
              'id': memberId,
              'name': displayName.isNotEmpty ? displayName : 'Member',
            });
          }
        } catch (e) {
          debugPrint('Error loading member $memberId: $e');
        }
      }

      if (mounted) {
        setState(() {
          _members = members;
        });
      }
    } catch (e) {
      debugPrint('Error loading members: $e');
      if (mounted) {
        setState(() {
          _members = [];
        });
      }
    }
  }

  Future<void> _selectDate(bool isStart) async {
    final now = DateTime.now();
    final picked = await showDatePicker(
      context: context,
      initialDate: isStart
          ? (_startDate ?? now)
          : (_endDate ?? now.add(const Duration(days: 30))),
      firstDate: now.subtract(const Duration(days: 365)),
      lastDate: now.add(const Duration(days: 365 * 2)),
    );
    if (picked != null && mounted) {
      setState(() {
        if (isStart) {
          _startDate = picked;
        } else {
          _endDate = picked;
        }
      });
    }
  }

  Future<void> _createGoal() async {
    if (_titleController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter a goal title')),
      );
      return;
    }

    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please sign in to create goals')),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      // Create the goal note in coachingNotes collection
      await FirebaseFirestore.instance.collection('coachingNotes').add({
        'title': _titleController.text.trim(),
        'content': _descriptionController.text.trim(),
        'coachId': currentUser.uid,
        'memberId': _selectedMemberId,
        'memberName': _selectedMemberName ?? 'Unknown',
        'noteType': 'Goal',
        'tag': _selectedGoalType ?? 'Growth Goal',
        'isDraft': false,
        'startDate':
            _startDate != null ? Timestamp.fromDate(_startDate!) : null,
        'endDate': _endDate != null ? Timestamp.fromDate(_endDate!) : null,
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      });

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Goal created and saved to Coach Notes'),
            backgroundColor: Color(0xFF22C55E),
          ),
        );
        // Clear form
        _titleController.clear();
        _descriptionController.clear();
        setState(() {
          _selectedMemberId = null;
          _selectedMemberName = null;
          _selectedGoalType = null;
          _startDate = null;
          _endDate = null;
        });
      }
    } catch (e) {
      debugPrint('Error creating goal: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to create goal: $e')),
        );
      }
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  String _formatDate(DateTime? date) {
    if (date == null) return 'Select date';
    return '${date.month}/${date.day}/${date.year}';
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
      decoration: _coachToolsCardDecoration(),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Goal Setting Tool',
            style: TextStyle(
              color: _coachToolsTitleColor,
              fontSize: 18,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 4),
          const Text(
            'Create and track SMART goals for your coaching clients',
            style: TextStyle(
              color: _coachToolsMutedColor,
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 24),
          _buildLabel('Member'),
          DropdownButtonFormField<String>(
            value: _selectedMemberId,
            items: _members
                .map((m) => DropdownMenuItem(
                      value: m['id'] as String,
                      child: Text(m['name'] as String),
                    ))
                .toList(),
            onChanged: (value) {
              final member = _members.firstWhere((m) => m['id'] == value,
                  orElse: () => {});
              setState(() {
                _selectedMemberId = value;
                _selectedMemberName = member['name'] as String?;
              });
            },
            decoration: _coachToolsInputDecoration('Select member'),
          ),
          const SizedBox(height: 20),
          _buildLabel('Goal Title'),
          TextFormField(
            controller: _titleController,
            decoration: _coachToolsInputDecoration('Enter a clear goal title'),
          ),
          const SizedBox(height: 20),
          _buildLabel('Description'),
          TextFormField(
            controller: _descriptionController,
            minLines: 4,
            maxLines: 6,
            decoration:
                _coachToolsInputDecoration('Describe your Goal in Detail'),
          ),
          const SizedBox(height: 24),
          Row(
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text('Start Date', style: _labelStyle),
                    const SizedBox(height: 12),
                    _DatePickerButton(
                      label: _formatDate(_startDate),
                      onTap: () => _selectDate(true),
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text('End Date', style: _labelStyle),
                    const SizedBox(height: 12),
                    _DatePickerButton(
                      label: _formatDate(_endDate),
                      onTap: () => _selectDate(false),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 24),
          _buildLabel('Goal Type'),
          DropdownButtonFormField<String>(
            value: _selectedGoalType,
            items: const [
              DropdownMenuItem(
                  value: 'Growth Goal', child: Text('Growth Goal')),
              DropdownMenuItem(value: 'Milestone', child: Text('Milestone')),
              DropdownMenuItem(
                  value: 'Performance', child: Text('Performance')),
              DropdownMenuItem(
                  value: 'Development', child: Text('Development')),
            ],
            onChanged: (value) => setState(() => _selectedGoalType = value),
            decoration: _coachToolsInputDecoration('Goal Type'),
          ),
          const SizedBox(height: 28),
          SizedBox(
            width: double.infinity,
            height: 54,
            child: ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: _coachToolsPrimaryBlue,
                foregroundColor: Colors.white,
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(16)),
                textStyle:
                    const TextStyle(fontSize: 16, fontWeight: FontWeight.w700),
                elevation: 0,
              ),
              onPressed: _isLoading ? null : _createGoal,
              child: _isLoading
                  ? const SizedBox(
                      width: 24,
                      height: 24,
                      child: CircularProgressIndicator(
                          color: Colors.white, strokeWidth: 2))
                  : const Text('Create Goal'),
            ),
          ),
        ],
      ),
    );
  }

  static Widget _buildLabel(String text) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Text(text, style: _labelStyle),
    );
  }
}

class _DatePickerButton extends StatelessWidget {
  const _DatePickerButton({required this.label, required this.onTap});

  final String label;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 54,
      width: double.infinity,
      child: ElevatedButton(
        style: ElevatedButton.styleFrom(
          backgroundColor: _coachToolsSecondaryBlue,
          foregroundColor: Colors.white,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(18)),
          elevation: 0,
        ),
        onPressed: onTap,
        child: Text(
          label,
          style: const TextStyle(fontSize: 15, fontWeight: FontWeight.w600),
        ),
      ),
    );
  }
}

class _DateButton extends StatelessWidget {
  const _DateButton({required this.label});

  final String label;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 54,
      width: double.infinity,
      child: ElevatedButton(
        style: ElevatedButton.styleFrom(
          backgroundColor: _coachToolsSecondaryBlue,
          foregroundColor: Colors.white,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(18)),
          elevation: 0,
        ),
        onPressed: () {},
        child: Text(
          label,
          style: const TextStyle(fontSize: 15, fontWeight: FontWeight.w600),
        ),
      ),
    );
  }
}

class _CoachToolsRightColumn extends StatelessWidget {
  const _CoachToolsRightColumn();

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: const [
        _SmartGoalChecklistCard(),
        SizedBox(height: 24),
        _GoalTipCard(),
      ],
    );
  }
}

class _SessionTimerView extends StatelessWidget {
  const _SessionTimerView({required this.isCompact});

  final bool isCompact;

  @override
  Widget build(BuildContext context) {
    final Widget rightColumn = Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: const [
        _SessionDetailsCard(),
        SizedBox(height: 24),
        _TimeManagementTipsCard(),
      ],
    );

    if (isCompact) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const _SessionTimerCard(),
          const SizedBox(height: 24),
          rightColumn,
        ],
      );
    }

    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Expanded(flex: 3, child: _SessionTimerCard()),
        const SizedBox(width: 24),
        Expanded(flex: 3, child: rightColumn),
      ],
    );
  }
}

class _SessionTimerCard extends StatefulWidget {
  const _SessionTimerCard();

  @override
  State<_SessionTimerCard> createState() => _SessionTimerCardState();
}

class _SessionTimerCardState extends State<_SessionTimerCard> {
  int _totalSeconds = 2400; // Default 40 minutes
  int _remainingSeconds = 2400;
  Timer? _timer;
  bool _isRunning = false;
  int _selectedGoalMinutes = 40;

  @override
  void dispose() {
    _timer?.cancel();
    super.dispose();
  }

  void _setGoalTimer(int minutes) {
    setState(() {
      _selectedGoalMinutes = minutes;
      _totalSeconds = minutes * 60;
      _remainingSeconds = minutes * 60;
      _isRunning = false;
    });
    _timer?.cancel();
  }

  void _startTimer() {
    if (_isRunning) return;
    setState(() => _isRunning = true);
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_remainingSeconds > 0) {
        setState(() => _remainingSeconds--);
      } else {
        _timer?.cancel();
        setState(() => _isRunning = false);
      }
    });
  }

  void _resetTimer() {
    _timer?.cancel();
    setState(() {
      _remainingSeconds = _totalSeconds;
      _isRunning = false;
    });
  }

  String get _formattedTime {
    final minutes = _remainingSeconds ~/ 60;
    final seconds = _remainingSeconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
  }

  @override
  Widget build(BuildContext context) {
    const TextStyle headlineStyle = TextStyle(
      color: _coachToolsTitleColor,
      fontSize: 18,
      fontWeight: FontWeight.w700,
    );

    const TextStyle mutedStyle = TextStyle(
      color: _coachToolsMutedColor,
      fontSize: 14,
    );

    return Container(
      padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
      decoration: _coachToolsCardDecoration(),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('Session Timer', style: headlineStyle),
          const SizedBox(height: 4),
          const Text('Track and manage your coaching session time',
              style: mutedStyle),
          const SizedBox(height: 32),
          Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  _formattedTime,
                  style: const TextStyle(
                    color: _coachToolsTitleColor,
                    fontSize: 48,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                const SizedBox(height: 20),
                Wrap(
                  spacing: 12,
                  runSpacing: 12,
                  alignment: WrapAlignment.center,
                  children: [
                    _TimerControlButton(
                      label: _isRunning ? 'Pause' : 'Start',
                      isPrimary: true,
                      onPressed: _startTimer,
                    ),
                    _TimerControlButton(
                      label: 'Reset',
                      onPressed: _resetTimer,
                    ),
                  ],
                ),
              ],
            ),
          ),
          const SizedBox(height: 32),
          const Divider(color: _coachToolsBorderColor),
          const SizedBox(height: 24),
          const Text(
            'Goal Timer',
            style: TextStyle(
              color: _coachToolsTitleColor,
              fontSize: 16,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 16),
          Wrap(
            spacing: 12,
            runSpacing: 12,
            children: [
              _GoalTimerChip(
                label: '5m',
                isSelected: _selectedGoalMinutes == 5,
                onTap: () => _setGoalTimer(5),
              ),
              _GoalTimerChip(
                label: '10m',
                isSelected: _selectedGoalMinutes == 10,
                onTap: () => _setGoalTimer(10),
              ),
              _GoalTimerChip(
                label: '40m',
                isSelected: _selectedGoalMinutes == 40,
                onTap: () => _setGoalTimer(40),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class _TimerControlButton extends StatelessWidget {
  const _TimerControlButton(
      {required this.label, this.isPrimary = false, this.onPressed});

  final String label;
  final bool isPrimary;
  final VoidCallback? onPressed;

  @override
  Widget build(BuildContext context) {
    final BorderRadius radius = BorderRadius.circular(14);

    if (isPrimary) {
      return SizedBox(
        width: 120,
        height: 48,
        child: ElevatedButton(
          style: ElevatedButton.styleFrom(
            backgroundColor: _coachToolsSecondaryBlue,
            foregroundColor: Colors.white,
            shape: RoundedRectangleBorder(borderRadius: radius),
            elevation: 0,
            textStyle:
                const TextStyle(fontSize: 15, fontWeight: FontWeight.w600),
          ),
          onPressed: onPressed,
          child: Text(label),
        ),
      );
    }

    return SizedBox(
      width: 120,
      height: 48,
      child: OutlinedButton(
        style: OutlinedButton.styleFrom(
          foregroundColor: _coachToolsTitleColor,
          side: const BorderSide(color: _coachToolsBorderColor),
          shape: RoundedRectangleBorder(borderRadius: radius),
          textStyle: const TextStyle(fontSize: 15, fontWeight: FontWeight.w600),
        ),
        onPressed: onPressed,
        child: Text(label),
      ),
    );
  }
}

class _GoalTimerChip extends StatelessWidget {
  const _GoalTimerChip(
      {required this.label, this.isSelected = false, this.onTap});

  final String label;
  final bool isSelected;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 88,
      height: 48,
      child: OutlinedButton(
        style: OutlinedButton.styleFrom(
          foregroundColor: isSelected ? Colors.white : _coachToolsTitleColor,
          backgroundColor:
              isSelected ? _coachToolsSecondaryBlue : Colors.transparent,
          side: BorderSide(
              color: isSelected
                  ? _coachToolsSecondaryBlue
                  : _coachToolsBorderColor),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
          textStyle: const TextStyle(fontSize: 14, fontWeight: FontWeight.w600),
        ),
        onPressed: onTap,
        child: Text(label),
      ),
    );
  }
}

class _SessionDetailsCard extends StatefulWidget {
  const _SessionDetailsCard();

  @override
  State<_SessionDetailsCard> createState() => _SessionDetailsCardState();
}

class _SessionDetailsCardState extends State<_SessionDetailsCard> {
  static const TextStyle _sectionTitleStyle = TextStyle(
    color: _coachToolsTitleColor,
    fontSize: 18,
    fontWeight: FontWeight.w700,
  );

  static const TextStyle _fieldLabelStyle = TextStyle(
    color: _coachToolsTitleColor,
    fontSize: 14,
    fontWeight: FontWeight.w600,
  );

  final _sessionTypeController = TextEditingController();
  final _sessionFocusController = TextEditingController();
  String? _selectedMemberId;
  String? _selectedMemberName;
  DateTime? _sessionDate;
  bool _isLoading = false;
  List<Map<String, dynamic>> _members = [];

  @override
  void initState() {
    super.initState();
    _loadMembers();
  }

  @override
  void dispose() {
    _sessionTypeController.dispose();
    _sessionFocusController.dispose();
    super.dispose();
  }

  Future<void> _loadMembers() async {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) return;

    try {
      final currentUserRef = FirebaseFirestore.instance
          .collection('users')
          .doc(currentUser.uid);

      // Query member_coach collection for documents where coach is current user
      var coachDocs = await FirebaseFirestore.instance
          .collection('member_coach')
          .where('coachref', isEqualTo: currentUserRef)
          .get();

      // Also check for 'coach' field as a fallback
      if (coachDocs.docs.isEmpty) {
        coachDocs = await FirebaseFirestore.instance
            .collection('member_coach')
            .where('coach', isEqualTo: currentUserRef)
            .get();
      }

      final Set<String> memberIds = {};

      // Extract member IDs from all matching coach documents
      for (final coachDoc in coachDocs.docs) {
        final data = coachDoc.data();
        
        // Handle single member reference (legacy)
        final memberRef = data['memberref'] as DocumentReference?
            ?? data['member'] as DocumentReference?;
        if (memberRef != null) {
          memberIds.add(memberRef.id);
        }

        // Handle multiple members assigned (current structure)
        final membersAssigned = data['membersAssigned'] as List<dynamic>?;
        if (membersAssigned != null) {
          for (final memberRefItem in membersAssigned) {
            if (memberRefItem is DocumentReference) {
              memberIds.add(memberRefItem.id);
            }
          }
        }
      }

      // Fetch user details for each member
      final List<Map<String, dynamic>> members = [];
      for (final memberId in memberIds) {
        try {
          final memberDoc = await FirebaseFirestore.instance
              .collection('users')
              .doc(memberId)
              .get();
          
          if (memberDoc.exists) {
            final data = memberDoc.data()!;
            final firstName = data['firstName'] as String? ?? '';
            final lastName = data['lastName'] as String? ?? '';
            final displayName =
                data['displayName'] as String? ?? '$firstName $lastName'.trim();
            members.add({
              'id': memberId,
              'name': displayName.isNotEmpty ? displayName : 'Member',
            });
          }
        } catch (e) {
          debugPrint('Error loading member $memberId: $e');
        }
      }

      if (mounted) {
        setState(() {
          _members = members;
        });
      }
    } catch (e) {
      debugPrint('Error loading members: $e');
      if (mounted) {
        setState(() {
          _members = [];
        });
      }
    }
  }

  Future<void> _selectDate() async {
    final now = DateTime.now();
    final picked = await showDatePicker(
      context: context,
      initialDate: _sessionDate ?? now,
      firstDate: now.subtract(const Duration(days: 365)),
      lastDate: now.add(const Duration(days: 365)),
    );
    if (picked != null && mounted) {
      setState(() => _sessionDate = picked);
    }
  }

  Future<void> _generateSessionNote() async {
    if (_sessionFocusController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter session focus')),
      );
      return;
    }

    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please sign in to generate notes')),
      );
      return;
    }

    setState(() => _isLoading = true);

    try {
      final sessionType = _sessionTypeController.text.trim().isNotEmpty
          ? _sessionTypeController.text.trim()
          : 'Coaching Session';
      final sessionFocus = _sessionFocusController.text.trim();
      final dateStr = _sessionDate != null
          ? '${_sessionDate!.month}/${_sessionDate!.day}/${_sessionDate!.year}'
          : 'Today';

      // Generate a session note content
      final noteContent = '''Session Date: $dateStr
Session Type: $sessionType
Focus Areas: $sessionFocus

Key Discussion Points:
‚Ä¢ Review of progress since last session
‚Ä¢ Current challenges and opportunities
‚Ä¢ Action items and next steps

Next Steps:
‚Ä¢ Follow up on discussed items
‚Ä¢ Schedule next session''';

      // Save to coachingNotes collection
      await FirebaseFirestore.instance.collection('coachingNotes').add({
        'title': 'Session Note - $sessionType',
        'content': noteContent,
        'coachId': currentUser.uid,
        'memberId': _selectedMemberId,
        'memberName': _selectedMemberName ?? 'Unknown',
        'noteType': 'Session Note',
        'tag': sessionType,
        'isDraft': false,
        'sessionDate':
            _sessionDate != null ? Timestamp.fromDate(_sessionDate!) : null,
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      });

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Session note generated and saved'),
            backgroundColor: Color(0xFF22C55E),
          ),
        );
        // Clear form
        _sessionTypeController.clear();
        _sessionFocusController.clear();
        setState(() {
          _selectedMemberId = null;
          _selectedMemberName = null;
          _sessionDate = null;
        });
      }
    } catch (e) {
      debugPrint('Error generating session note: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to generate note: $e')),
        );
      }
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: _coachToolsCardDecoration(),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          ClipRRect(
            borderRadius: const BorderRadius.vertical(top: Radius.circular(24)),
            child: Container(
              width: double.infinity,
              color: const Color(0xFFF1F2F7),
              padding: const EdgeInsets.symmetric(vertical: 16),
              child: const Center(
                child: Text(
                  'Session Timer',
                  style: TextStyle(
                    color: _coachToolsTitleColor,
                    fontSize: 16,
                    fontWeight: FontWeight.w700,
                  ),
                ),
              ),
            ),
          ),
          Padding(
            padding: const EdgeInsets.fromLTRB(28, 24, 28, 32),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text('Session Details', style: _sectionTitleStyle),
                const SizedBox(height: 20),
                const Text('Member', style: _fieldLabelStyle),
                const SizedBox(height: 10),
                DropdownButtonFormField<String>(
                  value: _selectedMemberId,
                  items: _members
                      .map((m) => DropdownMenuItem(
                            value: m['id'] as String,
                            child: Text(m['name'] as String),
                          ))
                      .toList(),
                  onChanged: (value) {
                    final member = _members.firstWhere((m) => m['id'] == value,
                        orElse: () => {});
                    setState(() {
                      _selectedMemberId = value;
                      _selectedMemberName = member['name'] as String?;
                    });
                  },
                  decoration: _coachToolsInputDecoration('Select member'),
                ),
                const SizedBox(height: 20),
                const Text('Session Type', style: _fieldLabelStyle),
                const SizedBox(height: 10),
                TextFormField(
                  controller: _sessionTypeController,
                  decoration: _coachToolsInputDecoration(
                      'e.g., Check-in, Strategy, Review'),
                ),
                const SizedBox(height: 20),
                const Text('Session Focus', style: _fieldLabelStyle),
                const SizedBox(height: 10),
                TextFormField(
                  controller: _sessionFocusController,
                  minLines: 3,
                  maxLines: 5,
                  decoration: _coachToolsInputDecoration(
                      'Key areas to focus on during this session'),
                ),
                const SizedBox(height: 24),
                GestureDetector(
                  onTap: _selectDate,
                  child: AbsorbPointer(
                    child: SizedBox(
                      width: 180,
                      child: TextFormField(
                        readOnly: true,
                        decoration: _coachToolsInputDecoration(
                          _sessionDate != null
                              ? '${_sessionDate!.month}/${_sessionDate!.day}/${_sessionDate!.year}'
                              : 'MM/DD/YYYY',
                        ).copyWith(
                          prefixIcon: const Icon(Icons.calendar_today_outlined,
                              color: _coachToolsMutedColor, size: 18),
                          contentPadding: const EdgeInsets.symmetric(
                              horizontal: 16, vertical: 14),
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 20),
                SizedBox(
                  width: double.infinity,
                  height: 54,
                  child: ElevatedButton(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: _coachToolsSecondaryBlue,
                      foregroundColor: Colors.white,
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(16)),
                      textStyle: const TextStyle(
                          fontSize: 16, fontWeight: FontWeight.w700),
                      elevation: 0,
                    ),
                    onPressed: _isLoading ? null : _generateSessionNote,
                    child: _isLoading
                        ? const SizedBox(
                            width: 24,
                            height: 24,
                            child: CircularProgressIndicator(
                                color: Colors.white, strokeWidth: 2))
                        : const Text('Generate Session Note'),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _TimeManagementTipsCard extends StatelessWidget {
  const _TimeManagementTipsCard();

  static const List<String> _tips = [
    '5min: Opening and check-in',
    '40min: Core coaching conversation',
    '10min: Action planning',
    '5min: Closing and next steps',
  ];

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
      decoration: _coachToolsCardDecoration(),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Time Management Tips',
            style: TextStyle(
              color: _coachToolsTitleColor,
              fontSize: 18,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 20),
          ..._tips.map(
            (tip) => Padding(
              padding: const EdgeInsets.only(bottom: 14),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Icon(Icons.access_time,
                      color: _coachToolsSecondaryBlue, size: 18),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      tip,
                      style: const TextStyle(
                        color: _coachToolsTitleColor,
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _SmartGoalChecklistCard extends StatelessWidget {
  const _SmartGoalChecklistCard();

  static const List<_ChecklistItem> _items = [
    _ChecklistItem(
        title: 'Specific', description: 'The goal is clear and specific'),
    _ChecklistItem(
        title: 'Measurable',
        description: 'Progress can be tracked and measured'),
    _ChecklistItem(
        title: 'Achievable',
        description: 'The goal is realistic and attainable'),
    _ChecklistItem(
        title: 'Relevant',
        description: 'The goal aligns with broader objectives'),
    _ChecklistItem(title: 'Time-bound', description: 'The goal has a deadline'),
  ];

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
      decoration: _coachToolsCardDecoration(),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'SMART GOAL CHECKLIST',
            style: TextStyle(
              color: _coachToolsTitleColor,
              fontSize: 16,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 6),
          const Text(
            'Ensure your goal meets the SMART criteria',
            style: TextStyle(
              color: _coachToolsMutedColor,
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 20),
          ..._items.map(
            (item) => Padding(
              padding: const EdgeInsets.only(bottom: 16),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Icon(Icons.check_circle, color: Color(0xFF22C55E)),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          item.title,
                          style: const TextStyle(
                            color: _coachToolsTitleColor,
                            fontSize: 15,
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          item.description,
                          style: const TextStyle(
                            color: _coachToolsMutedColor,
                            fontSize: 13,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _GoalTipCard extends StatelessWidget {
  const _GoalTipCard();

  static const List<String> _tips = [
    'Break large goals into smaller milestones',
    'Include a methode to track progress',
    'Set specificcheck-in dates',
    'Identify potential obstacle in advance',
  ];

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
      decoration: _coachToolsCardDecoration(),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Goal Tip',
            style: TextStyle(
              color: _coachToolsTitleColor,
              fontSize: 16,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 20),
          ..._tips.map(
            (tip) => Padding(
              padding: const EdgeInsets.only(bottom: 16),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Icon(Icons.lightbulb_outline, color: Color(0xFFF59E0B)),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      tip,
                      style: const TextStyle(
                        color: _coachToolsTitleColor,
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _ChecklistItem {
  const _ChecklistItem({required this.title, required this.description});

  final String title;
  final String description;
}

// Shared Coaching Notes page colors
const Color kCoachNotesTitleColor = Color(0xFF111827);
const Color kCoachNotesTabBorder = Color(0xFFE5E7EB);
const Color kCoachNotesTabBackground = Color(0xFFF5F6FA);
const Color kCoachNotesTabActiveBackground = Colors.white;
const Color kCoachNotesTabInactiveText = Color(0xFF6B7280);

class CoachCoachingNotesPage extends StatefulWidget {
  const CoachCoachingNotesPage({super.key});

  @override
  State<CoachCoachingNotesPage> createState() => _CoachCoachingNotesPageState();
}

class _CoachCoachingNotesPageState extends State<CoachCoachingNotesPage> {
  int _selectedTabIndex = 0; // 0 = All Notes, 1 = Drafts

  @override
  void dispose() {
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final double horizontalPadding =
            constraints.maxWidth > 1180 ? 60.0 : 32.0;

        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  const Expanded(
                    child: Text(
                      'Coaching Notes',
                      style: TextStyle(
                        color: kCoachNotesTitleColor,
                        fontSize: 24,
                        fontWeight: FontWeight.w700,
                      ),
                    ),
                  ),
                  ElevatedButton.icon(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF2563EB),
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(
                          horizontal: 24, vertical: 16),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(14)),
                      elevation: 0,
                    ),
                    onPressed: () => _showCreateNoteDialog(context),
                    icon: const Icon(Icons.add),
                    label: const Text(
                      'Create Note',
                      style:
                          TextStyle(fontWeight: FontWeight.w600, fontSize: 15),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 24),
              Container(
                decoration: BoxDecoration(
                  color: kCoachNotesTabBackground,
                  borderRadius: BorderRadius.circular(14),
                  border: Border.all(color: kCoachNotesTabBorder),
                ),
                child: Row(
                  children: [
                    Expanded(
                      child: InkWell(
                        onTap: () => setState(() => _selectedTabIndex = 0),
                        borderRadius: BorderRadius.circular(14),
                        child: _CoachNotesTab(
                            label: 'All Notes',
                            isActive: _selectedTabIndex == 0),
                      ),
                    ),
                    const SizedBox(
                      height: 48,
                      child: VerticalDivider(
                          color: kCoachNotesTabBorder, thickness: 1, width: 1),
                    ),
                    Expanded(
                      child: InkWell(
                        onTap: () => setState(() => _selectedTabIndex = 1),
                        borderRadius: BorderRadius.circular(14),
                        child: _CoachNotesTab(
                            label: 'Drafts', isActive: _selectedTabIndex == 1),
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 32),
              // Notes list
              _buildNotesList(),
            ],
          ),
        );
      },
    );
  }

  Widget _buildNotesList() {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      return const Center(child: Text('Please sign in to view notes'));
    }

    final bool showDraftsOnly = _selectedTabIndex == 1;

    return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
      stream: FirebaseFirestore.instance
          .collection('coachingNotes')
          .where('coachId', isEqualTo: currentUser.uid)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(
              child: Padding(
                  padding: EdgeInsets.all(32),
                  child: CircularProgressIndicator()));
        }

        if (snapshot.hasError) {
          debugPrint('Error loading coaching notes: ${snapshot.error}');
          return Center(
            child: Padding(
              padding: const EdgeInsets.all(32),
              child: Text('Error loading notes: ${snapshot.error}',
                  style: const TextStyle(color: Colors.red)),
            ),
          );
        }

        final allDocs = snapshot.data?.docs ?? [];

        // Sort client-side to avoid needing a composite index
        allDocs.sort((a, b) {
          final aCreatedAt = a.data()['createdAt'];
          final bCreatedAt = b.data()['createdAt'];
          if (aCreatedAt == null && bCreatedAt == null) return 0;
          if (aCreatedAt == null) return 1;
          if (bCreatedAt == null) return -1;
          final aDate =
              aCreatedAt is Timestamp ? aCreatedAt.toDate() : DateTime.now();
          final bDate =
              bCreatedAt is Timestamp ? bCreatedAt.toDate() : DateTime.now();
          return bDate.compareTo(aDate); // Descending order
        });

        final filteredDocs = showDraftsOnly
            ? allDocs.where((doc) => doc.data()['isDraft'] == true).toList()
            : allDocs;

        if (filteredDocs.isEmpty) {
          return Container(
            padding: const EdgeInsets.all(48),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(16),
              border: Border.all(color: kCoachNotesTabBorder),
            ),
            child: Center(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    showDraftsOnly
                        ? Icons.drafts_outlined
                        : Icons.note_alt_outlined,
                    size: 48,
                    color: const Color(0xFF9CA3AF),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    showDraftsOnly
                        ? 'No draft notes yet'
                        : 'No coaching notes yet',
                    style: const TextStyle(
                      color: Color(0xFF6B7280),
                      fontSize: 16,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    showDraftsOnly
                        ? 'Draft notes will appear here when you save them'
                        : 'Create your first coaching note to get started',
                    style:
                        const TextStyle(color: Color(0xFF9CA3AF), fontSize: 14),
                  ),
                ],
              ),
            ),
          );
        }

        return Column(
          children: filteredDocs.map((doc) {
            final data = doc.data();
            final title = data['title'] as String? ?? 'Untitled';
            final content = data['content'] as String? ?? '';
            final isDraft = data['isDraft'] as bool? ?? false;
            final noteType = data['noteType'] as String? ?? '';
            final tag = data['tag'] as String? ?? '';
            final memberName = data['memberName'] as String? ?? 'Unknown';
            final createdAt = data['createdAt'];
            DateTime? createdDate;
            if (createdAt is Timestamp) {
              createdDate = createdAt.toDate();
            }

            return Container(
              margin: const EdgeInsets.only(bottom: 16),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(16),
                border: Border.all(color: kCoachNotesTabBorder),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withValues(alpha: 0.04),
                    blurRadius: 8,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: InkWell(
                onTap: () => _showNoteDetail(doc.id, data),
                borderRadius: BorderRadius.circular(16),
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Expanded(
                            child: Text(
                              title,
                              style: const TextStyle(
                                color: kCoachNotesTitleColor,
                                fontSize: 16,
                                fontWeight: FontWeight.w700,
                              ),
                            ),
                          ),
                          if (isDraft)
                            Container(
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 10, vertical: 4),
                              decoration: BoxDecoration(
                                color: const Color(0xFFFEF3C7),
                                borderRadius: BorderRadius.circular(8),
                              ),
                              child: const Text(
                                'Draft',
                                style: TextStyle(
                                  color: Color(0xFFD97706),
                                  fontSize: 12,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                            ),
                          const SizedBox(width: 8),
                          IconButton(
                            onPressed: () => _deleteNote(doc.id),
                            icon: const Icon(Icons.delete_outline, size: 20),
                            color: Colors.red.shade400,
                            tooltip: 'Delete note',
                          ),
                        ],
                      ),
                      const SizedBox(height: 8),
                      Text(
                        content.length > 120
                            ? '${content.substring(0, 120)}...'
                            : content,
                        style: const TextStyle(
                          color: Color(0xFF6B7280),
                          fontSize: 14,
                          height: 1.5,
                        ),
                      ),
                      const SizedBox(height: 12),
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: [
                          _NoteInfoChip(
                              icon: Icons.person_outline, label: memberName),
                          if (noteType.isNotEmpty)
                            _NoteInfoChip(
                                icon: Icons.category_outlined, label: noteType),
                          if (tag.isNotEmpty)
                            _NoteInfoChip(
                                icon: Icons.label_outline, label: tag),
                          if (createdDate != null)
                            _NoteInfoChip(
                              icon: Icons.schedule,
                              label:
                                  DateFormat('MMM d, yyyy').format(createdDate),
                            ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            );
          }).toList(),
        );
      },
    );
  }

  void _showCreateNoteDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => const _CreateNoteDialog(),
    );
  }

  void _showNoteDetail(String noteId, Map<String, dynamic> data) {
    showDialog(
      context: context,
      builder: (context) => _NoteDetailDialog(noteId: noteId, data: data),
    );
  }

  Future<void> _deleteNote(String noteId) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Note'),
        content: const Text(
            'Are you sure you want to delete this note? This action cannot be undone.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            child: const Text('Delete', style: TextStyle(color: Colors.white)),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      try {
        await FirebaseFirestore.instance
            .collection('coachingNotes')
            .doc(noteId)
            .delete();
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Note deleted successfully')),
          );
        }
      } catch (e) {
        debugPrint('Error deleting note: $e');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error deleting note: $e')),
          );
        }
      }
    }
  }
}

class _NoteInfoChip extends StatelessWidget {
  const _NoteInfoChip({required this.icon, required this.label});

  final IconData icon;
  final String label;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: const Color(0xFFF3F4F6),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 14, color: const Color(0xFF6B7280)),
          const SizedBox(width: 6),
          Text(
            label,
            style: const TextStyle(
              color: Color(0xFF6B7280),
              fontSize: 12,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }
}

class _NoteDetailDialog extends StatelessWidget {
  const _NoteDetailDialog({required this.noteId, required this.data});

  final String noteId;
  final Map<String, dynamic> data;

  @override
  Widget build(BuildContext context) {
    final title = data['title'] as String? ?? 'Untitled';
    final content = data['content'] as String? ?? '';
    final isDraft = data['isDraft'] as bool? ?? false;
    final noteType = data['noteType'] as String? ?? '';
    final tag = data['tag'] as String? ?? '';
    final memberName = data['memberName'] as String? ?? 'Unknown';

    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      child: Container(
        width: 600,
        constraints: const BoxConstraints(maxHeight: 600),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(24),
              decoration: const BoxDecoration(
                color: Color(0xFF2563EB),
                borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
              ),
              child: Row(
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Expanded(
                              child: Text(
                                title,
                                style: const TextStyle(
                                    color: Colors.white,
                                    fontSize: 20,
                                    fontWeight: FontWeight.w700),
                              ),
                            ),
                            if (isDraft)
                              Container(
                                padding: const EdgeInsets.symmetric(
                                    horizontal: 10, vertical: 4),
                                decoration: BoxDecoration(
                                  color: Colors.white.withValues(alpha: 0.2),
                                  borderRadius: BorderRadius.circular(8),
                                ),
                                child: const Text(
                                  'Draft',
                                  style: TextStyle(
                                      color: Colors.white,
                                      fontSize: 12,
                                      fontWeight: FontWeight.w600),
                                ),
                              ),
                          ],
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'For: $memberName',
                          style: const TextStyle(
                              color: Colors.white70, fontSize: 14),
                        ),
                      ],
                    ),
                  ),
                  IconButton(
                    onPressed: () => Navigator.of(context).pop(),
                    icon: const Icon(Icons.close, color: Colors.white),
                  ),
                ],
              ),
            ),
            Flexible(
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(24),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    if (noteType.isNotEmpty || tag.isNotEmpty) ...[
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: [
                          if (noteType.isNotEmpty)
                            Chip(
                              label: Text(noteType),
                              backgroundColor: const Color(0xFFEEF2FF),
                              labelStyle: const TextStyle(
                                  color: Color(0xFF4F46E5), fontSize: 12),
                            ),
                          if (tag.isNotEmpty)
                            Chip(
                              label: Text(tag),
                              backgroundColor: const Color(0xFFF0FDF4),
                              labelStyle: const TextStyle(
                                  color: Color(0xFF16A34A), fontSize: 12),
                            ),
                        ],
                      ),
                      const SizedBox(height: 20),
                    ],
                    const Text(
                      'Note Content',
                      style: TextStyle(
                          color: Color(0xFF374151),
                          fontSize: 14,
                          fontWeight: FontWeight.w600),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      content.isNotEmpty ? content : 'No content',
                      style: const TextStyle(
                          color: Color(0xFF6B7280), fontSize: 14, height: 1.6),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _CoachNotesTab extends StatelessWidget {
  const _CoachNotesTab({required this.label, this.isActive = false});

  final String label;
  final bool isActive;

  @override
  Widget build(BuildContext context) {
    final Color background =
        isActive ? kCoachNotesTabActiveBackground : Colors.transparent;
    final Color textColor =
        isActive ? kCoachNotesTitleColor : kCoachNotesTabInactiveText;

    return Container(
      decoration: BoxDecoration(
        color: background,
        borderRadius: BorderRadius.circular(14),
      ),
      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 18),
      alignment: Alignment.centerLeft,
      child: Text(
        label,
        style: TextStyle(
          color: textColor,
          fontSize: 15,
          fontWeight: isActive ? FontWeight.w700 : FontWeight.w600,
        ),
      ),
    );
  }
}

class _CreateNoteDialog extends StatefulWidget {
  const _CreateNoteDialog();

  @override
  State<_CreateNoteDialog> createState() => _CreateNoteDialogState();
}

class _CreateNoteDialogState extends State<_CreateNoteDialog> {
  final _titleController = TextEditingController();
  final _contentController = TextEditingController();
  String? _selectedMemberId;
  String? _selectedNoteType;
  String? _selectedTag;

  List<Map<String, String>> _members = [];
  bool _isLoadingMembers = true;
  final List<String> _noteTypes = [
    'Session Note',
    'Progress Note',
    'Assessment',
    'Development Plan'
  ];
  final List<String> _tags = ['Leadership', 'Delegation', 'Team Management'];

  @override
  void initState() {
    super.initState();
    _loadAssignedMembers();
  }

  Future<void> _loadAssignedMembers() async {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      setState(() => _isLoadingMembers = false);
      return;
    }

    try {
      final currentUserRef = FirebaseFirestore.instance
          .collection('users')
          .doc(currentUser.uid);

      // Query member_coach collection for documents where coach is current user
      var coachDocs = await FirebaseFirestore.instance
          .collection('member_coach')
          .where('coachref', isEqualTo: currentUserRef)
          .get();

      // Also check for 'coach' field as a fallback
      if (coachDocs.docs.isEmpty) {
        coachDocs = await FirebaseFirestore.instance
            .collection('member_coach')
            .where('coach', isEqualTo: currentUserRef)
            .get();
      }

      final Set<String> memberIds = {};

      // Extract member IDs from all matching coach documents
      for (final coachDoc in coachDocs.docs) {
        final data = coachDoc.data();
        
        // Handle single member reference (legacy)
        final memberRef = data['memberref'] as DocumentReference?
            ?? data['member'] as DocumentReference?;
        if (memberRef != null) {
          memberIds.add(memberRef.id);
        }

        // Handle multiple members assigned (current structure)
        final membersAssigned = data['membersAssigned'] as List<dynamic>?;
        if (membersAssigned != null) {
          for (final memberRefItem in membersAssigned) {
            if (memberRefItem is DocumentReference) {
              memberIds.add(memberRefItem.id);
            }
          }
        }
      }

      // Fetch user details for each member
      final members = <Map<String, String>>[];
      for (final memberId in memberIds) {
        try {
          final memberDoc = await FirebaseFirestore.instance
              .collection('users')
              .doc(memberId)
              .get();
          
          if (memberDoc.exists) {
            final data = memberDoc.data()!;
            final firstName = data['firstName'] as String? ?? '';
            final lastName = data['lastName'] as String? ?? '';
            final fullName = '$firstName $lastName'.trim();
            if (fullName.isNotEmpty) {
              members.add({'id': memberId, 'name': fullName});
            }
          }
        } catch (e) {
          debugPrint('Error loading member $memberId: $e');
        }
      }

      setState(() {
        _members = members;
        _isLoadingMembers = false;
      });
    } catch (e) {
      debugPrint('Error loading members: $e');
      setState(() => _isLoadingMembers = false);
    }
  }

  @override
  void dispose() {
    _titleController.dispose();
    _contentController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      child: Container(
        width: 600,
        constraints: const BoxConstraints(maxHeight: 700),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(24),
              decoration: const BoxDecoration(
                color: Color(0xFF2563EB),
                borderRadius: BorderRadius.only(
                    topLeft: Radius.circular(20),
                    topRight: Radius.circular(20)),
              ),
              child: Row(
                children: [
                  const Expanded(
                    child: Text(
                      'Create Note',
                      style: TextStyle(
                          color: Colors.white,
                          fontSize: 20,
                          fontWeight: FontWeight.w700),
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close, color: Colors.white),
                    onPressed: () => Navigator.of(context).pop(),
                  ),
                ],
              ),
            ),
            Flexible(
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(24),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    _buildLabel('Title'),
                    const SizedBox(height: 8),
                    TextField(
                      controller: _titleController,
                      decoration: _inputDecoration('Enter note title'),
                    ),
                    const SizedBox(height: 20),
                    _buildLabel('Member'),
                    const SizedBox(height: 8),
                    _isLoadingMembers
                        ? Container(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 16, vertical: 14),
                            decoration: BoxDecoration(
                              border:
                                  Border.all(color: const Color(0xFFE5E7EB)),
                              borderRadius: BorderRadius.circular(12),
                            ),
                            child: const Row(
                              children: [
                                SizedBox(
                                  width: 16,
                                  height: 16,
                                  child:
                                      CircularProgressIndicator(strokeWidth: 2),
                                ),
                                SizedBox(width: 12),
                                Text('Loading members...',
                                    style: TextStyle(color: Color(0xFF9CA3AF))),
                              ],
                            ),
                          )
                        : DropdownButtonFormField<String>(
                            value: _selectedMemberId,
                            decoration: _inputDecoration(_members.isEmpty
                                ? 'No members assigned'
                                : 'Select member'),
                            items: _members
                                .map((member) => DropdownMenuItem(
                                      value: member['id'],
                                      child: Text(member['name']!),
                                    ))
                                .toList(),
                            onChanged: _members.isEmpty
                                ? null
                                : (value) =>
                                    setState(() => _selectedMemberId = value),
                          ),
                    const SizedBox(height: 20),
                    _buildLabel('Note Type'),
                    const SizedBox(height: 8),
                    DropdownButtonFormField<String>(
                      value: _selectedNoteType,
                      decoration: _inputDecoration('Select note type'),
                      items: _noteTypes
                          .map((type) =>
                              DropdownMenuItem(value: type, child: Text(type)))
                          .toList(),
                      onChanged: (value) =>
                          setState(() => _selectedNoteType = value),
                    ),
                    const SizedBox(height: 20),
                    _buildLabel('Tags'),
                    const SizedBox(height: 8),
                    DropdownButtonFormField<String>(
                      value: _selectedTag,
                      decoration: _inputDecoration('Select tag'),
                      items: _tags
                          .map((tag) =>
                              DropdownMenuItem(value: tag, child: Text(tag)))
                          .toList(),
                      onChanged: (value) =>
                          setState(() => _selectedTag = value),
                    ),
                    const SizedBox(height: 20),
                    _buildLabel('Content'),
                    const SizedBox(height: 8),
                    TextField(
                      controller: _contentController,
                      decoration: _inputDecoration('Enter note content'),
                      maxLines: 6,
                    ),
                    const SizedBox(height: 32),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        OutlinedButton(
                          style: OutlinedButton.styleFrom(
                            side: const BorderSide(color: Color(0xFF2563EB)),
                            foregroundColor: const Color(0xFF2563EB),
                            padding: const EdgeInsets.symmetric(
                                horizontal: 24, vertical: 16),
                            shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(12)),
                          ),
                          onPressed: () => _saveNote(isDraft: true),
                          child: const Text('Save As Draft',
                              style: TextStyle(fontWeight: FontWeight.w600)),
                        ),
                        const SizedBox(width: 12),
                        ElevatedButton(
                          style: ElevatedButton.styleFrom(
                            backgroundColor: const Color(0xFF2563EB),
                            foregroundColor: Colors.white,
                            padding: const EdgeInsets.symmetric(
                                horizontal: 32, vertical: 16),
                            shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(12)),
                            elevation: 0,
                          ),
                          onPressed: () => _saveNote(isDraft: false),
                          child: const Text('Save',
                              style: TextStyle(fontWeight: FontWeight.w600)),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildLabel(String text) => Text(text,
      style: const TextStyle(
          color: Color(0xFF374151), fontSize: 14, fontWeight: FontWeight.w600));

  InputDecoration _inputDecoration(String hint) => InputDecoration(
        hintText: hint,
        hintStyle: const TextStyle(color: Color(0xFF9CA3AF)),
        border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: Color(0xFFE5E7EB))),
        enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: Color(0xFFE5E7EB))),
        focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: Color(0xFF2563EB), width: 2)),
        contentPadding:
            const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      );

  Future<void> _saveNote({required bool isDraft}) async {
    if (_titleController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context)
          .showSnackBar(const SnackBar(content: Text('Please enter a title')));
      return;
    }

    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Please sign in to save notes')));
      return;
    }

    try {
      // Get member name if selected
      String memberName = 'Unknown';
      if (_selectedMemberId != null) {
        final member = _members.firstWhere(
          (m) => m['id'] == _selectedMemberId,
          orElse: () => {'name': 'Unknown'},
        );
        memberName = member['name'] ?? 'Unknown';
      }

      await FirebaseFirestore.instance.collection('coachingNotes').add({
        'title': _titleController.text.trim(),
        'content': _contentController.text.trim(),
        'coachId': currentUser.uid,
        'memberId': _selectedMemberId,
        'memberName': memberName,
        'noteType': _selectedNoteType ?? '',
        'tag': _selectedTag ?? '',
        'isDraft': isDraft,
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      });

      debugPrint(
          'Note saved successfully: isDraft=$isDraft, title=${_titleController.text.trim()}');

      if (mounted) {
        Navigator.of(context).pop();
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text(
                  isDraft ? 'Note saved as draft' : 'Note saved successfully')),
        );
      }
    } catch (e) {
      debugPrint('Error saving note: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error saving note: $e')),
        );
      }
    }
  }
}

class CoachPlaceholderPage extends StatelessWidget {
  const CoachPlaceholderPage({super.key, required this.title});

  final String title;

  @override
  Widget build(BuildContext context) {
    final double width = MediaQuery.of(context).size.width;
    final double horizontalPadding = width > 1180 ? 56.0 : 32.0;

    return SingleChildScrollView(
      padding:
          EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: const TextStyle(
              color: Color(0xFF111827),
              fontSize: 24,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 16),
          const Text(
            'Design for this section has not been provided yet.',
            style: TextStyle(
              color: Color(0xFF6B7280),
              fontSize: 15,
            ),
          ),
        ],
      ),
    );
  }
}

class DashboardView extends StatelessWidget {
  const DashboardView({
    super.key,
    required this.activeTab,
    required this.onTabSelected,
    this.userProfile,
    this.userEmail,
  });

  static const Color _cardBorder = Color(0xFFE0E5F2);
  static const Color _muted = Color(0xFF6B7280);

  final DashboardTab activeTab;
  final ValueChanged<DashboardTab> onTabSelected;
  final Map<String, dynamic>? userProfile;
  final String? userEmail;

  String get _displayName {
    final profile = userProfile;
    // First, try first_name + last_name fields (snake_case and camelCase variants)
    final firstName = (profile?['first_name'] as String?)?.trim() ??
        (profile?['firstName'] as String?)?.trim();
    final lastName = (profile?['last_name'] as String?)?.trim() ??
        (profile?['lastName'] as String?)?.trim();
    final fullName = '${firstName ?? ''} ${lastName ?? ''}'.trim();
    if (fullName.isNotEmpty) return fullName;
    // Fallback to displayName if present
    final displayName = (profile?['displayName'] as String?)?.trim();
    if (displayName != null && displayName.isNotEmpty) return displayName;
    // Fallback to email handle
    final email = userEmail;
    if (email != null && email.isNotEmpty) {
      final handle = email.split('@');
      if (handle.isNotEmpty && handle.first.isNotEmpty) return handle.first;
    }
    return 'there';
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final horizontalPadding = constraints.maxWidth > 1200 ? 48.0 : 24.0;
        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 32),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: const [
                      Text(
                        'My Breakaway Journey',
                        style: TextStyle(
                          fontSize: 22,
                          fontWeight: FontWeight.w700,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
              const SizedBox(height: 24),
              Wrap(
                spacing: 16,
                runSpacing: 16,
                children: [
                  _TopNavChip(
                    label: 'Dashboard',
                    icon: Icons.dashboard_outlined,
                    isActive: activeTab == DashboardTab.overview,
                    activeColor: const Color(0xFF3B3B3B),
                    inactiveColor: const Color(0xFFF5A26C),
                    activeIcon: Icons.dashboard,
                    onTap: () => onTabSelected(DashboardTab.overview),
                  ),
                  _TopNavChip(
                    label: 'Learning Activity',
                    icon: Icons.star_border,
                    isActive: activeTab == DashboardTab.learningActivity,
                    activeColor: const Color(0xFF3B3B3B),
                    inactiveColor: const Color(0xFFF5A26C),
                    activeIcon: Icons.star,
                    onTap: () => onTabSelected(DashboardTab.learningActivity),
                  ),
                  _TopNavChip(
                    label: 'Skills & Competencies',
                    icon: Icons.settings_outlined,
                    isActive: activeTab == DashboardTab.skills,
                    activeColor: const Color(0xFF3B3B3B),
                    inactiveColor: const Color(0xFFF5A26C),
                    activeIcon: Icons.settings,
                    onTap: () => onTabSelected(DashboardTab.skills),
                  ),
                ],
              ),
              const SizedBox(height: 32),
              _buildTabContent(),
            ],
          ),
        );
      },
    );
  }

  Widget _buildTabContent() {
    switch (activeTab) {
      case DashboardTab.overview:
        return _OverviewTabContent(
          cardBorder: _cardBorder,
          muted: _muted,
          displayName: _displayName,
        );
      case DashboardTab.learningActivity:
        return _LearningActivityTabContent(displayName: _displayName);
      case DashboardTab.skills:
        return _SkillsCompetenciesTabContent(displayName: _displayName);
    }
  }
}

class _OverviewTabContent extends StatelessWidget {
  const _OverviewTabContent({
    required this.cardBorder,
    required this.muted,
    required this.displayName,
  });

  final Color cardBorder;
  final Color muted;
  final String displayName;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Welcome back $displayName!',
          style: const TextStyle(
            fontSize: 32,
            fontWeight: FontWeight.w700,
          ),
        ),
        const SizedBox(height: 4),
        Text(
          'Track your Learning Progress',
          style: TextStyle(
            color: muted,
            fontSize: 16,
          ),
        ),
        const SizedBox(height: 28),
        LayoutBuilder(
          builder: (context, innerConstraints) {
            final isNarrow = innerConstraints.maxWidth < 900;
            if (isNarrow) {
              return Column(
                children: [
                  _LevelCard(borderColor: cardBorder),
                  const SizedBox(height: 16),
                  _LearningTimeCard(borderColor: cardBorder),
                  const SizedBox(height: 16),
                  _StreakCard(borderColor: cardBorder),
                ],
              );
            }
            return IntrinsicHeight(
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Expanded(child: _LevelCard(borderColor: cardBorder)),
                  const SizedBox(width: 20),
                  Expanded(child: _LearningTimeCard(borderColor: cardBorder)),
                  const SizedBox(width: 20),
                  Expanded(child: _StreakCard(borderColor: cardBorder)),
                ],
              ),
            );
          },
        ),
        const SizedBox(height: 24),
        LayoutBuilder(
          builder: (context, innerConstraints) {
            final isStacked = innerConstraints.maxWidth < 1024;
            if (isStacked) {
              return Column(
                children: const [
                  _AchievementsCard(borderColor: DashboardView._cardBorder),
                  SizedBox(height: 16),
                  _ProgressByCategoryCard(
                      borderColor: DashboardView._cardBorder),
                ],
              );
            }
            return Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                    flex: 2, child: _AchievementsCard(borderColor: cardBorder)),
                const SizedBox(width: 20),
                Expanded(
                    child: _ProgressByCategoryCard(borderColor: cardBorder)),
              ],
            );
          },
        ),
      ],
    );
  }
}

class _LearningActivityTabContent extends StatefulWidget {
  const _LearningActivityTabContent({required this.displayName});

  static const Color _titleColor = Color(0xFF111827);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE5E7EB);

  final String displayName;

  @override
  State<_LearningActivityTabContent> createState() =>
      _LearningActivityTabContentState();
}

class _LearningActivityTabContentState
    extends State<_LearningActivityTabContent> {
  Future<LearningMetrics>? _metricsFuture;

  @override
  void initState() {
    super.initState();
    _load();
  }

  void _load() {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid != null) {
      setState(() {
        _metricsFuture = UsageMetricsService.loadMetrics(uid: uid);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final displayName = widget.displayName;
    return FutureBuilder<LearningMetrics>(
      future: _metricsFuture,
      builder: (context, snapshot) {
        final metrics = snapshot.data;
        final totalHoursText =
            metrics == null ? '0 Hours' : '${metrics.totalHoursAllTime} Hours';
        final avgWeeklyText = metrics == null
            ? '0 minutes'
            : '${metrics.averageWeeklyMinutesThisMonth} minutes';
        final activeDaysText =
            metrics == null ? '0' : '${metrics.activeDaysThisMonth}';

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Welcome back $displayName!',
              style: const TextStyle(
                fontSize: 32,
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 4),
            const Text(
              'Track your Learning Progress',
              style: TextStyle(
                color: _LearningActivityTabContent._mutedColor,
                fontSize: 16,
              ),
            ),
            const SizedBox(height: 24),
            Container(
              width: double.infinity,
              padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(20),
                border:
                    Border.all(color: _LearningActivityTabContent._borderColor),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.04),
                    blurRadius: 12,
                    offset: const Offset(0, 6),
                  ),
                ],
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Learning Activity',
                    style: TextStyle(
                      color: _LearningActivityTabContent._titleColor,
                      fontSize: 20,
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  const SizedBox(height: 6),
                  const Text(
                    'Track how much time you spend learning',
                    style: TextStyle(
                      color: _LearningActivityTabContent._mutedColor,
                      fontSize: 14,
                    ),
                  ),
                  const SizedBox(height: 24),
                  LayoutBuilder(
                    builder: (context, constraints) {
                      final isNarrow = constraints.maxWidth < 840;
                      final cards = [
                        _LearningActivityMetricCard(
                          icon: Icons.timelapse_outlined,
                          accentColor: const Color(0xFF5E81F4),
                          title: 'Total Learning Time',
                          subtitle: 'All-time',
                          value: totalHoursText,
                        ),
                        _LearningActivityMetricCard(
                          icon: Icons.check_circle_outline,
                          accentColor: const Color(0xFF11B981),
                          title: 'Average Weekly time',
                          subtitle: 'This month',
                          value: avgWeeklyText,
                        ),
                        _LearningActivityMetricCard(
                          icon: Icons.my_location_outlined,
                          accentColor: const Color(0xFF9D6BFF),
                          title: 'Active Days',
                          subtitle: 'This month',
                          value: activeDaysText,
                        ),
                      ];

                      if (isNarrow) {
                        return Column(
                          children: [
                            for (var i = 0; i < cards.length; i++) ...[
                              cards[i],
                              if (i != cards.length - 1)
                                const SizedBox(height: 16),
                            ],
                          ],
                        );
                      }

                      return Row(
                        children: [
                          Expanded(child: cards[0]),
                          const SizedBox(width: 20),
                          Expanded(child: cards[1]),
                          const SizedBox(width: 20),
                          Expanded(child: cards[2]),
                        ],
                      );
                    },
                  ),
                ],
              ),
            ),
          ],
        );
      },
    );
  }
}

class _LearningActivityMetricCard extends StatelessWidget {
  const _LearningActivityMetricCard({
    required this.icon,
    required this.accentColor,
    required this.title,
    required this.subtitle,
    required this.value,
  });

  final IconData icon;
  final Color accentColor;
  final String title;
  final String subtitle;
  final String value;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: _LearningActivityTabContent._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 10,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: accentColor.withOpacity(0.12),
            ),
            child: Icon(icon, color: accentColor, size: 26),
          ),
          const SizedBox(height: 18),
          Text(
            title,
            style: const TextStyle(
              color: _LearningActivityTabContent._titleColor,
              fontSize: 16,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            subtitle,
            style: const TextStyle(
              color: _LearningActivityTabContent._mutedColor,
              fontSize: 13,
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 28),
          Text(
            value,
            style: const TextStyle(
              color: _LearningActivityTabContent._titleColor,
              fontSize: 32,
              fontWeight: FontWeight.w700,
            ),
          ),
        ],
      ),
    );
  }
}

class _SkillsCompetenciesTabContent extends StatelessWidget {
  const _SkillsCompetenciesTabContent({required this.displayName});

  static const Color _titleColor = Color(0xFF111827);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE5E7EB);

  final String displayName;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Welcome back $displayName!',
          style: const TextStyle(
            fontSize: 32,
            fontWeight: FontWeight.w700,
          ),
        ),
        const SizedBox(height: 4),
        const Text(
          'Track your Learning Progress',
          style: TextStyle(
            color: _mutedColor,
            fontSize: 16,
          ),
        ),
        const SizedBox(height: 24),
        const _SkillsAssessmentCard(),
        const SizedBox(height: 24),
        const _RecommendedContentCard(),
      ],
    );
  }
}

class _SkillsAssessmentCard extends StatefulWidget {
  const _SkillsAssessmentCard();

  @override
  State<_SkillsAssessmentCard> createState() => _SkillsAssessmentCardState();
}

class _SkillsAssessmentCardState extends State<_SkillsAssessmentCard> {
  List<_SkillRowData> _rows = [
    const _SkillRowData(label: 'THINK', levelIndex: 0, progress: 0.0),
    const _SkillRowData(label: 'KEEP', levelIndex: 0, progress: 0.0),
    const _SkillRowData(label: 'ACCELERATE', levelIndex: 0, progress: 0.0),
    const _SkillRowData(label: 'TRANSFORM', levelIndex: 0, progress: 0.0),
  ];
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadProgress();
  }

  Future<void> _loadProgress() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) {
      if (mounted) setState(() => _isLoading = false);
      return;
    }

    try {
      final List<String> topics = ['THINK', 'KEEP', 'ACCELERATE', 'TRANSFORM'];
      final updatedRows = <_SkillRowData>[];

      for (final topic in topics) {
        // Get all courses with this topic
        final coursesSnapshot = await FirebaseFirestore.instance
            .collection('courses')
            .where('topic', isEqualTo: topic)
            .get();

        final totalCourses = coursesSnapshot.docs.length;

        if (totalCourses == 0) {
          updatedRows
              .add(_SkillRowData(label: topic, levelIndex: 0, progress: 0.0));
          continue;
        }

        // Get completed courses
        final completedSnapshot = await FirebaseFirestore.instance
            .collection('users')
            .doc(uid)
            .collection('completed_courses')
            .get();

        final completedIds =
            completedSnapshot.docs.map((doc) => doc.id).toSet();
        final topicCourseIds =
            coursesSnapshot.docs.map((doc) => doc.id).toSet();
        final completedCount =
            topicCourseIds.where((id) => completedIds.contains(id)).length;

        final progress = totalCourses > 0 ? completedCount / totalCourses : 0.0;
        int levelIndex = 0;
        if (progress >= 0.7) {
          levelIndex = 2; // Advanced
        } else if (progress >= 0.3) {
          levelIndex = 1; // Intermediate
        }

        updatedRows.add(_SkillRowData(
            label: topic, levelIndex: levelIndex, progress: progress));
      }

      if (mounted) {
        setState(() {
          _rows = updatedRows;
          _isLoading = false;
        });
      }
    } catch (e) {
      debugPrint('Failed to load skills progress: $e');
      if (mounted) setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: _SkillsCompetenciesTabContent._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Skills Assessment',
            style: TextStyle(
              color: _SkillsCompetenciesTabContent._titleColor,
              fontSize: 20,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 6),
          const Text(
            'Your competency levels across key skills',
            style: TextStyle(
              color: _SkillsCompetenciesTabContent._mutedColor,
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 28),
          if (_isLoading)
            const Center(child: CircularProgressIndicator())
          else
            for (var i = 0; i < _rows.length; i++) ...[
              _SkillAssessmentRow(data: _rows[i]),
              if (i != _rows.length - 1) const SizedBox(height: 20),
            ],
        ],
      ),
    );
  }
}

class _SkillAssessmentRow extends StatelessWidget {
  const _SkillAssessmentRow({required this.data});

  static const List<String> _levels = ['Beginner', 'Intermediate', 'Advanced'];

  final _SkillRowData data;

  @override
  Widget build(BuildContext context) {
    final percentage = (data.progress * 100).toInt();
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              data.label,
              style: const TextStyle(
                color: _SkillsCompetenciesTabContent._titleColor,
                fontSize: 14,
                fontWeight: FontWeight.w700,
                letterSpacing: 0.2,
              ),
            ),
            Text(
              '$percentage% Complete',
              style: const TextStyle(
                color: Color(0xFF3B82F6),
                fontSize: 12,
                fontWeight: FontWeight.w600,
              ),
            ),
          ],
        ),
        const SizedBox(height: 12),
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
          decoration: BoxDecoration(
            color: const Color(0xFFF9FAFB),
            borderRadius: BorderRadius.circular(14),
            border:
                Border.all(color: _SkillsCompetenciesTabContent._borderColor),
          ),
          child: ClipRRect(
            borderRadius: BorderRadius.circular(10),
            child: Row(
              children: [
                for (var i = 0; i < _levels.length; i++)
                  Expanded(
                    child: _SkillLevelSegment(
                      label: _levels[i],
                      isActive: i == data.levelIndex,
                      showDivider: i != 0,
                    ),
                  ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}

class _SkillLevelSegment extends StatelessWidget {
  const _SkillLevelSegment({
    required this.label,
    required this.isActive,
    this.showDivider = false,
  });

  final String label;
  final bool isActive;
  final bool showDivider;

  @override
  Widget build(BuildContext context) {
    final Color background = isActive
        ? const Color(0xFFF5A26C).withOpacity(0.32)
        : const Color(0xFFF3F4F6);
    final Color textColor = isActive
        ? _SkillsCompetenciesTabContent._titleColor
        : const Color(0xFF9CA3AF);

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      alignment: Alignment.centerLeft,
      decoration: BoxDecoration(
        color: background,
        border: showDivider
            ? const Border(left: BorderSide(color: Color(0xFFE5E7EB)))
            : null,
      ),
      child: Text(
        label,
        style: TextStyle(
          color: textColor,
          fontSize: 13,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }
}

class _RecommendedContentCard extends StatefulWidget {
  const _RecommendedContentCard();

  @override
  State<_RecommendedContentCard> createState() =>
      _RecommendedContentCardState();
}

class _RecommendedContentCardState extends State<_RecommendedContentCard> {
  List<_LibraryCardData> _items = [];
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadRecommendedContent();
  }

  Future<void> _loadRecommendedContent() async {
    try {
      // Load 3 most recent courses from Firestore
      final snapshot = await FirebaseFirestore.instance
          .collection('video')
          .orderBy('created_at', descending: true)
          .limit(3)
          .get();

      final items = <_LibraryCardData>[];
      for (var i = 0; i < snapshot.docs.length; i++) {
        final doc = snapshot.docs[i];
        final data = doc.data();
        final title = (data['title'] as String?) ??
            (data['name'] as String?) ??
            'Untitled';
        final subtitle = (data['subtitle'] as String?) ??
            (data['description'] as String?) ??
            '';
        final topic =
            (data['topic'] as String?) ?? (data['category'] as String?);
        final thumbnailUrl =
            (data['thumbnailUrl'] as String?) ?? (data['thumbnail'] as String?);
        final videoUrl =
            (data['video_url'] as String?) ?? (data['videoUrl'] as String?);

        Color thumbnailColor = const Color(0xFF1F2937);
        if (topic != null) {
          final normalizedTopic = topic.toLowerCase();
          if (normalizedTopic == 'think') {
            thumbnailColor = const Color(0xFF1E3A8A);
          } else if (normalizedTopic == 'keep') {
            thumbnailColor = const Color(0xFF34D399);
          } else if (normalizedTopic == 'accelerate') {
            thumbnailColor = const Color(0xFFF97316);
          } else if (normalizedTopic == 'transform') {
            thumbnailColor = const Color(0xFFEC4899);
          }
        }

        final upVote = data['up_vote'];
        final likesValue = upVote is int ? upVote.abs() : 0;

        final meta = <_LibraryMetaData>[
          const _LibraryMetaData(icon: Icons.access_time, label: '0 minutes'),
          _LibraryMetaData(
              icon: Icons.thumb_up_alt_outlined, label: likesValue.toString()),
        ];

        items.add(_LibraryCardData(
          id: doc.id,
          title: title,
          subtitle: subtitle,
          thumbnailColor: thumbnailColor,
          thumbnailUrl: thumbnailUrl,
          videoUrl: videoUrl,
          meta: meta,
          tags: topic != null ? [topic] : [],
          normalizedTags: topic != null ? [topic.toLowerCase()] : [],
          originalData: data,
        ));
      }

      if (mounted) {
        setState(() {
          _items = items;
          _isLoading = false;
        });
      }
    } catch (e) {
      debugPrint('Failed to load recommended content: $e');
      if (mounted) setState(() => _isLoading = false);
    }
  }

  void _openContent(_LibraryCardData item) {
    Navigator.of(context).push(
      MaterialPageRoute<void>(
        builder: (ctx) => ContentDetailPage(
          course: item,
          relatedCourses: const [],
          onDownloadRequested: null,
          isAdmin: false, // Member dashboard context
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: _SkillsCompetenciesTabContent._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Recommended Content',
            style: TextStyle(
              color: _SkillsCompetenciesTabContent._titleColor,
              fontSize: 20,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 6),
          const Text(
            'Based on your skill development goals',
            style: TextStyle(
              color: _SkillsCompetenciesTabContent._mutedColor,
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 24),
          if (_isLoading)
            const Center(child: CircularProgressIndicator())
          else if (_items.isEmpty)
            const Text(
              'No recommendations available yet.',
              style: TextStyle(
                color: _SkillsCompetenciesTabContent._mutedColor,
                fontSize: 14,
              ),
            )
          else
            for (var i = 0; i < _items.length; i++) ...[
              _RecommendedContentItem(
                data: _items[i],
                onTap: () => _openContent(_items[i]),
              ),
              if (i != _items.length - 1) ...[
                const SizedBox(height: 20),
                const Divider(color: Color(0xFFE5E7EB)),
                const SizedBox(height: 20),
              ],
            ],
        ],
      ),
    );
  }
}

class _RecommendedContentItem extends StatelessWidget {
  const _RecommendedContentItem({required this.data, required this.onTap});

  final _LibraryCardData data;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(16),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: 68,
            height: 68,
            decoration: BoxDecoration(
              color: data.thumbnailColor,
              borderRadius: BorderRadius.circular(16),
              image: data.thumbnailUrl != null
                  ? DecorationImage(
                      image: NetworkImage(data.thumbnailUrl!),
                      fit: BoxFit.cover)
                  : data.thumbnailAsset != null
                      ? DecorationImage(
                          image: AssetImage(data.thumbnailAsset!),
                          fit: BoxFit.cover)
                      : null,
            ),
            child: data.thumbnailUrl == null && data.thumbnailAsset == null
                ? const Icon(Icons.play_arrow, color: Colors.white, size: 32)
                : null,
          ),
          const SizedBox(width: 20),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  data.title,
                  style: const TextStyle(
                    color: _SkillsCompetenciesTabContent._titleColor,
                    fontSize: 16,
                    fontWeight: FontWeight.w700,
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
                if (data.subtitle.isNotEmpty) ...[
                  const SizedBox(height: 8),
                  Text(
                    data.subtitle,
                    style: const TextStyle(
                      color: _SkillsCompetenciesTabContent._mutedColor,
                      fontSize: 14,
                      height: 1.5,
                    ),
                    maxLines: 3,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
                const SizedBox(height: 12),
                Wrap(
                  spacing: 16,
                  runSpacing: 8,
                  children: [
                    for (final meta in data.meta)
                      Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(meta.icon,
                              size: 16,
                              color: _SkillsCompetenciesTabContent._mutedColor),
                          const SizedBox(width: 6),
                          Text(
                            meta.label,
                            style: const TextStyle(
                              color: _SkillsCompetenciesTabContent._mutedColor,
                              fontSize: 13,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ],
                      ),
                  ],
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _SkillRowData {
  const _SkillRowData(
      {required this.label, required this.levelIndex, required this.progress});

  final String label;
  final int levelIndex;
  final double progress;
}

// ------------------------
// Usage metrics service
// ------------------------

class LearningMetrics {
  const LearningMetrics({
    required this.activeDaysThisMonth,
    required this.averageWeeklyMinutesThisMonth,
    required this.totalHoursAllTime,
  });

  final int activeDaysThisMonth;
  final int averageWeeklyMinutesThisMonth;
  final int totalHoursAllTime; // whole hours
}

class UsageMetricsService {
  static DocumentReference<Map<String, dynamic>> _userRef(String uid) {
    return FirebaseFirestore.instance.collection('users').doc(uid);
  }

  static CollectionReference<Map<String, dynamic>> _activityRef(String uid) {
    return _userRef(uid).collection('activity');
  }

  static CollectionReference<Map<String, dynamic>> _sessionsRef(String uid) {
    return _userRef(uid).collection('learning_sessions');
  }

  static DateTime _startOfMonth(DateTime dt) => DateTime(dt.year, dt.month, 1);
  static DateTime _endOfMonth(DateTime dt) {
    final start = _startOfMonth(dt);
    final nextMonth = DateTime(start.year, start.month + 1, 1);
    return nextMonth.subtract(const Duration(milliseconds: 1));
  }

  static int _weeksInMonth(DateTime dt) {
    final start = _startOfMonth(dt);
    final end = _endOfMonth(dt);
    final days = end.difference(start).inDays + 1;
    return (days / 7).ceil().clamp(1, 6);
  }

  static Future<void> logDailyAccess({required String uid}) async {
    final now = DateTime.now();
    final key = _yyyyMmDd(now);
    final doc = _activityRef(uid).doc(key);
    await doc.set({
      'dateKey': key,
      'date': Timestamp.fromDate(DateTime(now.year, now.month, now.day)),
      'accesses': FieldValue.increment(1),
      'lastSeenAt': FieldValue.serverTimestamp(),
    }, SetOptions(merge: true));
  }

  static Future<String> startLearningSession(
      {required String uid, required DateTime startedAt}) async {
    final ref = _sessionsRef(uid).doc();
    await ref.set({
      'status': 'running',
      'startAt': Timestamp.fromDate(startedAt),
      'createdAt': FieldValue.serverTimestamp(),
    });
    return ref.id;
  }

  static Future<void> stopLearningSession({
    required String uid,
    required String sessionId,
    required DateTime startedAt,
    required DateTime endedAt,
  }) async {
    int minutes = endedAt.difference(startedAt).inMinutes;
    if (minutes < 1) {
      minutes = 1; // minimum one minute to register some activity
    }
    await _sessionsRef(uid).doc(sessionId).set({
      'status': 'completed',
      'endAt': Timestamp.fromDate(endedAt),
      'durationMinutes': minutes,
      'updatedAt': FieldValue.serverTimestamp(),
    }, SetOptions(merge: true));

    // Also mark daily access to ensure the day is counted
    await logDailyAccess(uid: uid);
  }

  static Future<LearningMetrics> loadMetrics({required String uid}) async {
    final now = DateTime.now();
    final start = _startOfMonth(now);
    final end = _endOfMonth(now);

    // Active Days this month
    final activitySnap = await _activityRef(uid)
        .where('date', isGreaterThanOrEqualTo: Timestamp.fromDate(start))
        .where('date', isLessThanOrEqualTo: Timestamp.fromDate(end))
        .get();
    final activeDays = activitySnap.docs.length;

    // Learning time
    int totalMinutesAllTime = 0;
    int monthMinutes = 0;

    final sessionsAll =
        await _sessionsRef(uid).where('status', isEqualTo: 'completed').get();
    for (final doc in sessionsAll.docs) {
      final data = doc.data();
      final int? minutes = (data['durationMinutes'] is int)
          ? data['durationMinutes'] as int
          : (data['durationMinutes'] is num)
              ? (data['durationMinutes'] as num).round()
              : null;
      if (minutes == null) continue;
      totalMinutesAllTime += minutes;
      final Timestamp? startAtTs = data['startAt'] as Timestamp?;
      if (startAtTs != null) {
        final DateTime startAt = startAtTs.toDate();
        if (!startAt.isBefore(start) && !startAt.isAfter(end)) {
          monthMinutes += minutes;
        }
      }
    }

    final weeks = _weeksInMonth(now);
    final avgWeeklyMinutes = weeks > 0 ? (monthMinutes / weeks).round() : 0;
    final totalHours = (totalMinutesAllTime / 60).floor();

    return LearningMetrics(
      activeDaysThisMonth: activeDays,
      averageWeeklyMinutesThisMonth: avgWeeklyMinutes,
      totalHoursAllTime: totalHours,
    );
  }

  static String _yyyyMmDd(DateTime dt) {
    final mm = dt.month.toString().padLeft(2, '0');
    final dd = dt.day.toString().padLeft(2, '0');
    return '${dt.year}-$mm-$dd';
  }
}

class CategoryProgressService {
  static const List<_CategoryDefinition> _categories = [
    _CategoryDefinition(
      label: 'Think',
      color: Color(0xFF7C7FE9),
      aliases: {'think'},
    ),
    _CategoryDefinition(
      label: 'Keep',
      color: Color(0xFF34D399),
      aliases: {'keep'},
    ),
    _CategoryDefinition(
      label: 'Accelerate',
      color: Color(0xFFF59E0B),
      aliases: {'accelerate', 'accelerat'},
    ),
    _CategoryDefinition(
      label: 'Transform',
      color: Color(0xFF6366F1),
      aliases: {'transform'},
    ),
    _CategoryDefinition(
      label: 'Abundance',
      color: Color(0xFFF87171),
      aliases: {'abundance', 'abundan'},
    ),
  ];

  static Future<List<_PieSlice>> loadSlicesForUser(String uid) async {
    final counts = await _loadCounts(uid);
    return buildSlicesFromCounts(counts);
  }

  static List<_PieSlice> buildSlicesFromCounts(Map<String, int> counts) {
    return _categories
        .map(
          (category) => _PieSlice(
            category.label,
            (counts[category.label] ?? 0).toDouble(),
            category.color,
          ),
        )
        .toList(growable: false);
  }

  static Future<Map<String, int>> _loadCounts(String uid) async {
    final userRef = FirebaseFirestore.instance.collection('users').doc(uid);
    final Map<String, int> aggregated = {};

    try {
      final completedCoursesRef = userRef.collection('completed_courses');
      final snapshot = await completedCoursesRef.get();

      for (final doc in snapshot.docs) {
        final data = doc.data();
        final topic = _readString(data['topic']);
        if (topic != null) {
          final category = _categoryLabelFromText(topic);
          if (category != null) {
            aggregated[category] = (aggregated[category] ?? 0) + 1;
          }
        }
      }

      if (aggregated.isNotEmpty) {
        debugPrint(
            'CategoryProgress: Found ${aggregated.length} categories with completions');
        return aggregated;
      }
    } on FirebaseException catch (e) {
      debugPrint('Failed to read completed courses: ${e.message}');
    } catch (e) {
      debugPrint('Failed to read completed courses: $e');
    }

    try {
      final snapshot = await userRef.get();
      final counts = _extractCounts(snapshot.data());
      if (counts.isNotEmpty) {
        _mergeCounts(aggregated, counts);
        return aggregated;
      }
    } on FirebaseException catch (e) {
      debugPrint('Failed to read user progress doc: ${e.message}');
    } catch (e) {
      debugPrint('Failed to read user progress doc: $e');
    }

    final docCandidates = <DocumentReference<Map<String, dynamic>>>[
      userRef.collection('metrics').doc('categoryProgress'),
      userRef.collection('metrics').doc('moduleProgress'),
      userRef.collection('progress').doc('categoryProgress'),
      userRef.collection('progress').doc('modules'),
      userRef.collection('dashboard').doc('progressByCategory'),
      userRef.collection('summaries').doc('categoryProgress'),
      userRef.collection('stats').doc('categoryProgress'),
    ];

    for (final ref in docCandidates) {
      try {
        final snapshot = await ref.get();
        final counts = _extractCounts(snapshot.data());
        if (counts.isEmpty) {
          continue;
        }
        _mergeCounts(aggregated, counts);
        return aggregated;
      } on FirebaseException catch (e) {
        debugPrint('Failed to read ${ref.path}: ${e.message}');
      } catch (e) {
        debugPrint('Failed to read ${ref.path}: $e');
      }
    }

    final collectionNames = <String>[
      'module_progress',
      'modules_progress',
      'modules',
      'completedModules',
      'completed_modules',
      'course_progress',
      'courses_progress',
      'content_progress',
      'moduleCompletions',
      'learning_progress',
    ];

    final courseCache = <String, String?>{};

    for (final name in collectionNames) {
      final counts = await _aggregateCollection(
        userRef.collection(name),
        assumeCompleted: name.toLowerCase().contains('completed'),
        courseCache: courseCache,
      );
      if (counts.isEmpty) {
        continue;
      }
      _mergeCounts(aggregated, counts);
      return aggregated;
    }

    return aggregated;
  }

  static void _mergeCounts(Map<String, int> target, Map<String, int> source) {
    source.forEach((label, value) {
      if (value < 0) {
        return;
      }
      final current = target[label];
      if (current == null || value > current) {
        target[label] = value;
      }
    });
  }

  static Map<String, int> _extractCounts(Map<String, dynamic>? data) {
    if (data == null || data.isEmpty) {
      return {};
    }
    final Map<String, int> result = {};
    _mergeCounts(result, _coerceCategoryMap(data));

    const candidateKeys = [
      'modulesByCategory',
      'moduleByCategory',
      'modules_by_category',
      'modulesCompletedByCategory',
      'modules_completed_by_category',
      'categoryProgress',
      'category_progress',
      'progressByCategory',
      'progress_by_category',
      'moduleCompletionByCategory',
      'module_completion_by_category',
      'frameworkProgress',
      'framework_progress',
    ];

    for (final key in candidateKeys) {
      final dynamic value = data[key] ?? data[key.toLowerCase()];
      if (value is Map<String, dynamic>) {
        _mergeCounts(result, _coerceCategoryMap(value));
      } else if (value is Map) {
        _mergeCounts(result, _coerceCategoryMap(_stringKeyedMap(value)));
      }
    }

    data.forEach((rawKey, rawValue) {
      if (rawValue is Iterable) {
        final normalizedKey = _normalizeKey(rawKey.toString());
        if (normalizedKey.contains('completedmodule') ||
            normalizedKey.contains('moduleprogress')) {
          final aggregated = _aggregateFromIterable(rawValue);
          if (aggregated.isNotEmpty) {
            _mergeCounts(result, aggregated);
          }
        }
      }
    });

    return result;
  }

  static Map<String, int> _coerceCategoryMap(Map<dynamic, dynamic> source) {
    final Map<String, int> result = {};
    source.forEach((key, value) {
      final label = _categoryLabelFromText(key?.toString());
      if (label == null) {
        return;
      }
      final count = _coerceInt(value);
      if (count == null) {
        return;
      }
      final current = result[label];
      if (current == null || count > current) {
        result[label] = count;
      }
    });
    return result;
  }

  static Map<String, int> _aggregateFromIterable(Iterable<dynamic> items) {
    final Map<String, int> counts = {};
    for (final item in items) {
      if (item is Map) {
        final map = _stringKeyedMap(item);
        if (!_mapLooksCompleted(map)) {
          continue;
        }
        final category = _resolveCategoryFromMap(map);
        if (category == null) {
          continue;
        }
        counts[category] = (counts[category] ?? 0) + 1;
      } else {
        final label = _categoryLabelFromText(_readString(item));
        if (label != null) {
          counts[label] = (counts[label] ?? 0) + 1;
        }
      }
    }
    return counts;
  }

  static Future<Map<String, int>> _aggregateCollection(
    CollectionReference<Map<String, dynamic>> ref, {
    required bool assumeCompleted,
    required Map<String, String?> courseCache,
  }) async {
    try {
      final snapshot = await ref.get();
      if (snapshot.docs.isEmpty) {
        return {};
      }
      final Map<String, int> counts = {};
      for (final doc in snapshot.docs) {
        final data = doc.data();
        if (!_mapLooksCompleted(data, assumeCompleted: assumeCompleted)) {
          continue;
        }
        final category = await _resolveCategoryFromEntry(
          data: data,
          docId: doc.id,
          courseCache: courseCache,
        );
        if (category == null) {
          continue;
        }
        counts[category] = (counts[category] ?? 0) + 1;
      }
      return counts;
    } on FirebaseException catch (e) {
      debugPrint('Failed to load ${ref.path}: ${e.message}');
      return {};
    } catch (e) {
      debugPrint('Failed to load ${ref.path}: $e');
      return {};
    }
  }

  static Future<String?> _resolveCategoryFromEntry({
    required Map<String, dynamic> data,
    required String docId,
    required Map<String, String?> courseCache,
  }) async {
    final direct = _resolveCategoryFromMap(data);
    if (direct != null) {
      return direct;
    }

    final candidates = <String?>[
      _readString(data['courseId']),
      _readString(data['courseID']),
      _readString(data['course_id']),
      _readString(data['contentId']),
      _readString(data['contentID']),
      _readString(data['content_id']),
      _readString(data['moduleId']),
      _readString(data['module_id']),
      _readString(data['lessonId']),
      _readString(data['lesson_id']),
    ];

    for (final candidate in candidates) {
      final normalized = candidate?.trim();
      if (normalized == null || normalized.isEmpty) {
        continue;
      }
      final category = await _lookupCourseCategory(normalized, courseCache);
      if (category != null) {
        return category;
      }
    }

    return _lookupCourseCategory(docId, courseCache);
  }

  static Future<String?> _lookupCourseCategory(
    String courseId,
    Map<String, String?> cache,
  ) async {
    final normalized = courseId.trim();
    if (normalized.isEmpty) {
      return null;
    }
    if (cache.containsKey(normalized)) {
      return cache[normalized];
    }
    try {
      final snapshot = await FirebaseFirestore.instance
          .collection('courses')
          .doc(normalized)
          .get();
      final data = snapshot.data();
      final category = _categoryLabelFromText(_readString(data?['topic'])) ??
          _categoryLabelFromText(_readString(data?['category'])) ??
          _categoryLabelFromText(_readString(data?['framework'])) ??
          _categoryLabelFromText(_readString(data?['pillar']));
      cache[normalized] = category;
      return category;
    } on FirebaseException catch (e) {
      debugPrint('Failed to read course $normalized: ${e.message}');
    } catch (e) {
      debugPrint('Failed to read course $normalized: $e');
    }
    cache[normalized] = null;
    return null;
  }

  static Map<String, dynamic> _stringKeyedMap(Map<dynamic, dynamic> source) {
    return source.map((key, value) => MapEntry(key.toString(), value));
  }

  static String? _categoryLabelFromText(String? text) {
    if (text == null) {
      return null;
    }
    final normalized = _normalizeKey(text);
    for (final category in _categories) {
      if (category.matches(normalized)) {
        return category.label;
      }
    }
    return null;
  }

  static String _normalizeKey(String text) {
    return text.toLowerCase().replaceAll(RegExp(r'[^a-z]'), '');
  }

  static int? _coerceInt(dynamic value) {
    if (value == null) {
      return null;
    }
    if (value is int) {
      return value;
    }
    if (value is double) {
      return value.round();
    }
    if (value is num) {
      return value.toInt();
    }
    final parsed = int.tryParse(value.toString());
    if (parsed != null) {
      return parsed;
    }
    final match = RegExp(r'-?\d+').firstMatch(value.toString());
    if (match != null) {
      return int.tryParse(match.group(0)!);
    }
    return null;
  }

  static bool _mapLooksCompleted(Map<String, dynamic> data,
      {bool assumeCompleted = false}) {
    if (assumeCompleted) {
      return true;
    }
    const statusKeys = [
      'status',
      'state',
      'progressStatus',
      'completionStatus'
    ];
    for (final key in statusKeys) {
      if (_isCompletedStatus(data[key])) {
        return true;
      }
    }
    const flagKeys = [
      'completed',
      'isCompleted',
      'is_complete',
      'complete',
      'done',
      'finished'
    ];
    for (final key in flagKeys) {
      if (_isCompletedStatus(data[key])) {
        return true;
      }
    }
    const progressKeys = [
      'progress',
      'completion',
      'percentComplete',
      'completionPercent',
      'completionPercentage',
      'completionRate',
      'progressPercent',
    ];
    for (final key in progressKeys) {
      final value = data[key];
      if (value is num) {
        final metric = value.toDouble();
        if ((metric >= 0.99 && metric <= 1.01) || metric >= 99) {
          return true;
        }
      } else if (value is String) {
        final parsed = double.tryParse(value);
        if (parsed != null) {
          if ((parsed >= 0.99 && parsed <= 1.01) || parsed >= 99) {
            return true;
          }
        }
      }
    }
    const timestampKeys = [
      'completedAt',
      'completed_at',
      'completedOn',
      'completed_on',
      'finishedAt'
    ];
    for (final key in timestampKeys) {
      if (data[key] != null) {
        return true;
      }
    }
    return false;
  }

  static bool _isCompletedStatus(dynamic value) {
    if (value == null) {
      return false;
    }
    if (value is bool) {
      return value;
    }
    final normalized = value.toString().trim().toLowerCase();
    if (normalized.isEmpty) {
      return false;
    }
    if (normalized == '1' || normalized == 'true' || normalized == 'yes') {
      return true;
    }
    if (normalized.contains('incomplete') ||
        normalized.contains('pending') ||
        normalized.contains('progress')) {
      return false;
    }
    return normalized.contains('complete') ||
        normalized.contains('completed') ||
        normalized.contains('finished') ||
        normalized.contains('done') ||
        normalized.contains('achieved');
  }

  static String? _resolveCategoryFromMap(Map<String, dynamic> data) {
    const candidateKeys = [
      'category',
      'moduleCategory',
      'module_category',
      'topic',
      'framework',
      'pillar',
      'track',
      'series',
      'tag',
      'group',
      'segment',
    ];
    for (final key in candidateKeys) {
      final label = _categoryLabelFromText(_readString(data[key]));
      if (label != null) {
        return label;
      }
    }

    const nestedKeys = [
      'module',
      'course',
      'content',
      'item',
      'metadata',
      'details',
      'resource'
    ];
    for (final key in nestedKeys) {
      final nested = data[key];
      if (nested is Map<String, dynamic>) {
        final label = _resolveCategoryFromMap(nested);
        if (label != null) {
          return label;
        }
      } else if (nested is Map) {
        final label = _resolveCategoryFromMap(_stringKeyedMap(nested));
        if (label != null) {
          return label;
        }
      }
    }

    for (final entry in data.entries) {
      final value = entry.value;
      final label = _categoryFromDynamic(value);
      if (label != null) {
        return label;
      }
    }

    return null;
  }

  static String? _categoryFromDynamic(dynamic value) {
    if (value == null) {
      return null;
    }
    if (value is String) {
      return _categoryLabelFromText(value);
    }
    if (value is Map<String, dynamic>) {
      return _resolveCategoryFromMap(value);
    }
    if (value is Map) {
      return _resolveCategoryFromMap(_stringKeyedMap(value));
    }
    return null;
  }

  static String? _readString(dynamic value) {
    if (value == null) {
      return null;
    }
    if (value is String) {
      final trimmed = value.trim();
      return trimmed.isEmpty ? null : trimmed;
    }
    if (value is num) {
      return value.toString();
    }
    return value.toString();
  }
}

class _CategoryDefinition {
  const _CategoryDefinition({
    required this.label,
    required this.color,
    required this.aliases,
  });

  final String label;
  final Color color;
  final Set<String> aliases;

  bool matches(String normalizedInput) {
    for (final alias in aliases) {
      if (normalizedInput.contains(alias)) {
        return true;
      }
    }
    return false;
  }
}

class ProfilePage extends StatefulWidget {
  const ProfilePage({super.key});

  static const Color _titleColor = Color(0xFF111827);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFD1D5DB);
  static const Color _focusColor = Color(0xFF1AA8B0);

  @override
  State<ProfilePage> createState() => _ProfilePageState();
}

enum ProfileTab { generalInfo, notifications }

class _ProfilePageState extends State<ProfilePage> {
  final TextEditingController _firstNameController = TextEditingController();
  final TextEditingController _lastNameController = TextEditingController();
  final TextEditingController _usernameController = TextEditingController();
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _phoneController = TextEditingController();
  final TextEditingController _companyController = TextEditingController();
  final TextEditingController _bioController = TextEditingController();
  final TextEditingController _linkedinController = TextEditingController();
  final TextEditingController _twitterController = TextEditingController();

  bool _isLoading = true;
  bool _isSaving = false;
  bool _isUploadingImage = false;
  String? _userId;
  String? _profileImageUrl;
  ProfileTab _selectedTab = ProfileTab.generalInfo;

  @override
  void initState() {
    super.initState();
    _loadUserProfile();
  }

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    _usernameController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    _companyController.dispose();
    _bioController.dispose();
    _linkedinController.dispose();
    _twitterController.dispose();
    super.dispose();
  }

  Future<void> _loadUserProfile() async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) {
        setState(() => _isLoading = false);
        return;
      }

      _userId = user.uid;
      _emailController.text = user.email ?? '';

      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .get();
      if (userDoc.exists) {
        final data = userDoc.data()!;
        final firstName =
            data['first_name'] as String? ?? data['firstName'] as String? ?? '';
        final lastName =
            data['last_name'] as String? ?? data['lastName'] as String? ?? '';
        _firstNameController.text = firstName;
        _lastNameController.text = lastName;
        // Set username to combined first + last name
        _usernameController.text = '$firstName $lastName'.trim();
        _phoneController.text = data['phone'] as String? ?? '';
        _companyController.text =
            data['agency'] as String? ?? data['company'] as String? ?? '';
        _bioController.text = data['bio'] as String? ?? '';
        _linkedinController.text = data['linkedin'] as String? ?? '';
        _twitterController.text = data['twitter'] as String? ?? '';
        _profileImageUrl = data['profile_image'] as String?;
      }
    } catch (error) {
      debugPrint('Error loading user profile: $error');
    } finally {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _saveProfile() async {
    if (_userId == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('You must be logged in to save changes')),
      );
      return;
    }

    setState(() => _isSaving = true);

    try {
      await FirebaseFirestore.instance.collection('users').doc(_userId).update({
        'first_name': _firstNameController.text.trim(),
        'last_name': _lastNameController.text.trim(),
        'username': _usernameController.text.trim(),
        'phone': _phoneController.text.trim(),
        'agency': _companyController.text.trim(),
        'bio': _bioController.text.trim(),
        'linkedin': _linkedinController.text.trim(),
        'twitter': _twitterController.text.trim(),
        if (_profileImageUrl != null) 'profile_image': _profileImageUrl,
      });

      // Create notification for profile update
      await NotificationService.notifyProfileUpdate(
        userId: _userId!,
        updatedField: 'profile information',
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Profile updated successfully!'),
            backgroundColor: Color(0xFF10B981),
          ),
        );
      }
    } catch (error) {
      debugPrint('Error saving profile: $error');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Failed to save profile. Please try again.'),
            backgroundColor: Color(0xFFEF4444),
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isSaving = false);
      }
    }
  }

  Future<void> _pickAndUploadImage() async {
    if (_userId == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content: Text('You must be logged in to upload an image')),
      );
      return;
    }

    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        withData: true,
      );

      if (result == null || result.files.isEmpty) return;

      final file = result.files.first;
      if (file.bytes == null) {
        throw Exception('Unable to read image data');
      }

      setState(() => _isUploadingImage = true);

      final storageRef = FirebaseStorage.instance.ref();
      final fileName =
          'profile_images/$_userId/${DateTime.now().millisecondsSinceEpoch}_${file.name}';
      final imageRef = storageRef.child(fileName);

      await imageRef.putData(
        file.bytes!,
        SettableMetadata(contentType: 'image/${file.extension}'),
      );

      final downloadUrl = await imageRef.getDownloadURL();

      await FirebaseFirestore.instance.collection('users').doc(_userId).update({
        'profile_image': downloadUrl,
      });

      setState(() {
        _profileImageUrl = downloadUrl;
        _isUploadingImage = false;
      });

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Profile image uploaded successfully!'),
            backgroundColor: Color(0xFF10B981),
          ),
        );
      }
    } catch (error) {
      debugPrint('Error uploading image: $error');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to upload image: $error'),
            backgroundColor: const Color(0xFFEF4444),
          ),
        );
        setState(() => _isUploadingImage = false);
      }
    }
  }

  OutlineInputBorder _outline(Color color) {
    return OutlineInputBorder(
      borderRadius: BorderRadius.circular(12),
      borderSide: BorderSide(color: color, width: 1.2),
    );
  }

  InputDecoration _decoration({String? hintText}) {
    return InputDecoration(
      hintText: hintText,
      filled: true,
      fillColor: Colors.white,
      contentPadding: const EdgeInsets.symmetric(horizontal: 18, vertical: 18),
      enabledBorder: _outline(ProfilePage._borderColor),
      focusedBorder: _outline(ProfilePage._focusColor),
    );
  }

  Widget _field(String label,
      {required TextEditingController controller,
      String? hintText,
      int maxLines = 1}) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: const TextStyle(
            color: ProfilePage._titleColor,
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.2,
          ),
        ),
        const SizedBox(height: 8),
        TextFormField(
          controller: controller,
          maxLines: maxLines,
          minLines: maxLines > 1 ? maxLines : null,
          style: const TextStyle(
            color: ProfilePage._titleColor,
            fontSize: 15,
            fontWeight: FontWeight.w500,
          ),
          decoration: _decoration(hintText: hintText),
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Center(
        child: CircularProgressIndicator(
          valueColor: AlwaysStoppedAnimation<Color>(ProfilePage._focusColor),
        ),
      );
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        final horizontalPadding = constraints.maxWidth > 1180 ? 56.0 : 32.0;
        final isCompact = constraints.maxWidth < 960;

        final avatar = InkWell(
          onTap: _isUploadingImage ? null : _pickAndUploadImage,
          borderRadius: BorderRadius.circular(24),
          child: Container(
            width: 200,
            height: 200,
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(24),
              border: Border.all(color: const Color(0xFFE5E7EB), width: 2),
              image: _profileImageUrl != null
                  ? DecorationImage(
                      image: NetworkImage(_profileImageUrl!),
                      fit: BoxFit.cover,
                    )
                  : null,
            ),
            child: Stack(
              children: [
                if (_profileImageUrl == null)
                  const Center(
                    child: Icon(
                      Icons.person_outline,
                      color: ProfilePage._titleColor,
                      size: 120,
                    ),
                  ),
                if (_isUploadingImage)
                  Container(
                    decoration: BoxDecoration(
                      color: Colors.black.withValues(alpha: 0.5),
                      borderRadius: BorderRadius.circular(24),
                    ),
                    child: const Center(
                      child: CircularProgressIndicator(
                        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                      ),
                    ),
                  )
                else
                  Positioned(
                    bottom: 8,
                    right: 8,
                    child: Container(
                      padding: const EdgeInsets.all(8),
                      decoration: BoxDecoration(
                        color: const Color(0xFF1BA4B8),
                        borderRadius: BorderRadius.circular(12),
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withValues(alpha: 0.2),
                            blurRadius: 8,
                            offset: const Offset(0, 2),
                          ),
                        ],
                      ),
                      child: const Icon(
                        Icons.camera_alt,
                        color: Colors.white,
                        size: 20,
                      ),
                    ),
                  ),
              ],
            ),
          ),
        );

        late final Widget firstRow;
        if (isCompact) {
          firstRow = Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _field('First Name', controller: _firstNameController),
              const SizedBox(height: 24),
              _field('Last Name', controller: _lastNameController),
            ],
          );
        } else {
          firstRow = Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                  child:
                      _field('First Name', controller: _firstNameController)),
              const SizedBox(width: 24),
              Expanded(
                  child: _field('Last Name', controller: _lastNameController)),
            ],
          );
        }

        late final Widget emailPhoneRow;
        if (isCompact) {
          emailPhoneRow = Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _field('EMAIL', controller: _emailController),
              const SizedBox(height: 24),
              _field('Phone',
                  controller: _phoneController, hintText: 'Phone number'),
            ],
          );
        } else {
          emailPhoneRow = Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(child: _field('EMAIL', controller: _emailController)),
              const SizedBox(width: 24),
              Expanded(
                  child: _field('Phone',
                      controller: _phoneController, hintText: 'Phone number')),
            ],
          );
        }

        late final Widget socialRow;
        if (isCompact) {
          socialRow = Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _field('LinkedIn',
                  controller: _linkedinController, hintText: 'Link here'),
              const SizedBox(height: 24),
              _field('Twitter',
                  controller: _twitterController, hintText: 'Link here'),
            ],
          );
        } else {
          socialRow = Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                  child: _field('LinkedIn',
                      controller: _linkedinController, hintText: 'Link here')),
              const SizedBox(width: 24),
              Expanded(
                  child: _field('Twitter',
                      controller: _twitterController, hintText: 'Link here')),
            ],
          );
        }

        final generalInfoContent = Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            firstRow,
            const SizedBox(height: 24),
            _field('Username', controller: _usernameController),
            const SizedBox(height: 24),
            emailPhoneRow,
            const SizedBox(height: 24),
            _field('Company/Agency',
                controller: _companyController, hintText: 'add to agency'),
            const SizedBox(height: 24),
            _field('Bio',
                controller: _bioController,
                hintText: 'Tell us a bit about yourself',
                maxLines: 4),
            const SizedBox(height: 32),
            const Text(
              'Social Media Links',
              style: TextStyle(
                color: ProfilePage._titleColor,
                fontSize: 16,
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 16),
            socialRow,
            const SizedBox(height: 36),
            Align(
              alignment: Alignment.centerRight,
              child: ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF1BA4B8),
                  foregroundColor: Colors.white,
                  padding:
                      const EdgeInsets.symmetric(horizontal: 32, vertical: 18),
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12)),
                  elevation: 0,
                ),
                onPressed: _isSaving ? null : _saveProfile,
                child: _isSaving
                    ? const SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor:
                              AlwaysStoppedAnimation<Color>(Colors.white),
                        ),
                      )
                    : const Text(
                        'Save Changes',
                        style: TextStyle(
                            fontWeight: FontWeight.w600, fontSize: 16),
                      ),
              ),
            ),
          ],
        );

        final formColumn = Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _ProfileTabBar(
              selectedTab: _selectedTab,
              onTabSelected: (tab) => setState(() => _selectedTab = tab),
            ),
            const SizedBox(height: 32),
            if (_selectedTab == ProfileTab.generalInfo)
              generalInfoContent
            else
              _ProfileNotificationsContent(userId: _userId),
          ],
        );

        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Profile Management',
                style: TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.w700,
                  color: ProfilePage._titleColor,
                ),
              ),
              const SizedBox(height: 6),
              const Text(
                'Manage your personal information and preferences',
                style: TextStyle(color: ProfilePage._mutedColor, fontSize: 16),
              ),
              const SizedBox(height: 32),
              if (isCompact)
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    avatar,
                    const SizedBox(height: 32),
                    formColumn,
                  ],
                )
              else
                Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    avatar,
                    const SizedBox(width: 48),
                    Expanded(child: formColumn),
                  ],
                ),
            ],
          ),
        );
      },
    );
  }
}

enum SettingsTab { accounts, notifications, privacy, security }

class SettingsPage extends StatefulWidget {
  const SettingsPage({super.key});

  static const Color _titleColor = Color(0xFF111827);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE5E7EB);
  static const Color _tabBackground = Color(0xFFF5F6FA);
  static const Color _tabActiveBackground = Colors.white;
  static const Color _accentTeal = Color(0xFF1BA4B8);
  static const Color _dangerRed = Color(0xFFEF4444);

  @override
  State<SettingsPage> createState() => _SettingsPageState();
}

class _SettingsPageState extends State<SettingsPage> {
  SettingsTab _activeTab = SettingsTab.accounts;

  static const List<String> _languages = <String>[
    'English (US)',
    'English (UK)',
    'Spanish',
    'French',
  ];

  static const List<String> _dateFormats = <String>[
    'MM/DD/YYYY',
    'DD/MM/YYYY',
    'YYYY-MM-DD',
  ];

  static const List<String> _timezones = <String>[
    'Eastern time (ET)',
    'Central time (CT)',
    'Pacific time (PT)',
    'Mountain time (MT)',
  ];

  static const List<String> _timeFormats = <String>[
    '12-hour (1:30 PM)',
    '24-hour (13:30)',
  ];

  static const List<String> _privacyVisibilityOptions = <String>[
    'Everyone',
    'Only my coaches',
    'Only me',
  ];

  static const List<String> _privacyActivityOptions = <String>[
    'Everyone',
    'Only my coaches',
    'Hide activity',
  ];

  String _language = _languages.first;
  String _dateFormat = _dateFormats.first;
  String _timezone = _timezones.first;
  String _timeFormat = _timeFormats.first;
  String _profileVisibility = _privacyVisibilityOptions.first;
  String _activityVisibility = _privacyActivityOptions.first;
  bool _dataCollectionEnabled = true;
  bool _emailNotificationsEnabled = false;
  bool _pushNotificationsEnabled = false;
  bool _platformUpdatesEnabled = false;
  bool _sessionReminderEnabled = false;
  bool _messagesNotificationEnabled = false;
  bool _marketingUpdatesEnabled = false;

  InputDecoration _dropdownDecoration() {
    return InputDecoration(
      filled: true,
      fillColor: Colors.white,
      contentPadding: const EdgeInsets.symmetric(horizontal: 18, vertical: 18),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(14),
        borderSide: const BorderSide(color: SettingsPage._borderColor),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(14),
        borderSide:
            const BorderSide(color: SettingsPage._accentTeal, width: 1.4),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final double horizontalPadding =
            constraints.maxWidth > 1180 ? 56.0 : 32.0;
        final bool stackColumns = constraints.maxWidth < 1024;

        Widget content;
        switch (_activeTab) {
          case SettingsTab.accounts:
            content = _buildAccountsContent(stackColumns);
            break;
          case SettingsTab.notifications:
            content = _buildNotificationsContent(stackColumns);
            break;
          case SettingsTab.privacy:
            content = _buildPrivacyContent(stackColumns);
            break;
          case SettingsTab.security:
            content = _buildSecurityContent(stackColumns);
            break;
        }

        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Settings',
                style: TextStyle(
                  color: SettingsPage._titleColor,
                  fontSize: 24,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 24),
              _SettingsTabBar(
                activeTab: _activeTab,
                onSelected: (tab) {
                  if (_activeTab == tab) return;
                  setState(() => _activeTab = tab);
                },
              ),
              const SizedBox(height: 32),
              content,
            ],
          ),
        );
      },
    );
  }

  Widget _buildNotificationsContent(bool isCompact) {
    const TextStyle sectionTitleStyle = TextStyle(
      color: SettingsPage._titleColor,
      fontSize: 16,
      fontWeight: FontWeight.w700,
    );
    const TextStyle sectionSubtitleStyle = TextStyle(
      color: SettingsPage._mutedColor,
      fontSize: 14,
    );
    const TextStyle tileTitleStyle = TextStyle(
      color: SettingsPage._titleColor,
      fontSize: 15,
      fontWeight: FontWeight.w700,
    );
    const TextStyle tileSubtitleStyle = TextStyle(
      color: SettingsPage._mutedColor,
      fontSize: 13,
      height: 1.4,
      fontWeight: FontWeight.w500,
    );

    Widget buildTile({
      required String title,
      required String description,
      required bool value,
      required ValueChanged<bool> onChanged,
    }) {
      return Padding(
        padding: EdgeInsets.symmetric(
          horizontal: isCompact ? 18 : 24,
          vertical: isCompact ? 16 : 18,
        ),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(title, style: tileTitleStyle),
                  const SizedBox(height: 4),
                  Text(description, style: tileSubtitleStyle),
                ],
              ),
            ),
            const SizedBox(width: 18),
            Transform.scale(
              scale: 0.9,
              child: Switch.adaptive(
                value: value,
                onChanged: onChanged,
                activeColor: Colors.white,
                activeTrackColor: SettingsPage._accentTeal,
                inactiveThumbColor: const Color(0xFFE5E7EB),
                inactiveTrackColor: const Color(0xFFF3F4F6),
              ),
            ),
          ],
        ),
      );
    }

    Widget buildSection(String title, List<Widget> tiles) {
      final List<Widget> children = <Widget>[];
      for (var i = 0; i < tiles.length; i++) {
        if (i > 0) {
          children.add(
              const Divider(height: 1, thickness: 1, color: Color(0xFFEFF1F5)));
        }
        children.add(tiles[i]);
      }

      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(title, style: sectionTitleStyle),
          const SizedBox(height: 16),
          Container(
            width: double.infinity,
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(22),
              border: const Border.fromBorderSide(
                  BorderSide(color: SettingsPage._borderColor)),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.02),
                  blurRadius: 18,
                  offset: const Offset(0, 12),
                ),
              ],
            ),
            child: Column(children: children),
          ),
        ],
      );
    }

    return Container(
      width: double.infinity,
      padding: EdgeInsets.fromLTRB(
        isCompact ? 24 : 28,
        isCompact ? 24 : 28,
        isCompact ? 24 : 28,
        isCompact ? 26 : 32,
      ),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: const Border.fromBorderSide(
            BorderSide(color: SettingsPage._borderColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Notification Preferences',
            style: TextStyle(
              color: SettingsPage._titleColor,
              fontSize: 20,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 6),
          const Text(
            'Manage how and when you receive notifications',
            style: sectionSubtitleStyle,
          ),
          const SizedBox(height: 28),
          buildSection(
            'Notification Channels',
            [
              buildTile(
                title: 'Email Notifications',
                description: 'Receive notifications via email',
                value: _emailNotificationsEnabled,
                onChanged: (value) =>
                    setState(() => _emailNotificationsEnabled = value),
              ),
              buildTile(
                title: 'Push Notifications',
                description: 'Receive notifications in browser and mobile',
                value: _pushNotificationsEnabled,
                onChanged: (value) =>
                    setState(() => _pushNotificationsEnabled = value),
              ),
            ],
          ),
          const SizedBox(height: 28),
          buildSection(
            'Email Notification Types',
            [
              buildTile(
                title: 'Platform Updates',
                description: 'New features, content updates, and improvements',
                value: _platformUpdatesEnabled,
                onChanged: (value) =>
                    setState(() => _platformUpdatesEnabled = value),
              ),
              buildTile(
                title: 'Session Reminder',
                description: 'Session updates and schedule',
                value: _sessionReminderEnabled,
                onChanged: (value) =>
                    setState(() => _sessionReminderEnabled = value),
              ),
              buildTile(
                title: 'Messages',
                description: 'Direct messages from coaches and members',
                value: _messagesNotificationEnabled,
                onChanged: (value) =>
                    setState(() => _messagesNotificationEnabled = value),
              ),
              buildTile(
                title: 'Marketing Communications',
                description: 'Special offers, promotions, and newsletters',
                value: _marketingUpdatesEnabled,
                onChanged: (value) =>
                    setState(() => _marketingUpdatesEnabled = value),
              ),
            ],
          ),
          const SizedBox(height: 32),
          Align(
            alignment: isCompact ? Alignment.center : Alignment.centerRight,
            child: SizedBox(
              width: isCompact ? double.infinity : 220,
              height: 52,
              child: ElevatedButton(
                onPressed: () {},
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF3253C8),
                  foregroundColor: Colors.white,
                  textStyle: const TextStyle(
                      fontSize: 15, fontWeight: FontWeight.w700),
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16)),
                  elevation: 0,
                ),
                child: const Text('Save Notification Settings'),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSecurityContent(bool isCompact) {
    final String? email = FirebaseAuth.instance.currentUser?.email;

    final Widget changePasswordCard = Container(
      width: double.infinity,
      padding: EdgeInsets.all(isCompact ? 22 : 26),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(22),
        border: const Border.fromBorderSide(
            BorderSide(color: SettingsPage._borderColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: LayoutBuilder(
        builder: (context, constraints) {
          final bool stack = constraints.maxWidth < 640;
          final Widget detailsContent = Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Change your password',
                style: TextStyle(
                  color: SettingsPage._titleColor,
                  fontSize: 16,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 6),
              Text(
                email ?? 'Email unavailable',
                style: const TextStyle(
                  color: SettingsPage._titleColor,
                  fontSize: 14,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(height: 4),
              const Text(
                "We'll email you a secure link to create a new password.",
                style: TextStyle(
                  color: SettingsPage._mutedColor,
                  fontSize: 13,
                  height: 1.4,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          );

          final Widget button = SizedBox(
            width: stack ? double.infinity : null,
            height: 48,
            child: ElevatedButton(
              onPressed: _sendPasswordResetFromSecurity,
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF3253C8),
                foregroundColor: Colors.white,
                textStyle:
                    const TextStyle(fontSize: 14, fontWeight: FontWeight.w700),
                padding: const EdgeInsets.symmetric(horizontal: 24),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(14)),
                elevation: 0,
              ),
              child: const Text('Change Password'),
            ),
          );

          if (stack) {
            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                detailsContent,
                const SizedBox(height: 18),
                button,
              ],
            );
          }

          return Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Expanded(child: detailsContent),
              const SizedBox(width: 24),
              button,
            ],
          );
        },
      ),
    );

    final Widget signOutButton = SizedBox(
      width: double.infinity,
      height: 54,
      child: ElevatedButton(
        onPressed: _signOutOtherSessions,
        style: ElevatedButton.styleFrom(
          backgroundColor: const Color(0xFF3253C8),
          foregroundColor: Colors.white,
          textStyle: const TextStyle(fontSize: 15, fontWeight: FontWeight.w700),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          elevation: 0,
        ),
        child: const Text('Sign Out All Other Sessions'),
      ),
    );

    return Container(
      width: double.infinity,
      padding: EdgeInsets.fromLTRB(isCompact ? 24 : 28, isCompact ? 24 : 28,
          isCompact ? 24 : 28, isCompact ? 26 : 32),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: const Border.fromBorderSide(
            BorderSide(color: SettingsPage._borderColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Security Settings',
            style: TextStyle(
              color: SettingsPage._titleColor,
              fontSize: 20,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 6),
          const Text(
            'Manage your account security and access',
            style: TextStyle(color: SettingsPage._mutedColor, fontSize: 14),
          ),
          const SizedBox(height: 28),
          changePasswordCard,
          const SizedBox(height: 28),
          signOutButton,
        ],
      ),
    );
  }

  Widget _buildAccountsContent(bool stackColumns) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          width: double.infinity,
          padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(24),
            border: const Border.fromBorderSide(
                BorderSide(color: SettingsPage._borderColor)),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.03),
                blurRadius: 12,
                offset: const Offset(0, 6),
              ),
            ],
          ),
          child: const Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Current Subscription',
                style: TextStyle(
                  color: SettingsPage._titleColor,
                  fontSize: 20,
                  fontWeight: FontWeight.w700,
                ),
              ),
              SizedBox(height: 6),
              Text(
                'Manage your current subscription plan and payment details',
                style: TextStyle(
                  color: SettingsPage._mutedColor,
                  fontSize: 14,
                ),
              ),
            ],
          ),
        ),
        const SizedBox(height: 32),
        _buildHelpAndTutorialSection(stackColumns),
        const SizedBox(height: 32),
        _buildDangerZone(stackColumns),
      ],
    );
  }

  Widget _buildHelpAndTutorialSection(bool isCompact) {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.fromLTRB(
        isCompact ? 24 : 28,
        isCompact ? 24 : 28,
        isCompact ? 24 : 28,
        isCompact ? 26 : 32,
      ),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: const Border.fromBorderSide(
            BorderSide(color: SettingsPage._borderColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.03),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Container(
                width: 48,
                height: 48,
                decoration: BoxDecoration(
                  color: SettingsPage._accentTeal.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(14),
                ),
                child: const Icon(
                  Icons.school_outlined,
                  color: SettingsPage._accentTeal,
                  size: 24,
                ),
              ),
              const SizedBox(width: 16),
              const Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Help & Tutorial',
                      style: TextStyle(
                        color: SettingsPage._titleColor,
                        fontSize: 20,
                        fontWeight: FontWeight.w700,
                      ),
                    ),
                    SizedBox(height: 4),
                    Text(
                      'Learn how to use all features of the platform',
                      style: TextStyle(
                        color: SettingsPage._mutedColor,
                        fontSize: 14,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 24),
          const Text(
            'Interactive walkthroughs help you understand each feature of the platform. Select any page to start a guided tour.',
            style: TextStyle(
              color: SettingsPage._mutedColor,
              fontSize: 14,
              height: 1.5,
            ),
          ),
          const SizedBox(height: 24),
          // Quick walkthrough buttons
          Wrap(
            spacing: 12,
            runSpacing: 12,
            children: [
              _TutorialQuickButton(
                icon: Icons.dashboard_outlined,
                label: 'Dashboard',
                pageId: 'dashboard',
              ),
              _TutorialQuickButton(
                icon: Icons.video_library_outlined,
                label: 'Content Library',
                pageId: 'content_library',
              ),
              _TutorialQuickButton(
                icon: Icons.assignment_outlined,
                label: 'Assessments',
                pageId: 'assessments',
              ),
              _TutorialQuickButton(
                icon: Icons.score_outlined,
                label: 'Scorecard',
                pageId: 'scorecard',
              ),
            ],
          ),
          const SizedBox(height: 24),
          // View all walkthroughs button
          SizedBox(
            width: double.infinity,
            height: 52,
            child: ElevatedButton.icon(
              style: ElevatedButton.styleFrom(
                backgroundColor: SettingsPage._accentTeal,
                foregroundColor: Colors.white,
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(14)),
                textStyle:
                    const TextStyle(fontSize: 15, fontWeight: FontWeight.w700),
                elevation: 0,
              ),
              onPressed: () {
                showDialog(
                  context: context,
                  builder: (context) => const WalkthroughSelectionDialog(),
                );
              },
              icon: const Icon(Icons.play_circle_outline,
                  size: 20, color: Colors.white),
              label: const Text('View All Page Walkthroughs'),
            ),
          ),
          const SizedBox(height: 16),
          // Reset walkthroughs button
          SizedBox(
            width: double.infinity,
            height: 48,
            child: OutlinedButton.icon(
              style: OutlinedButton.styleFrom(
                foregroundColor: SettingsPage._mutedColor,
                side: const BorderSide(
                    color: SettingsPage._borderColor, width: 1.2),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(14)),
                textStyle:
                    const TextStyle(fontSize: 14, fontWeight: FontWeight.w600),
              ),
              onPressed: () async {
                await WalkthroughService().resetAllWalkthroughs();
                _showSnack('All walkthrough progress has been reset.');
              },
              icon: const Icon(Icons.refresh_outlined,
                  size: 18, color: SettingsPage._mutedColor),
              label: const Text('Reset Walkthrough Progress'),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPrivacyContent(bool isCompact) {
    const TextStyle sectionTitleStyle = TextStyle(
      color: SettingsPage._titleColor,
      fontSize: 16,
      fontWeight: FontWeight.w700,
    );

    return Container(
      width: double.infinity,
      padding: EdgeInsets.fromLTRB(isCompact ? 24 : 28, isCompact ? 24 : 28,
          isCompact ? 24 : 28, isCompact ? 26 : 32),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: const Border.fromBorderSide(
            BorderSide(color: SettingsPage._borderColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Privacy Settings',
            style: TextStyle(
              color: SettingsPage._titleColor,
              fontSize: 20,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 6),
          const Text(
            'Control your data and privacy preferences',
            style: TextStyle(color: SettingsPage._mutedColor, fontSize: 14),
          ),
          const SizedBox(height: 28),
          const Text('Profile Visibility', style: sectionTitleStyle),
          const SizedBox(height: 18),
          _privacyOptionRow(
            title: 'Who can see your profile?',
            description:
                'This controls who can view your profile page and information',
            control: _privacyDropdown(
              value: _profileVisibility,
              options: _privacyVisibilityOptions,
              onChanged: (value) => setState(() => _profileVisibility = value),
            ),
          ),
          const SizedBox(height: 24),
          const Divider(height: 1, color: SettingsPage._borderColor),
          const SizedBox(height: 24),
          const Text('Activity Visibility', style: sectionTitleStyle),
          const SizedBox(height: 18),
          _privacyOptionRow(
            title: 'Who can see your activity?',
            description:
                'Controls who can see your learning activity and progress',
            control: _privacyDropdown(
              value: _activityVisibility,
              options: _privacyActivityOptions,
              onChanged: (value) => setState(() => _activityVisibility = value),
            ),
          ),
          const SizedBox(height: 24),
          const Divider(height: 1, color: SettingsPage._borderColor),
          const SizedBox(height: 24),
          const Text('Data Privacy', style: sectionTitleStyle),
          const SizedBox(height: 18),
          _privacyToggleRow(
            title: 'Data Collection',
            description:
                'Allow us to collect usage data to improve your experience',
            value: _dataCollectionEnabled,
            onChanged: (value) =>
                setState(() => _dataCollectionEnabled = value),
          ),
          const SizedBox(height: 24),
          _buildPrivacyInfoBanner(),
          const SizedBox(height: 28),
          _buildPrivacyActionRow(isCompact),
        ],
      ),
    );
  }

  Widget _privacyOptionRow({
    required String title,
    required String description,
    required Widget control,
  }) {
    const TextStyle titleStyle = TextStyle(
      color: SettingsPage._titleColor,
      fontSize: 14,
      fontWeight: FontWeight.w700,
    );
    const TextStyle descriptionStyle = TextStyle(
      color: SettingsPage._mutedColor,
      fontSize: 13,
      height: 1.45,
      fontWeight: FontWeight.w500,
    );

    return LayoutBuilder(
      builder: (context, constraints) {
        final bool stack = constraints.maxWidth < 720;
        if (stack) {
          return Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(title, style: titleStyle),
              const SizedBox(height: 6),
              Text(description, style: descriptionStyle),
              const SizedBox(height: 16),
              SizedBox(width: double.infinity, child: control),
            ],
          );
        }

        return Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(title, style: titleStyle),
                  const SizedBox(height: 6),
                  Text(description, style: descriptionStyle),
                ],
              ),
            ),
            const SizedBox(width: 32),
            SizedBox(width: 240, child: control),
          ],
        );
      },
    );
  }

  Widget _privacyDropdown({
    required String value,
    required List<String> options,
    required ValueChanged<String> onChanged,
  }) {
    return DropdownButtonFormField<String>(
      value: value,
      items: options
          .map(
            (option) => DropdownMenuItem<String>(
              value: option,
              child: Text(
                option,
                style: const TextStyle(
                  color: SettingsPage._titleColor,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          )
          .toList(),
      onChanged: (selected) {
        if (selected != null) {
          onChanged(selected);
        }
      },
      icon: const Icon(Icons.expand_more, color: SettingsPage._mutedColor),
      decoration: _dropdownDecoration(),
    );
  }

  Widget _privacyToggleRow({
    required String title,
    required String description,
    required bool value,
    required ValueChanged<bool> onChanged,
  }) {
    const TextStyle titleStyle = TextStyle(
      color: SettingsPage._titleColor,
      fontSize: 14,
      fontWeight: FontWeight.w700,
    );
    const TextStyle descriptionStyle = TextStyle(
      color: SettingsPage._mutedColor,
      fontSize: 13,
      height: 1.45,
      fontWeight: FontWeight.w500,
    );

    final Widget toggle = Switch.adaptive(
      value: value,
      onChanged: onChanged,
      activeColor: SettingsPage._accentTeal,
    );

    return LayoutBuilder(
      builder: (context, constraints) {
        final bool stack = constraints.maxWidth < 720;
        if (stack) {
          return Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(title, style: titleStyle),
              const SizedBox(height: 6),
              Text(description, style: descriptionStyle),
              const SizedBox(height: 16),
              toggle,
            ],
          );
        }

        return Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(title, style: titleStyle),
                  const SizedBox(height: 6),
                  Text(description, style: descriptionStyle),
                ],
              ),
            ),
            const SizedBox(width: 32),
            SizedBox(height: 42, child: Center(child: toggle)),
          ],
        );
      },
    );
  }

  Widget _buildPrivacyInfoBanner() {
    const Color bannerColor = Color(0xFFF8E8FF);
    const Color borderColor = Color(0xFFEBCFF9);
    const TextStyle bodyStyle = TextStyle(
      color: SettingsPage._mutedColor,
      fontSize: 13,
      height: 1.45,
      fontWeight: FontWeight.w500,
    );

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: bannerColor,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: borderColor),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: 44,
            height: 44,
            decoration: BoxDecoration(
              color: Colors.white,
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.05),
                  blurRadius: 12,
                  offset: const Offset(0, 6),
                ),
              ],
            ),
            alignment: Alignment.center,
            child: const Icon(Icons.shield_outlined,
                color: SettingsPage._accentTeal, size: 22),
          ),
          const SizedBox(width: 18),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Data Privacy',
                  style: TextStyle(
                    color: SettingsPage._titleColor,
                    fontSize: 15,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                const SizedBox(height: 8),
                RichText(
                  text: TextSpan(
                    style: bodyStyle,
                    children: [
                      const TextSpan(
                        text:
                            'You can request a copy of your data or delete your account at any time ‚Äî see our ',
                      ),
                      WidgetSpan(
                        alignment: PlaceholderAlignment.baseline,
                        baseline: TextBaseline.alphabetic,
                        child: GestureDetector(
                          onTap: _openPrivacyPolicy,
                          child: Text(
                            'Privacy Policy',
                            style: bodyStyle.copyWith(
                              color: SettingsPage._accentTeal,
                              fontWeight: FontWeight.w700,
                            ),
                          ),
                        ),
                      ),
                      const TextSpan(text: ' for more information.'),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPrivacyActionRow(bool isCompact) {
    final ButtonStyle outlinedStyle = OutlinedButton.styleFrom(
      foregroundColor: SettingsPage._titleColor,
      side: const BorderSide(color: SettingsPage._borderColor, width: 1.2),
      padding: const EdgeInsets.symmetric(horizontal: 22, vertical: 16),
      textStyle: const TextStyle(fontSize: 14, fontWeight: FontWeight.w600),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
    );

    final ButtonStyle primaryStyle = ElevatedButton.styleFrom(
      backgroundColor: const Color(0xFF3B5CCC),
      foregroundColor: Colors.white,
      padding: const EdgeInsets.symmetric(horizontal: 28, vertical: 16),
      textStyle: const TextStyle(fontSize: 15, fontWeight: FontWeight.w700),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
      elevation: 0,
    );

    final Widget resetButton = OutlinedButton(
      style: outlinedStyle,
      onPressed: _resetPrivacySettings,
      child: const Text('Reset preferences'),
    );

    final Widget saveButton = ElevatedButton(
      style: primaryStyle,
      onPressed: _savePrivacySettings,
      child: const Text('Save Privacy settings'),
    );

    if (isCompact) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          resetButton,
          const SizedBox(height: 12),
          saveButton,
        ],
      );
    }

    return Align(
      alignment: Alignment.centerRight,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          resetButton,
          const SizedBox(width: 12),
          saveButton,
        ],
      ),
    );
  }

  void _savePrivacySettings() {
    _showSnack('Privacy preferences saved.');
  }

  void _resetPrivacySettings() {
    setState(() {
      _profileVisibility = _privacyVisibilityOptions.first;
      _activityVisibility = _privacyActivityOptions.first;
      _dataCollectionEnabled = true;
    });
    _showSnack('Privacy preferences restored to defaults.');
  }

  void _showSnack(String message) {
    final messenger = ScaffoldMessenger.of(context);
    messenger
      ..hideCurrentSnackBar()
      ..showSnackBar(
        SnackBar(
          content: Text(message),
        ),
      );
  }

  Future<void> _sendPasswordResetFromSecurity() async {
    final user = FirebaseAuth.instance.currentUser;
    final email = user?.email;

    if (email == null || email.isEmpty) {
      _showSnack('We could not find an email for your account.');
      return;
    }

    try {
      await FirebaseAuth.instance.sendPasswordResetEmail(email: email);
      if (!mounted) return;
      _showSnack('Password reset link sent to $email.');
    } on FirebaseAuthException catch (e) {
      _showSnack(e.message ?? 'Unable to send password reset email right now.');
    }
  }

  void _signOutOtherSessions() {
    _showSnack(
        "We'll sign you out of other sessions once this feature is connected.");
  }

  Future<void> _openPrivacyPolicy() async {
    final Uri url = Uri.parse('https://breakaway365.com/privacy');
    if (!await launchUrl(url, mode: LaunchMode.externalApplication)) {
      if (!mounted) return;
      _showSnack('Unable to open the privacy policy right now.');
    }
  }

  Widget _buildAccountSettingsColumn() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Account Settings',
          style: TextStyle(
            color: SettingsPage._titleColor,
            fontSize: 16,
            fontWeight: FontWeight.w700,
          ),
        ),
        const SizedBox(height: 4),
        const Text(
          'Manage your basic account preferences',
          style: TextStyle(color: SettingsPage._mutedColor, fontSize: 14),
        ),
        const SizedBox(height: 24),
        _buildDropdownField(
          label: 'Language',
          value: _language,
          options: _languages,
          onChanged: (value) => setState(() => _language = value),
        ),
        const SizedBox(height: 20),
        _buildDropdownField(
          label: 'Date Format',
          value: _dateFormat,
          options: _dateFormats,
          onChanged: (value) => setState(() => _dateFormat = value),
        ),
        const SizedBox(height: 28),
        SizedBox(
          width: double.infinity,
          height: 52,
          child: ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: SettingsPage._accentTeal,
              foregroundColor: Colors.white,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(14)),
              textStyle:
                  const TextStyle(fontSize: 15, fontWeight: FontWeight.w700),
              elevation: 0,
            ),
            onPressed: () {},
            child: const Text('Save account Settings'),
          ),
        ),
      ],
    );
  }

  Widget _buildPreferenceColumn() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const SizedBox(height: 4),
        _buildDropdownField(
          label: 'Timezone',
          value: _timezone,
          options: _timezones,
          onChanged: (value) => setState(() => _timezone = value),
        ),
        const SizedBox(height: 20),
        _buildDropdownField(
          label: 'Time format',
          value: _timeFormat,
          options: _timeFormats,
          onChanged: (value) => setState(() => _timeFormat = value),
        ),
      ],
    );
  }

  Widget _buildDropdownField({
    required String label,
    required String value,
    required List<String> options,
    required ValueChanged<String> onChanged,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: const TextStyle(
            color: SettingsPage._titleColor,
            fontSize: 14,
            fontWeight: FontWeight.w600,
          ),
        ),
        const SizedBox(height: 10),
        DropdownButtonFormField<String>(
          value: value,
          items: options
              .map(
                (option) => DropdownMenuItem<String>(
                  value: option,
                  child: Text(option),
                ),
              )
              .toList(),
          onChanged: (selected) {
            if (selected != null) {
              onChanged(selected);
            }
          },
          icon: const Icon(Icons.expand_more, color: SettingsPage._mutedColor),
          decoration: _dropdownDecoration(),
        ),
      ],
    );
  }

  Widget _buildDangerZone(bool stackButtons) {
    final Widget logoutButton = SizedBox(
      width: stackButtons ? double.infinity : 240,
      height: 54,
      child: OutlinedButton(
        style: OutlinedButton.styleFrom(
          foregroundColor: SettingsPage._titleColor,
          side: const BorderSide(color: SettingsPage._borderColor, width: 1.2),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
          textStyle: const TextStyle(fontSize: 15, fontWeight: FontWeight.w600),
        ),
        onPressed: () {},
        child: const Text('Log Out Of All Devices'),
      ),
    );

    final Widget deleteButton = SizedBox(
      width: stackButtons ? double.infinity : 240,
      height: 54,
      child: ElevatedButton(
        style: ElevatedButton.styleFrom(
          backgroundColor: SettingsPage._dangerRed,
          foregroundColor: Colors.white,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
          textStyle: const TextStyle(fontSize: 15, fontWeight: FontWeight.w700),
          elevation: 0,
        ),
        onPressed: () {},
        child: const Text('Delete Account'),
      ),
    );

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: const Border.fromBorderSide(
            BorderSide(color: SettingsPage._borderColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Danger Zone',
            style: TextStyle(
              color: SettingsPage._titleColor,
              fontSize: 18,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 6),
          const Text(
            'Irreversible and destructive actions for your account',
            style: TextStyle(color: SettingsPage._mutedColor, fontSize: 14),
          ),
          const SizedBox(height: 28),
          stackButtons
              ? Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    logoutButton,
                    const SizedBox(height: 16),
                    deleteButton,
                  ],
                )
              : Row(
                  children: [
                    logoutButton,
                    const SizedBox(width: 24),
                    deleteButton,
                  ],
                ),
        ],
      ),
    );
  }

  Widget _buildPlaceholder(SettingsTab tab) {
    final String label;
    switch (tab) {
      case SettingsTab.accounts:
        label = 'Accounts';
        break;
      case SettingsTab.notifications:
        label = 'Notifications';
        break;
      case SettingsTab.privacy:
        label = 'Privacy';
        break;
      case SettingsTab.security:
        label = 'Security';
        break;
    }

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(horizontal: 28, vertical: 48),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: const Border.fromBorderSide(
            BorderSide(color: SettingsPage._borderColor)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            '$label settings coming soon.',
            style: const TextStyle(
              color: SettingsPage._mutedColor,
              fontSize: 15,
            ),
          ),
        ],
      ),
    );
  }
}

class _SettingsTabBar extends StatelessWidget {
  const _SettingsTabBar({required this.activeTab, required this.onSelected});

  final SettingsTab activeTab;
  final ValueChanged<SettingsTab> onSelected;

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: SettingsPage._tabBackground,
        borderRadius: BorderRadius.circular(16),
        border: const Border.fromBorderSide(
            BorderSide(color: SettingsPage._borderColor)),
      ),
      child: Row(
        children: [
          Expanded(
            child: _SettingsTabButton(
              label: 'Accounts',
              icon: Icons.person_outline,
              isActive: activeTab == SettingsTab.accounts,
              onTap: () => onSelected(SettingsTab.accounts),
            ),
          ),
          const SizedBox(
            height: 54,
            child: VerticalDivider(
                color: SettingsPage._borderColor, thickness: 1, width: 1),
          ),
          Expanded(
            child: _SettingsTabButton(
              label: 'Notifications',
              icon: Icons.notifications_none,
              isActive: activeTab == SettingsTab.notifications,
              onTap: () => onSelected(SettingsTab.notifications),
            ),
          ),
          const SizedBox(
            height: 54,
            child: VerticalDivider(
                color: SettingsPage._borderColor, thickness: 1, width: 1),
          ),
          Expanded(
            child: _SettingsTabButton(
              label: 'Privacy',
              icon: Icons.privacy_tip_outlined,
              isActive: activeTab == SettingsTab.privacy,
              onTap: () => onSelected(SettingsTab.privacy),
            ),
          ),
          const SizedBox(
            height: 54,
            child: VerticalDivider(
                color: SettingsPage._borderColor, thickness: 1, width: 1),
          ),
          Expanded(
            child: _SettingsTabButton(
              label: 'Security',
              icon: Icons.lock_outline,
              isActive: activeTab == SettingsTab.security,
              onTap: () => onSelected(SettingsTab.security),
            ),
          ),
        ],
      ),
    );
  }
}

class _SettingsTabButton extends StatelessWidget {
  const _SettingsTabButton({
    required this.label,
    required this.icon,
    this.isActive = false,
    this.onTap,
  });

  final String label;
  final IconData icon;
  final bool isActive;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final Color background =
        isActive ? SettingsPage._tabActiveBackground : Colors.transparent;
    final Color contentColor =
        isActive ? SettingsPage._titleColor : SettingsPage._mutedColor;

    return Material(
      color: Colors.transparent,
      child: InkWell(
        borderRadius: BorderRadius.circular(16),
        onTap: onTap,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
          decoration: BoxDecoration(
            color: background,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(icon, color: contentColor, size: 18),
              const SizedBox(width: 10),
              Text(
                label,
                style: TextStyle(
                  color: contentColor,
                  fontSize: 15,
                  fontWeight: isActive ? FontWeight.w700 : FontWeight.w600,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _TutorialQuickButton extends StatefulWidget {
  final IconData icon;
  final String label;
  final String pageId;

  const _TutorialQuickButton({
    required this.icon,
    required this.label,
    required this.pageId,
  });

  @override
  State<_TutorialQuickButton> createState() => _TutorialQuickButtonState();
}

class _TutorialQuickButtonState extends State<_TutorialQuickButton> {
  bool _isHovered = false;

  static const Color _accentTeal = Color(0xFF1BA4B8);
  static const Color _titleColor = Color(0xFF111827);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE5E7EB);

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: GestureDetector(
        onTap: () => WalkthroughService().startWalkthrough(widget.pageId),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          decoration: BoxDecoration(
            color:
                _isHovered ? _accentTeal.withValues(alpha: 0.08) : Colors.white,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: _isHovered
                  ? _accentTeal.withValues(alpha: 0.4)
                  : _borderColor,
            ),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                widget.icon,
                size: 18,
                color: _isHovered ? _accentTeal : _mutedColor,
              ),
              const SizedBox(width: 8),
              Text(
                widget.label,
                style: TextStyle(
                  color: _isHovered ? _accentTeal : _titleColor,
                  fontSize: 13,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(width: 6),
              Icon(
                Icons.play_circle_outline,
                size: 16,
                color: _isHovered ? _accentTeal : _mutedColor,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class MyDocumentsPage extends StatefulWidget {
  const MyDocumentsPage({super.key});

  static const Color _titleColor = Color(0xFF111827);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE5E7EB);
  static const Color _buttonColor = Color(0xFF1BA4B8);
  static const Color _dropZoneColor = Color(0xFFF5F6FA);

  @override
  State<MyDocumentsPage> createState() => _MyDocumentsPageState();
}

class _MyDocumentsPageState extends State<MyDocumentsPage> {
  PlatformFile? _selectedFile;
  final TextEditingController _documentNameController = TextEditingController();

  @override
  void dispose() {
    _documentNameController.dispose();
    super.dispose();
  }

  Future<void> _pickFile() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: [
          'pdf',
          'doc',
          'docx',
          'ppt',
          'pptx',
          'jpg',
          'jpeg',
          'png',
          'mp4',
          'mov'
        ],
        withData: true,
      );
      if (result != null && result.files.isNotEmpty) {
        setState(() {
          _selectedFile = result.files.first;
          if (_documentNameController.text.isEmpty) {
            _documentNameController.text = _selectedFile!.name;
          }
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error picking file: $e')),
        );
      }
    }
  }

  Future<void> _uploadDocument() async {
    if (_selectedFile == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a file first')),
      );
      return;
    }
    if (_documentNameController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter a document name')),
      );
      return;
    }

    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please log in to upload documents')),
      );
      return;
    }

    try {
      await FirebaseFirestore.instance.collection('documents').add({
        'name': _documentNameController.text.trim(),
        'fileName': _selectedFile!.name,
        'fileSize': _selectedFile!.size,
        'fileExtension': _selectedFile!.extension,
        'uploadedBy': user.uid,
        'uploadedByEmail': user.email,
        'uploadedAt': FieldValue.serverTimestamp(),
        'type': 'upload',
      });

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Document uploaded successfully!')),
        );
        setState(() {
          _selectedFile = null;
          _documentNameController.clear();
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error uploading document: $e')),
        );
      }
    }
  }

  InputDecoration _inputDecoration(String hint) {
    return InputDecoration(
      hintText: hint,
      filled: true,
      fillColor: Colors.white,
      contentPadding: const EdgeInsets.symmetric(horizontal: 18, vertical: 18),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(16),
        borderSide: const BorderSide(color: MyDocumentsPage._borderColor),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(16),
        borderSide:
            const BorderSide(color: MyDocumentsPage._buttonColor, width: 1.4),
      ),
    );
  }

  Widget _uploadIllustration() {
    if (_selectedFile == null) {
      return Container(
        width: 320,
        height: 320,
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(28),
          border: Border.all(color: MyDocumentsPage._borderColor),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.04),
              blurRadius: 16,
              offset: const Offset(0, 8),
            ),
          ],
        ),
        child: const Center(
          child: Text(
            'No file selected',
            style: TextStyle(
              color: MyDocumentsPage._mutedColor,
              fontSize: 16,
            ),
          ),
        ),
      );
    }

    final isImage = ['jpg', 'jpeg', 'png', 'gif']
        .contains(_selectedFile!.extension?.toLowerCase());

    return Container(
      width: 320,
      height: 320,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(28),
        border: Border.all(color: MyDocumentsPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 16,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: isImage && _selectedFile!.bytes != null
          ? ClipRRect(
              borderRadius: BorderRadius.circular(28),
              child: Image.memory(
                _selectedFile!.bytes!,
                fit: BoxFit.cover,
              ),
            )
          : Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    _getFileIcon(_selectedFile!.extension),
                    size: 100,
                    color: MyDocumentsPage._buttonColor,
                  ),
                  const SizedBox(height: 16),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 24),
                    child: Text(
                      _selectedFile!.name,
                      textAlign: TextAlign.center,
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                      style: const TextStyle(
                        color: MyDocumentsPage._titleColor,
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    _formatFileSize(_selectedFile!.size),
                    style: const TextStyle(
                      color: MyDocumentsPage._mutedColor,
                      fontSize: 13,
                    ),
                  ),
                ],
              ),
            ),
    );
  }

  IconData _getFileIcon(String? extension) {
    switch (extension?.toLowerCase()) {
      case 'pdf':
        return Icons.picture_as_pdf;
      case 'doc':
      case 'docx':
        return Icons.description;
      case 'ppt':
      case 'pptx':
        return Icons.slideshow;
      case 'mp4':
      case 'mov':
        return Icons.video_library;
      default:
        return Icons.insert_drive_file;
    }
  }

  String _formatFileSize(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
  }

  Widget _dropZone() {
    return InkWell(
      onTap: _pickFile,
      borderRadius: BorderRadius.circular(28),
      child: Container(
        height: 320,
        decoration: BoxDecoration(
          color: MyDocumentsPage._dropZoneColor,
          borderRadius: BorderRadius.circular(28),
          border: Border.all(color: MyDocumentsPage._borderColor),
        ),
        child: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: const [
              Icon(Icons.cloud_upload_outlined,
                  color: MyDocumentsPage._mutedColor, size: 64),
              SizedBox(height: 16),
              Text(
                'Click to select file',
                style: TextStyle(
                  color: MyDocumentsPage._titleColor,
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                ),
              ),
              SizedBox(height: 8),
              Text(
                'PDF, DOC, PPT, Images, Videos',
                style: TextStyle(
                  color: MyDocumentsPage._mutedColor,
                  fontSize: 13,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final bool isCompact = constraints.maxWidth < 1120;
        final double horizontalPadding =
            constraints.maxWidth > 1180 ? 56.0 : 32.0;

        final Widget uploadSection = isCompact
            ? Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _uploadIllustration(),
                  const SizedBox(height: 24),
                  _dropZone(),
                ],
              )
            : Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _uploadIllustration(),
                  const SizedBox(width: 36),
                  Expanded(child: _dropZone()),
                ],
              );

        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'My Documents',
                          style: TextStyle(
                            color: MyDocumentsPage._titleColor,
                            fontSize: 24,
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                        SizedBox(height: 4),
                        Text(
                          'Access all your downloaded resources from the Breakaway365 program',
                          style: TextStyle(
                              color: MyDocumentsPage._mutedColor, fontSize: 16),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(width: 24),
                  ElevatedButton(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF3B6EF5),
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(
                          horizontal: 28, vertical: 16),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(16)),
                      elevation: 0,
                    ),
                    onPressed: () {
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (_) => const AICoachView(
                            url:
                                'https://app.gpt-trainer.com/widget/e75aedf2ab3541c28943d0094e09547f',
                          ),
                        ),
                      );
                    },
                    child: const Text(
                      'Breakaway365 AI Coach',
                      style:
                          TextStyle(fontWeight: FontWeight.w600, fontSize: 16),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 36),
              const Text(
                'Upload Document',
                style: TextStyle(
                  color: MyDocumentsPage._titleColor,
                  fontSize: 18,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 24),
              uploadSection,
              const SizedBox(height: 28),
              const Text(
                'Document Name',
                style: TextStyle(
                  color: MyDocumentsPage._titleColor,
                  fontSize: 14,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(height: 10),
              TextFormField(
                controller: _documentNameController,
                decoration: _inputDecoration('Document name'),
              ),
              const SizedBox(height: 32),
              Align(
                alignment: Alignment.centerRight,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: MyDocumentsPage._buttonColor,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(
                        horizontal: 32, vertical: 18),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(14)),
                    elevation: 0,
                  ),
                  onPressed: _uploadDocument,
                  child: const Text(
                    'Upload Document',
                    style: TextStyle(fontWeight: FontWeight.w600, fontSize: 16),
                  ),
                ),
              ),
              const SizedBox(height: 40),
              const Divider(color: MyDocumentsPage._borderColor),
              const SizedBox(height: 20),
              const _DocumentStatsRow(),
              const SizedBox(height: 24),
              const _DocumentList(),
            ],
          ),
        );
      },
    );
  }
}

class _DocumentStatsRow extends StatelessWidget {
  const _DocumentStatsRow();

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;

    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance.collection('documents').snapshots(),
      builder: (context, snapshot) {
        int downloadsCount = 0;
        int uploadsCount = 0;

        if (snapshot.hasData) {
          final docs = snapshot.data!.docs;
          downloadsCount = docs.where((doc) {
            final data = doc.data() as Map<String, dynamic>?;
            return data?['type'] == 'download';
          }).length;

          if (user != null) {
            uploadsCount = docs.where((doc) {
              final data = doc.data() as Map<String, dynamic>?;
              return data?['type'] == 'upload' &&
                  data?['uploadedBy'] == user.uid;
            }).length;
          }
        }

        return Row(
          children: [
            Expanded(
              child: Row(
                children: [
                  const Text(
                    'Your Downloads',
                    style: TextStyle(
                      color: MyDocumentsPage._titleColor,
                      fontSize: 16,
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  const SizedBox(width: 12),
                  Text(
                    '$downloadsCount items',
                    style: const TextStyle(
                        color: MyDocumentsPage._mutedColor, fontSize: 14),
                  ),
                ],
              ),
            ),
            const SizedBox(width: 40),
            Expanded(
              child: Row(
                children: [
                  const Text(
                    'Your Uploads',
                    style: TextStyle(
                      color: MyDocumentsPage._titleColor,
                      fontSize: 16,
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  const SizedBox(width: 12),
                  Text(
                    '$uploadsCount items',
                    style: const TextStyle(
                        color: MyDocumentsPage._mutedColor, fontSize: 14),
                  ),
                ],
              ),
            ),
          ],
        );
      },
    );
  }
}

class _DocumentList extends StatelessWidget {
  const _DocumentList();

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;

    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance
          .collection('documents')
          .orderBy('uploadedAt', descending: true)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(
            child: Padding(
              padding: EdgeInsets.all(24.0),
              child: CircularProgressIndicator(),
            ),
          );
        }

        if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
          return Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: const [
              Expanded(
                child: Center(
                  child: Padding(
                    padding: EdgeInsets.all(24.0),
                    child: Text(
                      'No downloads yet',
                      style: TextStyle(
                        color: MyDocumentsPage._mutedColor,
                        fontSize: 14,
                      ),
                    ),
                  ),
                ),
              ),
              SizedBox(width: 40),
              Expanded(
                child: Center(
                  child: Padding(
                    padding: EdgeInsets.all(24.0),
                    child: Text(
                      'No uploads yet',
                      style: TextStyle(
                        color: MyDocumentsPage._mutedColor,
                        fontSize: 14,
                      ),
                    ),
                  ),
                ),
              ),
            ],
          );
        }

        final allDocs = snapshot.data!.docs;
        final downloads = allDocs.where((doc) {
          final data = doc.data() as Map<String, dynamic>?;
          return data?['type'] == 'download';
        }).toList();

        final uploads = user != null
            ? allDocs.where((doc) {
                final data = doc.data() as Map<String, dynamic>?;
                return data?['type'] == 'upload' &&
                    data?['uploadedBy'] == user.uid;
              }).toList()
            : <QueryDocumentSnapshot>[];

        return Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              child: downloads.isEmpty
                  ? const Center(
                      child: Padding(
                        padding: EdgeInsets.all(24.0),
                        child: Text(
                          'No downloads yet',
                          style: TextStyle(
                            color: MyDocumentsPage._mutedColor,
                            fontSize: 14,
                          ),
                        ),
                      ),
                    )
                  : Column(
                      children: [
                        for (var i = 0; i < downloads.length; i++) ...[
                          _DocumentEntry(
                            docId: downloads[i].id,
                            data: downloads[i].data() as Map<String, dynamic>,
                          ),
                          if (i != downloads.length - 1)
                            const SizedBox(height: 20),
                        ],
                      ],
                    ),
            ),
            const SizedBox(width: 40),
            Expanded(
              child: uploads.isEmpty
                  ? const Center(
                      child: Padding(
                        padding: EdgeInsets.all(24.0),
                        child: Text(
                          'No uploads yet',
                          style: TextStyle(
                            color: MyDocumentsPage._mutedColor,
                            fontSize: 14,
                          ),
                        ),
                      ),
                    )
                  : Column(
                      children: [
                        for (var i = 0; i < uploads.length; i++) ...[
                          _DocumentEntry(
                            docId: uploads[i].id,
                            data: uploads[i].data() as Map<String, dynamic>,
                          ),
                          if (i != uploads.length - 1)
                            const SizedBox(height: 20),
                        ],
                      ],
                    ),
            ),
          ],
        );
      },
    );
  }
}

class _DocumentEntry extends StatelessWidget {
  const _DocumentEntry({required this.docId, required this.data});

  final String docId;
  final Map<String, dynamic> data;

  IconData _getFileIcon(String? extension) {
    switch (extension?.toLowerCase()) {
      case 'pdf':
        return Icons.picture_as_pdf;
      case 'doc':
      case 'docx':
        return Icons.description;
      case 'ppt':
      case 'pptx':
        return Icons.slideshow;
      case 'mp4':
      case 'mov':
        return Icons.video_library;
      case 'jpg':
      case 'jpeg':
      case 'png':
      case 'gif':
        return Icons.image;
      default:
        return Icons.insert_drive_file_outlined;
    }
  }

  String _formatFileSize(int? bytes) {
    if (bytes == null || bytes == 0) return '';
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
  }

  @override
  Widget build(BuildContext context) {
    final name = data['name'] as String? ?? 'Untitled';
    final fileName = data['fileName'] as String? ?? '';
    final fileExtension = data['fileExtension'] as String? ?? '';
    final fileSize = data['fileSize'] as int?;
    final description = data['description'] as String? ?? '';
    final uploadedAt = data['uploadedAt'] as Timestamp?;

    final dateStr = uploadedAt != null
        ? '${uploadedAt.toDate().day}/${uploadedAt.toDate().month}/${uploadedAt.toDate().year}'
        : '';

    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          width: 48,
          height: 48,
          decoration: BoxDecoration(
            color: const Color(0xFFE0E7FF),
            borderRadius: BorderRadius.circular(14),
          ),
          child: Icon(
            _getFileIcon(fileExtension),
            color: const Color(0xFF1E3A8A),
            size: 24,
          ),
        ),
        const SizedBox(width: 18),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                name,
                style: const TextStyle(
                  color: MyDocumentsPage._titleColor,
                  fontSize: 15,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                [
                  if (fileExtension.isNotEmpty) fileExtension.toUpperCase(),
                  if (fileSize != null) _formatFileSize(fileSize),
                  if (dateStr.isNotEmpty) dateStr,
                ].where((s) => s.isNotEmpty).join(' ¬∑ '),
                style: const TextStyle(
                  color: MyDocumentsPage._mutedColor,
                  fontSize: 13,
                  fontWeight: FontWeight.w600,
                ),
              ),
              if (description.isNotEmpty) ...[
                const SizedBox(height: 2),
                Text(
                  description,
                  style: const TextStyle(
                    color: MyDocumentsPage._mutedColor,
                    fontSize: 13,
                    height: 1.4,
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ],
          ),
        ),
      ],
    );
  }
}

class DiscussionForumPage extends StatefulWidget {
  const DiscussionForumPage({super.key});

  static const Color _titleColor = Color(0xFF111827);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE5E7EB);
  static const Color _tabBackground = Color(0xFFF5F6FA);
  static const Color _tabActiveBackground = Colors.white;
  static const Color _primaryBlue = Color(0xFF2563EB);

  static const List<_FriendSuggestionData> _friendSuggestions = [
    _FriendSuggestionData(
      name: 'Beth Niemann',
      email: 'beth@rivhc.com',
      details: <String>['no linkedIn', 'Riverside Home Care'],
    ),
    _FriendSuggestionData(
      name: 'Donna Young',
      email: 'donna@angelseniorcare.com',
      details: <String>['no linkedIn', 'Angel Senior Care'],
    ),
    _FriendSuggestionData(
      name: 'Megan',
      email: 'megan@breakaway365.com',
      details: <String>[
        'https://www.linkedin.com/in/megangould/',
        'add to agency'
      ],
      avatarUrl:
          'https://images.unsplash.com/photo-1535713875002-d1d0cf377fde?auto=format&fit=crop&w=200&q=80',
    ),
    _FriendSuggestionData(
      name: 'InfoBreakaway',
      email: 'info@breakaway365.com',
      details: <String>['no linkedIn', 'None'],
    ),
    _FriendSuggestionData(
      name: 'Developer',
      email: 'everisto@thestackone.com',
      details: <String>['Link here', 'add to agency'],
    ),
    _FriendSuggestionData(
      name: 'John Doe',
      email: 'chungu424@gmail.com',
      details: <String>['no linkedIn', 'add to agency'],
    ),
    _FriendSuggestionData(
      name: 'Krystal',
      email: 'kdw@adultcareassistance.com',
      details: <String>['Link here', 'Adultcare Assistance'],
    ),
  ];

  @override
  State<DiscussionForumPage> createState() => _DiscussionForumPageState();
}

class _DiscussionForumPageState extends State<DiscussionForumPage> {
  ForumTab _activeTab = ForumTab.forums;

  void _handleTabSelection(ForumTab tab) {
    if (_activeTab == tab) return;
    setState(() => _activeTab = tab);
  }

  Future<void> _openCreateForumDialog() async {
    final bool? created = await showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (dialogContext) => const _CreateForumDialog(),
    );

    if (created == true && mounted) {
      setState(() {});
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: const Text('Forum created successfully'),
          backgroundColor: DiscussionForumPage._primaryBlue,
          behavior: SnackBarBehavior.floating,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    }
  }

  Future<void> _openFriendRequestsSheet() async {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      if (!mounted) return;
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          SnackBar(
            content: const Text('Please sign in to view friend requests.'),
            backgroundColor: Colors.red.shade600,
            behavior: SnackBarBehavior.floating,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      return;
    }

    await showModalBottomSheet<void>(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) =>
          _FriendRequestsSheet(currentUserId: currentUser.uid),
    );
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final double horizontalPadding =
            constraints.maxWidth > 1200 ? 60.0 : 32.0;
        final bool stackSearchRow = constraints.maxWidth < 840;

        final Widget tabContent;
        switch (_activeTab) {
          case ForumTab.forums:
            tabContent = _buildForumsContent(stackSearchRow: stackSearchRow);
            break;
          case ForumTab.friends:
            tabContent = _buildFriendsContent(stackSearchRow: stackSearchRow);
            break;
          case ForumTab.coaches:
            tabContent = _buildCoachesPlaceholder();
            break;
        }

        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Discussion Forum',
                style: TextStyle(
                  color: DiscussionForumPage._titleColor,
                  fontSize: 24,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 6),
              const Text(
                'Connect with peers, join groups, and engage in learning discussions',
                style: TextStyle(
                    color: DiscussionForumPage._mutedColor, fontSize: 15),
              ),
              const SizedBox(height: 28),
              _ForumTabBar(
                selectedTab: _activeTab,
                onTabSelected: _handleTabSelection,
              ),
              const SizedBox(height: 28),
              tabContent,
            ],
          ),
        );
      },
    );
  }

  Widget _buildForumsContent({required bool stackSearchRow}) {
    final Widget searchInput = SizedBox(
      height: 54,
      child: TextField(
        decoration: InputDecoration(
          hintText: 'Search forums..',
          prefixIcon:
              const Icon(Icons.search, color: DiscussionForumPage._mutedColor),
          filled: true,
          fillColor: Colors.white,
          contentPadding:
              const EdgeInsets.symmetric(horizontal: 18, vertical: 16),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(18),
            borderSide:
                const BorderSide(color: DiscussionForumPage._borderColor),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(18),
            borderSide: const BorderSide(
                color: DiscussionForumPage._primaryBlue, width: 1.4),
          ),
        ),
      ),
    );

    final Widget createButton = SizedBox(
      height: 54,
      child: ElevatedButton(
        style: ElevatedButton.styleFrom(
          backgroundColor: const Color(0xFF3454F4),
          foregroundColor: Colors.white,
          padding: const EdgeInsets.symmetric(horizontal: 28),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          elevation: 0,
        ),
        onPressed: _openCreateForumDialog,
        child: const Text(
          'Create Forum',
          style: TextStyle(fontWeight: FontWeight.w700, fontSize: 15),
        ),
      ),
    );

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (stackSearchRow)
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              searchInput,
              const SizedBox(height: 16),
              createButton,
            ],
          )
        else
          Row(
            children: [
              Expanded(child: searchInput),
              const SizedBox(width: 20),
              createButton,
            ],
          ),
        const SizedBox(height: 32),
        const _ForumSectionHeading(label: 'Featured Forums'),
        const SizedBox(height: 20),
        const _FeaturedForumsSection(),
        const SizedBox(height: 36),
        const _ForumSectionHeading(label: 'My Forums'),
        const SizedBox(height: 20),
        const _MyForumsSection(),
      ],
    );
  }

  Widget _buildFriendsContent({required bool stackSearchRow}) {
    final Widget searchInput = SizedBox(
      height: 54,
      child: TextField(
        decoration: InputDecoration(
          hintText: 'Search for friends by name or username..',
          prefixIcon:
              const Icon(Icons.search, color: DiscussionForumPage._mutedColor),
          filled: true,
          fillColor: Colors.white,
          contentPadding:
              const EdgeInsets.symmetric(horizontal: 18, vertical: 16),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(18),
            borderSide:
                const BorderSide(color: DiscussionForumPage._borderColor),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(18),
            borderSide: const BorderSide(
                color: DiscussionForumPage._primaryBlue, width: 1.4),
          ),
        ),
      ),
    );

    final Widget viewRequestsButton = SizedBox(
      height: 54,
      child: ElevatedButton(
        style: ElevatedButton.styleFrom(
          backgroundColor: DiscussionForumPage._primaryBlue,
          foregroundColor: Colors.white,
          padding: const EdgeInsets.symmetric(horizontal: 24),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          elevation: 0,
        ),
        onPressed: _openFriendRequestsSheet,
        child: const Text(
          'View Requests',
          style: TextStyle(fontWeight: FontWeight.w700, fontSize: 15),
        ),
      ),
    );

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (stackSearchRow)
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              searchInput,
              const SizedBox(height: 16),
              viewRequestsButton,
            ],
          )
        else
          Row(
            children: [
              Expanded(child: searchInput),
              const SizedBox(width: 20),
              viewRequestsButton,
            ],
          ),
        const SizedBox(height: 28),
        const Text(
          'Find your friends and send them requests',
          style: TextStyle(
            color: DiscussionForumPage._mutedColor,
            fontSize: 15,
          ),
        ),
        const SizedBox(height: 24),
        _AllUsersList(),
        const SizedBox(height: 36),
        const _MyFriendsSection(),
      ],
    );
  }

  Widget _buildCoachesPlaceholder() {
    return const _CoachesTabContent();
  }
}

class _CoachesTabContent extends StatefulWidget {
  const _CoachesTabContent();

  @override
  State<_CoachesTabContent> createState() => _CoachesTabContentState();
}

class _CoachesTabContentState extends State<_CoachesTabContent> {
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _sendCoachRequest(String coachId, String coachName) async {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Please sign in to send requests')),
        );
      }
      return;
    }

    try {
      // Check if request already exists
      final existingRequest = await FirebaseFirestore.instance
          .collection('coachRequests')
          .where('fromUserId', isEqualTo: currentUser.uid)
          .where('toCoachId', isEqualTo: coachId)
          .where('status', isEqualTo: 'pending')
          .get();

      if (existingRequest.docs.isNotEmpty) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('You already have a pending request to $coachName'),
              behavior: SnackBarBehavior.floating,
            ),
          );
        }
        return;
      }

      // Get current user's name
      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(currentUser.uid)
          .get();
      final userData = userDoc.data();
      final firstName = userData?['firstName'] as String? ??
          userData?['first_name'] as String? ??
          '';
      final lastName = userData?['lastName'] as String? ??
          userData?['last_name'] as String? ??
          '';
      final fullName = '$firstName $lastName'.trim();
      final displayName = userData?['display_name'] as String? ??
          userData?['displayName'] as String? ??
          '';
      final userName = fullName.isNotEmpty
          ? fullName
          : (displayName.isNotEmpty
              ? displayName
              : currentUser.email?.split('@').first ?? 'User');

      // Add to coachRequests collection
      await FirebaseFirestore.instance.collection('coachRequests').add({
        'fromUserId': currentUser.uid,
        'fromUserName': userName,
        'fromUserEmail': currentUser.email,
        'toCoachId': coachId,
        'toCoachName': coachName,
        'status': 'pending',
        'message': 'I would like to connect with you as my coach.',
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      });

      // Also add user document reference to the coach's 'requests' field in users collection
      final userRef =
          FirebaseFirestore.instance.collection('users').doc(currentUser.uid);
      await FirebaseFirestore.instance.collection('users').doc(coachId).update({
        'requests': FieldValue.arrayUnion([userRef]),
      });

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Request sent to $coachName'),
            backgroundColor: const Color(0xFF22C55E),
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } catch (e) {
      debugPrint('Error sending coach request: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to send request: $e')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        SizedBox(
          height: 54,
          child: TextField(
            controller: _searchController,
            onChanged: (value) =>
                setState(() => _searchQuery = value.trim().toLowerCase()),
            decoration: InputDecoration(
              hintText: 'Search for coaches...',
              prefixIcon: const Icon(Icons.search,
                  color: DiscussionForumPage._mutedColor),
              suffixIcon: _searchQuery.isNotEmpty
                  ? IconButton(
                      onPressed: () {
                        _searchController.clear();
                        setState(() => _searchQuery = '');
                      },
                      icon: const Icon(Icons.close_rounded,
                          color: DiscussionForumPage._mutedColor),
                    )
                  : null,
              filled: true,
              fillColor: Colors.white,
              contentPadding:
                  const EdgeInsets.symmetric(horizontal: 18, vertical: 16),
              enabledBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(18),
                borderSide:
                    const BorderSide(color: DiscussionForumPage._borderColor),
              ),
              focusedBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(18),
                borderSide: const BorderSide(
                    color: DiscussionForumPage._primaryBlue, width: 1.4),
              ),
            ),
          ),
        ),
        const SizedBox(height: 24),
        const Text(
          'Available Coaches',
          style: TextStyle(
            color: DiscussionForumPage._titleColor,
            fontSize: 18,
            fontWeight: FontWeight.w700,
          ),
        ),
        const SizedBox(height: 8),
        const Text(
          'Send a request to connect with a coach',
          style:
              TextStyle(color: DiscussionForumPage._mutedColor, fontSize: 14),
        ),
        const SizedBox(height: 20),
        StreamBuilder<QuerySnapshot>(
          stream: FirebaseFirestore.instance
              .collection('users')
              .where('role', isEqualTo: 'Coach')
              .snapshots(),
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Center(
                child: Padding(
                  padding: EdgeInsets.all(32),
                  child: CircularProgressIndicator(),
                ),
              );
            }

            if (snapshot.hasError) {
              return Container(
                padding: const EdgeInsets.all(24),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(16),
                  border: Border.all(color: DiscussionForumPage._borderColor),
                ),
                child: const Text(
                  'Error loading coaches',
                  style: TextStyle(color: DiscussionForumPage._mutedColor),
                ),
              );
            }

            final coaches = snapshot.data?.docs ?? [];
            final filteredCoaches = coaches.where((doc) {
              if (_searchQuery.isEmpty) return true;
              final data = doc.data() as Map<String, dynamic>;
              final firstName = (data['firstName'] as String? ??
                      data['first_name'] as String? ??
                      '')
                  .toLowerCase();
              final lastName = (data['lastName'] as String? ??
                      data['last_name'] as String? ??
                      '')
                  .toLowerCase();
              final displayName = (data['display_name'] as String? ??
                      data['displayName'] as String? ??
                      '')
                  .toLowerCase();
              final email = (data['email'] as String? ?? '').toLowerCase();
              return firstName.contains(_searchQuery) ||
                  lastName.contains(_searchQuery) ||
                  displayName.contains(_searchQuery) ||
                  email.contains(_searchQuery);
            }).toList();

            if (filteredCoaches.isEmpty) {
              return Container(
                width: double.infinity,
                padding: const EdgeInsets.all(48),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(20),
                  border: Border.all(color: DiscussionForumPage._borderColor),
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(Icons.person_search_outlined,
                        size: 56, color: Colors.grey.shade300),
                    const SizedBox(height: 16),
                    Text(
                      _searchQuery.isNotEmpty
                          ? 'No coaches found'
                          : 'No coaches available',
                      style: const TextStyle(
                        color: DiscussionForumPage._titleColor,
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      _searchQuery.isNotEmpty
                          ? 'Try a different search term'
                          : 'Check back later for available coaches',
                      style: const TextStyle(
                          color: DiscussionForumPage._mutedColor, fontSize: 14),
                    ),
                  ],
                ),
              );
            }

            return ListView.separated(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: filteredCoaches.length,
              separatorBuilder: (_, __) => const SizedBox(height: 12),
              itemBuilder: (context, index) {
                final doc = filteredCoaches[index];
                final data = doc.data() as Map<String, dynamic>;
                final firstName = data['firstName'] as String? ??
                    data['first_name'] as String? ??
                    '';
                final lastName = data['lastName'] as String? ??
                    data['last_name'] as String? ??
                    '';
                final fullName = '$firstName $lastName'.trim();
                // Prioritize first + last name, then display_name/displayName
                final displayName = data['display_name'] as String? ??
                    data['displayName'] as String? ??
                    '';
                final coachName = fullName.isNotEmpty
                    ? fullName
                    : (displayName.isNotEmpty ? displayName : 'Coach');
                final photoUrl = data['photoURL'] as String?;
                final bio = data['bio'] as String? ??
                    'Certified coach ready to help you achieve your goals.';

                return _CoachRequestCard(
                  coachId: doc.id,
                  coachName: coachName,
                  photoUrl: photoUrl,
                  bio: bio,
                  onSendRequest: () async =>
                      _sendCoachRequest(doc.id, coachName),
                );
              },
            );
          },
        ),
        const SizedBox(height: 32),
        const Text(
          'My Coach Requests',
          style: TextStyle(
            color: DiscussionForumPage._titleColor,
            fontSize: 18,
            fontWeight: FontWeight.w700,
          ),
        ),
        const SizedBox(height: 16),
        _MyCoachRequestsList(),
      ],
    );
  }
}

class _CoachRequestCard extends StatefulWidget {
  const _CoachRequestCard({
    required this.coachId,
    required this.coachName,
    required this.photoUrl,
    required this.bio,
    required this.onSendRequest,
  });

  final String coachId;
  final String coachName;
  final String? photoUrl;
  final String bio;
  final Future<void> Function() onSendRequest;

  @override
  State<_CoachRequestCard> createState() => _CoachRequestCardState();
}

class _CoachRequestCardState extends State<_CoachRequestCard> {
  bool _isSending = false;

  Future<void> _handleSendRequest() async {
    setState(() => _isSending = true);
    try {
      await widget.onSendRequest();
    } finally {
      if (mounted) setState(() => _isSending = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final currentUser = FirebaseAuth.instance.currentUser;

    return Container(
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: DiscussionForumPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.03),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Row(
        children: [
          CircleAvatar(
            radius: 28,
            backgroundColor: const Color(0xFFF3F4F6),
            backgroundImage:
                widget.photoUrl != null ? NetworkImage(widget.photoUrl!) : null,
            child: widget.photoUrl == null
                ? Text(
                    widget.coachName.isNotEmpty
                        ? widget.coachName[0].toUpperCase()
                        : 'C',
                    style: const TextStyle(
                      color: DiscussionForumPage._titleColor,
                      fontWeight: FontWeight.w700,
                      fontSize: 20,
                    ),
                  )
                : null,
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  widget.coachName,
                  style: const TextStyle(
                    color: DiscussionForumPage._titleColor,
                    fontSize: 16,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  widget.bio,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                  style: const TextStyle(
                      color: DiscussionForumPage._mutedColor, fontSize: 13),
                ),
              ],
            ),
          ),
          const SizedBox(width: 12),
          if (currentUser != null)
            StreamBuilder<QuerySnapshot>(
              stream: FirebaseFirestore.instance
                  .collection('coachRequests')
                  .where('fromUserId', isEqualTo: currentUser.uid)
                  .where('toCoachId', isEqualTo: widget.coachId)
                  .snapshots(),
              builder: (context, snapshot) {
                final hasExistingRequest =
                    snapshot.hasData && snapshot.data!.docs.isNotEmpty;
                String? requestStatus;
                if (hasExistingRequest) {
                  final data =
                      snapshot.data!.docs.first.data() as Map<String, dynamic>;
                  requestStatus = data['status'] as String? ?? 'pending';
                }

                final isPending = requestStatus == 'pending';
                final isAccepted = requestStatus == 'accepted';
                final isRejected = requestStatus == 'rejected';

                String buttonText;
                Color bgColor;
                Color fgColor;
                bool isDisabled;

                if (_isSending) {
                  buttonText = 'Sending...';
                  bgColor =
                      DiscussionForumPage._primaryBlue.withValues(alpha: 0.6);
                  fgColor = Colors.white;
                  isDisabled = true;
                } else if (isPending) {
                  buttonText = 'Request Sent';
                  bgColor = const Color(0xFFF59E0B).withValues(alpha: 0.15);
                  fgColor = const Color(0xFFF59E0B);
                  isDisabled = true;
                } else if (isAccepted) {
                  buttonText = 'Connected';
                  bgColor = const Color(0xFF22C55E).withValues(alpha: 0.15);
                  fgColor = const Color(0xFF22C55E);
                  isDisabled = true;
                } else if (isRejected) {
                  buttonText = 'Send Request';
                  bgColor = DiscussionForumPage._primaryBlue;
                  fgColor = Colors.white;
                  isDisabled = false;
                } else {
                  buttonText = 'Send Request';
                  bgColor = DiscussionForumPage._primaryBlue;
                  fgColor = Colors.white;
                  isDisabled = false;
                }

                return ElevatedButton(
                  onPressed: isDisabled ? null : _handleSendRequest,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: bgColor,
                    foregroundColor: fgColor,
                    disabledBackgroundColor: bgColor,
                    disabledForegroundColor: fgColor,
                    padding: const EdgeInsets.symmetric(
                        horizontal: 20, vertical: 12),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12)),
                    elevation: 0,
                  ),
                  child: Text(buttonText,
                      style: const TextStyle(fontWeight: FontWeight.w600)),
                );
              },
            )
          else
            ElevatedButton(
              onPressed: () => _handleSendRequest(),
              style: ElevatedButton.styleFrom(
                backgroundColor: DiscussionForumPage._primaryBlue,
                foregroundColor: Colors.white,
                padding:
                    const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12)),
                elevation: 0,
              ),
              child: const Text('Send Request',
                  style: TextStyle(fontWeight: FontWeight.w600)),
            ),
        ],
      ),
    );
  }
}

class _MyCoachRequestsList extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      return Container(
        padding: const EdgeInsets.all(24),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: DiscussionForumPage._borderColor),
        ),
        child: const Text(
          'Please sign in to view your requests',
          style: TextStyle(color: DiscussionForumPage._mutedColor),
        ),
      );
    }

    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance
          .collection('coachRequests')
          .where('fromUserId', isEqualTo: currentUser.uid)
          .orderBy('createdAt', descending: true)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Padding(
            padding: EdgeInsets.all(24),
            child: Center(child: CircularProgressIndicator(strokeWidth: 2)),
          );
        }

        final requests = snapshot.data?.docs ?? [];

        if (requests.isEmpty) {
          return Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(16),
              border: Border.all(color: DiscussionForumPage._borderColor),
            ),
            child: const Text(
              'You haven\'t sent any coach requests yet',
              style: TextStyle(
                  color: DiscussionForumPage._mutedColor, fontSize: 14),
            ),
          );
        }

        return ListView.separated(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          itemCount: requests.length,
          separatorBuilder: (_, __) => const SizedBox(height: 10),
          itemBuilder: (context, index) {
            final data = requests[index].data() as Map<String, dynamic>;
            final coachName = data['toCoachName'] as String? ?? 'Coach';
            final status = data['status'] as String? ?? 'pending';
            final createdAt = data['createdAt'] as Timestamp?;
            final dateStr = createdAt != null
                ? '${createdAt.toDate().month}/${createdAt.toDate().day}/${createdAt.toDate().year}'
                : '';

            Color statusColor;
            IconData statusIcon;
            switch (status) {
              case 'accepted':
                statusColor = const Color(0xFF22C55E);
                statusIcon = Icons.check_circle;
                break;
              case 'rejected':
                statusColor = const Color(0xFFEF4444);
                statusIcon = Icons.cancel;
                break;
              default:
                statusColor = const Color(0xFFF59E0B);
                statusIcon = Icons.schedule;
            }

            return Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(14),
                border: Border.all(color: DiscussionForumPage._borderColor),
              ),
              child: Row(
                children: [
                  Icon(statusIcon, color: statusColor, size: 20),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Request to $coachName',
                          style: const TextStyle(
                            color: DiscussionForumPage._titleColor,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        if (dateStr.isNotEmpty)
                          Text(
                            dateStr,
                            style: const TextStyle(
                                color: DiscussionForumPage._mutedColor,
                                fontSize: 12),
                          ),
                      ],
                    ),
                  ),
                  Container(
                    padding:
                        const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                    decoration: BoxDecoration(
                      color: statusColor.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(20),
                    ),
                    child: Text(
                      status.toUpperCase(),
                      style: TextStyle(
                        color: statusColor,
                        fontSize: 11,
                        fontWeight: FontWeight.w700,
                      ),
                    ),
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }
}

class _ForumTabBar extends StatelessWidget {
  const _ForumTabBar({required this.selectedTab, required this.onTabSelected});

  final ForumTab selectedTab;
  final ValueChanged<ForumTab> onTabSelected;

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: DiscussionForumPage._tabBackground,
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: DiscussionForumPage._borderColor),
      ),
      child: Row(
        children: [
          Expanded(
            child: _ForumTabButton(
              label: 'Forums',
              isActive: selectedTab == ForumTab.forums,
              onTap: () => onTabSelected(ForumTab.forums),
            ),
          ),
          const SizedBox(
            height: 52,
            child: VerticalDivider(
                color: DiscussionForumPage._borderColor,
                thickness: 1,
                width: 1),
          ),
          Expanded(
            child: _ForumTabButton(
              label: 'Friends',
              isActive: selectedTab == ForumTab.friends,
              onTap: () => onTabSelected(ForumTab.friends),
            ),
          ),
          const SizedBox(
            height: 52,
            child: VerticalDivider(
                color: DiscussionForumPage._borderColor,
                thickness: 1,
                width: 1),
          ),
          Expanded(
            child: _ForumTabButton(
              label: 'Coaches',
              isActive: selectedTab == ForumTab.coaches,
              onTap: () => onTabSelected(ForumTab.coaches),
            ),
          ),
        ],
      ),
    );
  }
}

class _ForumTabButton extends StatelessWidget {
  const _ForumTabButton(
      {required this.label, this.isActive = false, this.onTap});

  final String label;
  final bool isActive;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final Color background = isActive
        ? DiscussionForumPage._tabActiveBackground
        : Colors.transparent;
    final Color textColor = isActive
        ? DiscussionForumPage._titleColor
        : DiscussionForumPage._mutedColor;

    return Material(
      color: Colors.transparent,
      child: InkWell(
        borderRadius: BorderRadius.circular(18),
        onTap: onTap,
        child: Container(
          decoration: BoxDecoration(
            color: background,
            borderRadius: BorderRadius.circular(18),
          ),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 18),
          alignment: Alignment.center,
          child: Text(
            label,
            style: TextStyle(
              color: textColor,
              fontSize: 15,
              fontWeight: isActive ? FontWeight.w700 : FontWeight.w600,
            ),
          ),
        ),
      ),
    );
  }
}

class _FeaturedForumsSection extends StatelessWidget {
  const _FeaturedForumsSection();

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<QuerySnapshot>(
      stream:
          FirebaseFirestore.instance.collection('forums').limit(3).snapshots(),
      builder: (context, snapshot) {
        print(
            'üìã Featured Forums - connectionState: ${snapshot.connectionState}');
        print('üìã Featured Forums - hasError: ${snapshot.hasError}');
        if (snapshot.hasError) {
          print('‚ùå Featured Forums error: ${snapshot.error}');
        }
        print('üìã Featured Forums - hasData: ${snapshot.hasData}');
        print(
            'üìã Featured Forums - docs count: ${snapshot.data?.docs.length ?? 0}');
        // Log each forum's data for debugging
        snapshot.data?.docs.forEach((doc) {
          final data = doc.data() as Map<String, dynamic>;
          print(
              'üîç Forum: ${data['title']} by ${data['creatorName']} at ${data['createdAt']}');
        });
        if (snapshot.connectionState == ConnectionState.waiting) {
          return Column(
            children: List.generate(
              1,
              (index) => Container(
                margin: const EdgeInsets.only(bottom: 16),
                height: 200,
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(26),
                  border: Border.all(color: DiscussionForumPage._borderColor),
                ),
              ),
            ),
          );
        }

        if (snapshot.hasError) {
          return Text('Error: ${snapshot.error}');
        }

        final forums = snapshot.data?.docs ?? [];
        if (forums.isEmpty) {
          return Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 36),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(24),
              border: Border.all(color: DiscussionForumPage._borderColor),
            ),
            child: const Text(
              'No forums available yet.',
              style: TextStyle(
                  color: DiscussionForumPage._mutedColor, fontSize: 14),
            ),
          );
        }

        return Column(
          children: [
            ...forums.asMap().entries.map((entry) {
              final doc = entry.value;
              final forum = doc.data() as Map<String, dynamic>;
              forum['id'] = doc.id;
              return _ForumCard(forum: forum);
            }),
            const SizedBox(height: 20),
            if (forums.length == 3)
              GestureDetector(
                onTap: () => _showAllForums(context),
                child: const Text(
                  'View All',
                  style: TextStyle(
                    color: DiscussionForumPage._primaryBlue,
                    fontSize: 14,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
          ],
        );
      },
    );
  }

  void _showAllForums(BuildContext context) {
    showDialog(
      context: context,
      builder: (dialogContext) => const _AllForumsDialog(),
    );
  }
}

class _ForumCard extends StatelessWidget {
  const _ForumCard({required this.forum});

  final Map<String, dynamic> forum;

  void _openForumDetail(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => _ForumDetailSheet(forum: forum),
    );
  }

  @override
  Widget build(BuildContext context) {
    final String title = forum['title'] ?? 'Untitled Forum';
    final String body = forum['body'] ?? '';
    final int commentCount = forum['commentsCount'] ?? 0;

    return Container(
      width: double.infinity,
      margin: const EdgeInsets.only(bottom: 16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(26),
        border: Border.all(color: DiscussionForumPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      padding: const EdgeInsets.fromLTRB(28, 28, 28, 28),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: const TextStyle(
                        color: DiscussionForumPage._titleColor,
                        fontSize: 18,
                        fontWeight: FontWeight.w700,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    if (body.isNotEmpty) ...[
                      const SizedBox(height: 10),
                      Text(
                        body,
                        style: const TextStyle(
                          color: DiscussionForumPage._mutedColor,
                          fontSize: 14,
                          height: 1.5,
                        ),
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ],
                ),
              ),
              const SizedBox(width: 24),
              SizedBox(
                height: 46,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: DiscussionForumPage._primaryBlue,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(horizontal: 24),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(14)),
                    elevation: 0,
                  ),
                  onPressed: () => _openForumDetail(context),
                  child: const Text(
                    'View',
                    style: TextStyle(fontWeight: FontWeight.w700, fontSize: 14),
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 24),
          const Divider(color: DiscussionForumPage._borderColor),
          const SizedBox(height: 16),
          Text(
            '$commentCount Comments',
            style: const TextStyle(
                color: DiscussionForumPage._mutedColor,
                fontSize: 13,
                fontWeight: FontWeight.w600),
          ),
        ],
      ),
    );
  }
}

class _ForumDetailSheet extends StatefulWidget {
  const _ForumDetailSheet({required this.forum});

  final Map<String, dynamic> forum;

  @override
  State<_ForumDetailSheet> createState() => _ForumDetailSheetState();
}

class _ForumDetailSheetState extends State<_ForumDetailSheet> {
  final _commentController = TextEditingController();
  bool _submittingComment = false;
  bool _deletingForum = false;
  PlatformFile? _selectedMedia;
  bool _uploadingMedia = false;

  @override
  void initState() {
    super.initState();
    _commentController.addListener(() {
      setState(() {}); // Rebuild to update send button state
    });
  }

  @override
  void dispose() {
    _commentController.dispose();
    super.dispose();
  }

  Future<void> _pickMedia() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.media,
        allowMultiple: false,
        withData: true,
      );

      if (result != null && result.files.isNotEmpty) {
        setState(() => _selectedMedia = result.files.first);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to pick media: $e'),
            backgroundColor: Colors.red.shade600,
          ),
        );
      }
    }
  }

  void _clearSelectedMedia() {
    setState(() => _selectedMedia = null);
  }

  Future<void> _postComment() async {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) return;

    final text = _commentController.text.trim();
    // Allow sending if either text exists OR media is selected
    if (text.isEmpty && _selectedMedia == null) return;

    setState(() => _submittingComment = true);

    try {
      final forumId = widget.forum['id'] as String?;
      if (forumId == null) throw Exception('Forum ID is missing');

      String? mediaUrl;
      String? mediaType;
      String? mediaName;

      // Upload media if selected
      if (_selectedMedia != null) {
        setState(() => _uploadingMedia = true);
        try {
          final fileName =
              'forum_comments/$forumId/${DateTime.now().millisecondsSinceEpoch}_${_selectedMedia!.name}';
          final storageRef = FirebaseStorage.instance.ref().child(fileName);

          final metadata = SettableMetadata(
            contentType: _selectedMedia!.extension != null
                ? 'image/${_selectedMedia!.extension}'
                : 'application/octet-stream',
          );

          await storageRef.putData(_selectedMedia!.bytes!, metadata);
          mediaUrl = await storageRef.getDownloadURL();
          mediaType = _selectedMedia!.extension;
          mediaName = _selectedMedia!.name;
        } catch (e) {
          // If media upload fails, continue without it but log the error
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Media upload failed: $e'),
                backgroundColor: Colors.orange.shade700,
              ),
            );
          }
        } finally {
          setState(() => _uploadingMedia = false);
        }
      }

      await FirebaseFirestore.instance
          .collection('forums')
          .doc(forumId)
          .collection('comments')
          .add({
        'text': text,
        'userId': currentUser.uid,
        'userName': currentUser.displayName ?? currentUser.email ?? 'User',
        'userAvatar': currentUser.photoURL,
        'createdAt': FieldValue.serverTimestamp(),
        if (mediaUrl != null) 'mediaUrl': mediaUrl,
        if (mediaType != null) 'mediaType': mediaType,
        if (mediaName != null) 'mediaName': mediaName,
      });

      await FirebaseFirestore.instance
          .collection('forums')
          .doc(forumId)
          .update({'commentsCount': FieldValue.increment(1)});

      _commentController.clear();
      _clearSelectedMedia();
      FocusScope.of(context).unfocus();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to post comment: $e'),
            backgroundColor: Colors.red.shade600,
          ),
        );
      }
    } finally {
      if (mounted) setState(() => _submittingComment = false);
    }
  }

  Future<void> _deleteForum() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: const Text('Delete Forum'),
        content: const Text(
            'Are you sure you want to delete this forum? This action cannot be undone.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red.shade600,
              foregroundColor: Colors.white,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
            ),
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Delete'),
          ),
        ],
      ),
    );

    if (confirmed != true) return;

    setState(() => _deletingForum = true);

    try {
      final forumId = widget.forum['id'] as String?;
      if (forumId == null) throw Exception('Forum ID is missing');

      final commentsSnapshot = await FirebaseFirestore.instance
          .collection('forums')
          .doc(forumId)
          .collection('comments')
          .get();

      for (final doc in commentsSnapshot.docs) {
        await doc.reference.delete();
      }

      await FirebaseFirestore.instance
          .collection('forums')
          .doc(forumId)
          .delete();

      if (mounted) {
        Navigator.pop(context);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('Forum deleted successfully'),
            backgroundColor: DiscussionForumPage._primaryBlue,
            behavior: SnackBarBehavior.floating,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to delete forum: $e'),
            backgroundColor: Colors.red.shade600,
          ),
        );
      }
    } finally {
      if (mounted) setState(() => _deletingForum = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final currentUser = FirebaseAuth.instance.currentUser;
    final forumId = widget.forum['id'] as String?;
    final title = widget.forum['title'] ?? 'Untitled Forum';
    final body = widget.forum['body'] ?? '';
    final imageUrl = widget.forum['imageUrl'] as String?;
    final creatorName = widget.forum['creatorName'] ?? 'Anonymous';
    final createdBy = widget.forum['createdBy'] as String?;
    final isAuthor = currentUser != null && createdBy == currentUser.uid;

    return DraggableScrollableSheet(
      initialChildSize: 0.9,
      minChildSize: 0.5,
      maxChildSize: 0.95,
      builder: (context, scrollController) => Container(
        decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.vertical(top: Radius.circular(28)),
        ),
        child: Column(
          children: [
            Container(
              margin: const EdgeInsets.only(top: 12),
              width: 48,
              height: 4,
              decoration: BoxDecoration(
                color: DiscussionForumPage._borderColor,
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            Padding(
              padding: const EdgeInsets.fromLTRB(24, 20, 24, 16),
              child: Row(
                children: [
                  const Expanded(
                    child: Text(
                      'Forum Details',
                      style: TextStyle(
                        fontSize: 22,
                        fontWeight: FontWeight.w700,
                        color: DiscussionForumPage._titleColor,
                      ),
                    ),
                  ),
                  if (isAuthor)
                    IconButton(
                      icon: Icon(Icons.delete_outline,
                          color: Colors.red.shade600),
                      onPressed: _deletingForum ? null : _deleteForum,
                      tooltip: 'Delete Forum',
                    ),
                  IconButton(
                    icon: const Icon(Icons.close,
                        color: DiscussionForumPage._mutedColor),
                    onPressed: () => Navigator.pop(context),
                  ),
                ],
              ),
            ),
            const Divider(height: 1, color: DiscussionForumPage._borderColor),
            Expanded(
              child: ListView(
                controller: scrollController,
                padding: const EdgeInsets.all(24),
                children: [
                  if (imageUrl != null && imageUrl.isNotEmpty) ...[
                    ClipRRect(
                      borderRadius: BorderRadius.circular(20),
                      child: Image.network(
                        imageUrl,
                        fit: BoxFit.cover,
                        height: 240,
                        width: double.infinity,
                        errorBuilder: (context, error, stack) => Container(
                          height: 240,
                          decoration: BoxDecoration(
                            color: DiscussionForumPage._tabBackground,
                            borderRadius: BorderRadius.circular(20),
                          ),
                          child: const Icon(
                            Icons.image_not_supported_outlined,
                            size: 64,
                            color: DiscussionForumPage._mutedColor,
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(height: 24),
                  ],
                  Row(
                    children: [
                      CircleAvatar(
                        radius: 24,
                        backgroundColor: DiscussionForumPage._primaryBlue
                            .withValues(alpha: 0.1),
                        child: Text(
                          creatorName.isNotEmpty
                              ? creatorName[0].toUpperCase()
                              : '?',
                          style: const TextStyle(
                            color: DiscussionForumPage._primaryBlue,
                            fontWeight: FontWeight.w700,
                            fontSize: 18,
                          ),
                        ),
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              creatorName,
                              style: const TextStyle(
                                color: DiscussionForumPage._titleColor,
                                fontSize: 16,
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                            const SizedBox(height: 2),
                            Text(
                              _formatTimestamp(widget.forum['createdAt']),
                              style: const TextStyle(
                                color: DiscussionForumPage._mutedColor,
                                fontSize: 13,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 24),
                  Text(
                    title,
                    style: const TextStyle(
                      color: DiscussionForumPage._titleColor,
                      fontSize: 24,
                      fontWeight: FontWeight.w700,
                      height: 1.3,
                    ),
                  ),
                  if (body.isNotEmpty) ...[
                    const SizedBox(height: 16),
                    Text(
                      body,
                      style: const TextStyle(
                        color: DiscussionForumPage._titleColor,
                        fontSize: 15,
                        height: 1.6,
                      ),
                    ),
                  ],
                  const SizedBox(height: 32),
                  const Divider(color: DiscussionForumPage._borderColor),
                  const SizedBox(height: 24),
                  const Row(
                    children: [
                      Icon(
                        Icons.chat_bubble_outline,
                        size: 20,
                        color: DiscussionForumPage._titleColor,
                      ),
                      SizedBox(width: 8),
                      Text(
                        'Comments',
                        style: TextStyle(
                          color: DiscussionForumPage._titleColor,
                          fontSize: 18,
                          fontWeight: FontWeight.w700,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 20),
                  if (forumId != null)
                    _CommentsSection(forumId: forumId)
                  else
                    const Padding(
                      padding: EdgeInsets.all(24),
                      child: Text(
                        'Unable to load comments',
                        style:
                            TextStyle(color: DiscussionForumPage._mutedColor),
                        textAlign: TextAlign.center,
                      ),
                    ),
                ],
              ),
            ),
            if (currentUser != null) ...[
              const Divider(height: 1, color: DiscussionForumPage._borderColor),
              Container(
                padding: const EdgeInsets.fromLTRB(24, 16, 24, 24),
                child: Column(
                  children: [
                    if (_selectedMedia != null)
                      Container(
                        margin: const EdgeInsets.only(bottom: 12),
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: DiscussionForumPage._tabBackground,
                          borderRadius: BorderRadius.circular(12),
                          border: Border.all(
                            color: DiscussionForumPage._primaryBlue
                                .withValues(alpha: 0.3),
                          ),
                        ),
                        child: Row(
                          children: [
                            Container(
                              width: 48,
                              height: 48,
                              decoration: BoxDecoration(
                                color: DiscussionForumPage._primaryBlue
                                    .withValues(alpha: 0.1),
                                borderRadius: BorderRadius.circular(8),
                              ),
                              child: Icon(
                                _selectedMedia!.extension?.toLowerCase() ==
                                            'mp4' ||
                                        _selectedMedia!.extension
                                                ?.toLowerCase() ==
                                            'mov'
                                    ? Icons.video_library
                                    : Icons.image,
                                color: DiscussionForumPage._primaryBlue,
                                size: 24,
                              ),
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    _selectedMedia!.name,
                                    style: const TextStyle(
                                      color: DiscussionForumPage._titleColor,
                                      fontSize: 14,
                                      fontWeight: FontWeight.w600,
                                    ),
                                    maxLines: 1,
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                  const SizedBox(height: 4),
                                  Text(
                                    '${(_selectedMedia!.size / 1024 / 1024).toStringAsFixed(2)} MB',
                                    style: const TextStyle(
                                      color: DiscussionForumPage._mutedColor,
                                      fontSize: 12,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                            IconButton(
                              icon: const Icon(Icons.close, size: 20),
                              onPressed: _clearSelectedMedia,
                              color: DiscussionForumPage._mutedColor,
                            ),
                          ],
                        ),
                      ),
                    Row(
                      crossAxisAlignment: CrossAxisAlignment.end,
                      children: [
                        Material(
                          color: DiscussionForumPage._tabBackground,
                          borderRadius: BorderRadius.circular(16),
                          child: InkWell(
                            onTap: _submittingComment ? null : _pickMedia,
                            borderRadius: BorderRadius.circular(16),
                            child: Container(
                              width: 56,
                              height: 56,
                              alignment: Alignment.center,
                              child: const Icon(
                                Icons.attach_file,
                                color: DiscussionForumPage._titleColor,
                                size: 24,
                              ),
                            ),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: TextField(
                            controller: _commentController,
                            maxLines: null,
                            decoration: InputDecoration(
                              hintText: 'Add a comment...',
                              hintStyle: const TextStyle(
                                color: DiscussionForumPage._mutedColor,
                                fontSize: 14,
                              ),
                              filled: true,
                              fillColor: DiscussionForumPage._tabBackground,
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(20),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(
                                horizontal: 20,
                                vertical: 14,
                              ),
                            ),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Material(
                          color: (_commentController.text.trim().isNotEmpty ||
                                  _selectedMedia != null)
                              ? DiscussionForumPage._primaryBlue
                              : DiscussionForumPage._mutedColor
                                  .withValues(alpha: 0.3),
                          borderRadius: BorderRadius.circular(16),
                          child: InkWell(
                            onTap: (_submittingComment ||
                                    _uploadingMedia ||
                                    (_commentController.text.trim().isEmpty &&
                                        _selectedMedia == null))
                                ? null
                                : _postComment,
                            borderRadius: BorderRadius.circular(16),
                            child: Container(
                              width: 56,
                              height: 56,
                              alignment: Alignment.center,
                              child: _submittingComment || _uploadingMedia
                                  ? const SizedBox(
                                      width: 24,
                                      height: 24,
                                      child: CircularProgressIndicator(
                                        strokeWidth: 2,
                                        valueColor:
                                            AlwaysStoppedAnimation<Color>(
                                                Colors.white),
                                      ),
                                    )
                                  : const Icon(
                                      Icons.send_rounded,
                                      color: Colors.white,
                                      size: 24,
                                    ),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  String _formatTimestamp(dynamic timestamp) {
    if (timestamp == null) return 'Just now';
    try {
      final DateTime dateTime = (timestamp as Timestamp).toDate();
      final now = DateTime.now();
      final difference = now.difference(dateTime);

      if (difference.inDays > 7) {
        return '${dateTime.day}/${dateTime.month}/${dateTime.year}';
      } else if (difference.inDays > 0) {
        return '${difference.inDays}d ago';
      } else if (difference.inHours > 0) {
        return '${difference.inHours}h ago';
      } else if (difference.inMinutes > 0) {
        return '${difference.inMinutes}m ago';
      } else {
        return 'Just now';
      }
    } catch (e) {
      return 'Just now';
    }
  }
}

class _CommentsSection extends StatelessWidget {
  const _CommentsSection({required this.forumId});

  final String forumId;

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance
          .collection('forums')
          .doc(forumId)
          .collection('comments')
          .orderBy('createdAt', descending: false)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(
            child: Padding(
              padding: EdgeInsets.all(32),
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(
                    DiscussionForumPage._primaryBlue),
              ),
            ),
          );
        }

        if (snapshot.hasError) {
          return Padding(
            padding: const EdgeInsets.all(24),
            child: Text(
              'Error loading comments',
              style: TextStyle(color: Colors.red.shade600),
              textAlign: TextAlign.center,
            ),
          );
        }

        final comments = snapshot.data?.docs ?? [];

        if (comments.isEmpty) {
          return Container(
            padding: const EdgeInsets.all(32),
            child: Column(
              children: [
                Icon(
                  Icons.chat_bubble_outline,
                  size: 64,
                  color: DiscussionForumPage._mutedColor.withValues(alpha: 0.4),
                ),
                const SizedBox(height: 16),
                const Text(
                  'No comments yet',
                  style: TextStyle(
                    color: DiscussionForumPage._mutedColor,
                    fontSize: 15,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 8),
                const Text(
                  'Be the first to share your thoughts!',
                  style: TextStyle(
                    color: DiscussionForumPage._mutedColor,
                    fontSize: 13,
                  ),
                ),
              ],
            ),
          );
        }

        return Column(
          children: comments
              .map((doc) => _CommentTile(
                    comment: doc.data() as Map<String, dynamic>,
                    commentId: doc.id,
                    forumId: forumId,
                  ))
              .toList(),
        );
      },
    );
  }
}

class _CommentTile extends StatelessWidget {
  const _CommentTile({
    required this.comment,
    required this.commentId,
    required this.forumId,
  });

  final Map<String, dynamic> comment;
  final String commentId;
  final String forumId;

  @override
  Widget build(BuildContext context) {
    final userName = comment['userName'] ?? 'Anonymous';
    final text = comment['text'] ?? '';
    final userAvatar = comment['userAvatar'] as String?;
    final userId = comment['userId'] as String?;
    final mediaUrl = comment['mediaUrl'] as String?;
    final mediaType = comment['mediaType'] as String?;
    final mediaName = comment['mediaName'] as String?;
    final currentUser = FirebaseAuth.instance.currentUser;
    final isOwner = currentUser != null && userId == currentUser.uid;

    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: DiscussionForumPage._tabBackground,
        borderRadius: BorderRadius.circular(16),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              CircleAvatar(
                radius: 18,
                backgroundColor:
                    DiscussionForumPage._primaryBlue.withValues(alpha: 0.1),
                backgroundImage: userAvatar != null && userAvatar.isNotEmpty
                    ? NetworkImage(userAvatar)
                    : null,
                child: userAvatar == null || userAvatar.isEmpty
                    ? Text(
                        userName.isNotEmpty ? userName[0].toUpperCase() : '?',
                        style: const TextStyle(
                          color: DiscussionForumPage._primaryBlue,
                          fontWeight: FontWeight.w700,
                          fontSize: 14,
                        ),
                      )
                    : null,
              ),
              const SizedBox(width: 10),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      userName,
                      style: const TextStyle(
                        color: DiscussionForumPage._titleColor,
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 2),
                    Text(
                      _formatTimestamp(comment['createdAt']),
                      style: const TextStyle(
                        color: DiscussionForumPage._mutedColor,
                        fontSize: 12,
                      ),
                    ),
                  ],
                ),
              ),
              if (isOwner)
                IconButton(
                  icon: Icon(Icons.delete_outline,
                      color: Colors.red.shade400, size: 18),
                  padding: EdgeInsets.zero,
                  constraints: const BoxConstraints(),
                  onPressed: () => _deleteComment(context),
                  tooltip: 'Delete comment',
                ),
            ],
          ),
          if (text.isNotEmpty) ...[
            const SizedBox(height: 12),
            Text(
              text,
              style: const TextStyle(
                color: DiscussionForumPage._titleColor,
                fontSize: 14,
                height: 1.5,
              ),
            ),
          ],
          if (mediaUrl != null) ...[
            const SizedBox(height: 12),
            GestureDetector(
              onTap: () => _openMedia(context, mediaUrl, mediaType),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(12),
                child: _isVideoFile(mediaType)
                    ? Container(
                        height: 200,
                        decoration: BoxDecoration(
                          color: Colors.black,
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Stack(
                          alignment: Alignment.center,
                          children: [
                            const Icon(
                              Icons.play_circle_outline,
                              size: 64,
                              color: Colors.white,
                            ),
                            Positioned(
                              bottom: 12,
                              left: 12,
                              child: Container(
                                padding: const EdgeInsets.symmetric(
                                    horizontal: 12, vertical: 6),
                                decoration: BoxDecoration(
                                  color: Colors.black.withValues(alpha: 0.7),
                                  borderRadius: BorderRadius.circular(8),
                                ),
                                child: Row(
                                  mainAxisSize: MainAxisSize.min,
                                  children: [
                                    const Icon(Icons.videocam,
                                        size: 16, color: Colors.white),
                                    const SizedBox(width: 6),
                                    Text(
                                      mediaName ?? 'Video',
                                      style: const TextStyle(
                                        color: Colors.white,
                                        fontSize: 12,
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                            ),
                          ],
                        ),
                      )
                    : Image.network(
                        mediaUrl,
                        fit: BoxFit.cover,
                        loadingBuilder: (context, child, loadingProgress) {
                          if (loadingProgress == null) return child;
                          return Container(
                            height: 200,
                            alignment: Alignment.center,
                            child: CircularProgressIndicator(
                              value: loadingProgress.expectedTotalBytes != null
                                  ? loadingProgress.cumulativeBytesLoaded /
                                      loadingProgress.expectedTotalBytes!
                                  : null,
                              strokeWidth: 2,
                              valueColor: const AlwaysStoppedAnimation<Color>(
                                  DiscussionForumPage._primaryBlue),
                            ),
                          );
                        },
                        errorBuilder: (context, error, stackTrace) => Container(
                          height: 200,
                          decoration: BoxDecoration(
                            color: DiscussionForumPage._primaryBlue
                                .withValues(alpha: 0.1),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Icon(
                                Icons.broken_image,
                                size: 48,
                                color: DiscussionForumPage._mutedColor,
                              ),
                              const SizedBox(height: 8),
                              Text(
                                'Failed to load image',
                                style: TextStyle(
                                  color: DiscussionForumPage._mutedColor,
                                  fontSize: 12,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  bool _isVideoFile(String? extension) {
    if (extension == null) return false;
    final videoExtensions = ['mp4', 'mov', 'avi', 'mkv', 'webm'];
    return videoExtensions.contains(extension.toLowerCase());
  }

  void _openMedia(BuildContext context, String mediaUrl, String? mediaType) {
    // Open media in a full-screen dialog or external viewer
    showDialog(
      context: context,
      builder: (context) => Dialog(
        backgroundColor: Colors.transparent,
        insetPadding: const EdgeInsets.all(24),
        child: Stack(
          children: [
            Center(
              child: _isVideoFile(mediaType)
                  ? Container(
                      padding: const EdgeInsets.all(20),
                      decoration: BoxDecoration(
                        color: Colors.black.withValues(alpha: 0.9),
                        borderRadius: BorderRadius.circular(16),
                      ),
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.video_library,
                              size: 64, color: Colors.white),
                          const SizedBox(height: 16),
                          const Text(
                            'Video playback',
                            style: TextStyle(color: Colors.white, fontSize: 16),
                          ),
                          const SizedBox(height: 8),
                          Text(
                            'Tap to open in browser',
                            style: TextStyle(
                              color: Colors.white.withValues(alpha: 0.7),
                              fontSize: 12,
                            ),
                          ),
                          const SizedBox(height: 16),
                          ElevatedButton(
                            onPressed: () async {
                              Navigator.pop(context);
                              final uri = Uri.parse(mediaUrl);
                              if (await canLaunchUrl(uri)) {
                                await launchUrl(uri,
                                    mode: LaunchMode.externalApplication);
                              }
                            },
                            style: ElevatedButton.styleFrom(
                              backgroundColor: DiscussionForumPage._primaryBlue,
                              foregroundColor: Colors.white,
                            ),
                            child: const Text('Open Video'),
                          ),
                        ],
                      ),
                    )
                  : InteractiveViewer(
                      child: ClipRRect(
                        borderRadius: BorderRadius.circular(16),
                        child: Image.network(mediaUrl, fit: BoxFit.contain),
                      ),
                    ),
            ),
            Positioned(
              top: 16,
              right: 16,
              child: Material(
                color: Colors.black.withValues(alpha: 0.7),
                borderRadius: BorderRadius.circular(20),
                child: InkWell(
                  onTap: () => Navigator.pop(context),
                  borderRadius: BorderRadius.circular(20),
                  child: Container(
                    width: 40,
                    height: 40,
                    alignment: Alignment.center,
                    child:
                        const Icon(Icons.close, color: Colors.white, size: 24),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _deleteComment(BuildContext context) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: const Text('Delete Comment'),
        content: const Text('Are you sure you want to delete this comment?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red.shade600,
              foregroundColor: Colors.white,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
            ),
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Delete'),
          ),
        ],
      ),
    );

    if (confirmed != true) return;

    try {
      await FirebaseFirestore.instance
          .collection('forums')
          .doc(forumId)
          .collection('comments')
          .doc(commentId)
          .delete();

      await FirebaseFirestore.instance
          .collection('forums')
          .doc(forumId)
          .update({'commentsCount': FieldValue.increment(-1)});

      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('Comment deleted'),
            backgroundColor: DiscussionForumPage._primaryBlue,
            behavior: SnackBarBehavior.floating,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to delete comment: $e'),
            backgroundColor: Colors.red.shade600,
          ),
        );
      }
    }
  }

  String _formatTimestamp(dynamic timestamp) {
    if (timestamp == null) return 'Just now';
    try {
      final DateTime dateTime = (timestamp as Timestamp).toDate();
      final now = DateTime.now();
      final difference = now.difference(dateTime);

      if (difference.inDays > 7) {
        return '${dateTime.day}/${dateTime.month}/${dateTime.year}';
      } else if (difference.inDays > 0) {
        return '${difference.inDays}d ago';
      } else if (difference.inHours > 0) {
        return '${difference.inHours}h ago';
      } else if (difference.inMinutes > 0) {
        return '${difference.inMinutes}m ago';
      } else {
        return 'Just now';
      }
    } catch (e) {
      return 'Just now';
    }
  }
}

class _MyForumsSection extends StatelessWidget {
  const _MyForumsSection();

  @override
  Widget build(BuildContext context) {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      return Container(
        width: double.infinity,
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 36),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(24),
          border: Border.all(color: DiscussionForumPage._borderColor),
        ),
        child: const Text(
          'Please log in to view your forums.',
          style:
              TextStyle(color: DiscussionForumPage._mutedColor, fontSize: 14),
        ),
      );
    }

    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance
          .collection('forums')
          .where('createdBy', isEqualTo: currentUser.uid)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return Container(
            height: 150,
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(24),
              border: Border.all(color: DiscussionForumPage._borderColor),
            ),
          );
        }

        if (snapshot.hasError) {
          return Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 36),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(24),
              border: Border.all(color: DiscussionForumPage._borderColor),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Unable to load your forums',
                  style: TextStyle(
                    color: DiscussionForumPage._titleColor,
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  'Error: ${snapshot.error}',
                  style: const TextStyle(
                    color: DiscussionForumPage._mutedColor,
                    fontSize: 13,
                  ),
                ),
              ],
            ),
          );
        }

        final forums = snapshot.data?.docs ?? [];
        if (forums.isEmpty) {
          return Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 36),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(24),
              border: Border.all(color: DiscussionForumPage._borderColor),
            ),
            child: const Text(
              'You have not created any forums yet.',
              style: TextStyle(
                  color: DiscussionForumPage._mutedColor, fontSize: 14),
            ),
          );
        }

        return Column(
          children: forums.map((doc) {
            final forum = doc.data() as Map<String, dynamic>;
            forum['id'] = doc.id;
            return _ForumCard(forum: forum);
          }).toList(),
        );
      },
    );
  }
}

class _AllForumsDialog extends StatelessWidget {
  const _AllForumsDialog();

  @override
  Widget build(BuildContext context) {
    return Dialog(
      insetPadding: const EdgeInsets.symmetric(horizontal: 24, vertical: 24),
      backgroundColor: Colors.white,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(28)),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(28, 28, 28, 20),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'All Forums',
                  style: TextStyle(
                    color: DiscussionForumPage._titleColor,
                    fontSize: 20,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                GestureDetector(
                  onTap: () => Navigator.pop(context),
                  child: const Icon(Icons.close,
                      color: DiscussionForumPage._mutedColor),
                ),
              ],
            ),
          ),
          Expanded(
            child: StreamBuilder<QuerySnapshot>(
              stream:
                  FirebaseFirestore.instance.collection('forums').snapshots(),
              builder: (context, snapshot) {
                print(
                    'üîç All Forums Dialog - docs count: ${snapshot.data?.docs.length ?? 0}');
                snapshot.data?.docs.forEach((doc) {
                  final data = doc.data() as Map<String, dynamic>;
                  print(
                      'üìÑ All Forums - Forum: ${data['title']} by ${data['creatorName']}');
                });

                if (snapshot.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator());
                }

                if (snapshot.hasError) {
                  return Center(child: Text('Error: ${snapshot.error}'));
                }

                final forums = snapshot.data?.docs ?? [];
                if (forums.isEmpty) {
                  return const Center(
                    child: Text(
                      'No forums available.',
                      style: TextStyle(color: DiscussionForumPage._mutedColor),
                    ),
                  );
                }

                return SingleChildScrollView(
                  child: Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 28),
                    child: Column(
                      children: forums.map((doc) {
                        final forum = doc.data() as Map<String, dynamic>;
                        forum['id'] = doc.id;
                        return Padding(
                          padding: const EdgeInsets.only(bottom: 16),
                          child: _ForumCard(forum: forum),
                        );
                      }).toList(),
                    ),
                  ),
                );
              },
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(28),
            child: SizedBox(
              width: double.infinity,
              height: 46,
              child: ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: DiscussionForumPage._primaryBlue,
                  foregroundColor: Colors.white,
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(14)),
                  elevation: 0,
                ),
                onPressed: () => Navigator.pop(context),
                child: const Text('Close',
                    style:
                        TextStyle(fontWeight: FontWeight.w700, fontSize: 15)),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _ForumSectionHeading extends StatelessWidget {
  const _ForumSectionHeading({required this.label});

  final String label;

  @override
  Widget build(BuildContext context) {
    return Text(
      label,
      style: const TextStyle(
        color: DiscussionForumPage._titleColor,
        fontSize: 18,
        fontWeight: FontWeight.w700,
      ),
    );
  }
}

class _FriendSuggestionCard extends StatefulWidget {
  const _FriendSuggestionCard({required this.data});

  final _FriendSuggestionData data;

  @override
  State<_FriendSuggestionCard> createState() => _FriendSuggestionCardState();
}

class _FriendSuggestionCardState extends State<_FriendSuggestionCard> {
  bool _isSending = false;
  bool _requestSent = false;

  Future<void> _sendFriendRequest() async {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null || widget.data.userId == null) return;

    setState(() => _isSending = true);

    try {
      final batch = FirebaseFirestore.instance.batch();
      final timestamp = FieldValue.serverTimestamp();

      final requestRef = FirebaseFirestore.instance
          .collection('users')
          .doc(widget.data.userId)
          .collection('friend_requests')
          .doc(currentUser.uid);

      batch.set(requestRef, {
        'fromUserId': currentUser.uid,
        'fromUserName': currentUser.displayName ?? currentUser.email ?? 'User',
        'fromUserEmail': currentUser.email,
        'status': 'pending',
        'createdAt': timestamp,
      });

      final sentRequestRef = FirebaseFirestore.instance
          .collection('users')
          .doc(currentUser.uid)
          .collection('sent_requests')
          .doc(widget.data.userId);

      batch.set(sentRequestRef, {
        'toUserId': widget.data.userId,
        'toUserName': widget.data.name,
        'toUserEmail': widget.data.email,
        'status': 'pending',
        'createdAt': timestamp,
      });

      await batch.commit();

      if (mounted) {
        setState(() {
          _requestSent = true;
          _isSending = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Friend request sent to ${widget.data.name}'),
            backgroundColor: DiscussionForumPage._primaryBlue,
            behavior: SnackBarBehavior.floating,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isSending = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to send request: $e'),
            backgroundColor: Colors.red,
            behavior: SnackBarBehavior.floating,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final Widget avatar =
        widget.data.avatarUrl != null && widget.data.avatarUrl!.isNotEmpty
            ? CircleAvatar(
                radius: 30,
                backgroundImage: NetworkImage(widget.data.avatarUrl!),
              )
            : CircleAvatar(
                radius: 30,
                backgroundColor: const Color(0xFFEFF1F6),
                child: const Icon(
                  Icons.person_outline,
                  color: DiscussionForumPage._primaryBlue,
                  size: 30,
                ),
              );

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 20),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: DiscussionForumPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          avatar,
          const SizedBox(width: 20),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  widget.data.name,
                  style: const TextStyle(
                    color: DiscussionForumPage._titleColor,
                    fontSize: 16,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                const SizedBox(height: 6),
                Wrap(
                  spacing: 12,
                  runSpacing: 6,
                  children: [
                    Text(
                      widget.data.email,
                      style: const TextStyle(
                        color: DiscussionForumPage._mutedColor,
                        fontSize: 13,
                      ),
                    ),
                    ...widget.data.details.map(
                      (detail) => Text(
                        detail,
                        style: const TextStyle(
                          color: DiscussionForumPage._mutedColor,
                          fontSize: 13,
                        ),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
          const SizedBox(width: 20),
          SizedBox(
            height: 44,
            child: _isSending
                ? const SizedBox(
                    width: 140,
                    child: Center(
                      child: SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2.5,
                          color: DiscussionForumPage._primaryBlue,
                        ),
                      ),
                    ),
                  )
                : ElevatedButton(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: _requestSent
                          ? Colors.grey.shade400
                          : DiscussionForumPage._primaryBlue,
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(horizontal: 22),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(16)),
                      elevation: 0,
                    ),
                    onPressed: _requestSent ? null : _sendFriendRequest,
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(
                            _requestSent
                                ? Icons.check_circle
                                : Icons.person_add,
                            size: 18),
                        const SizedBox(width: 8),
                        Text(
                          _requestSent ? 'Request Sent' : 'Send Request',
                          style: const TextStyle(
                              fontWeight: FontWeight.w700, fontSize: 14),
                        ),
                      ],
                    ),
                  ),
          ),
        ],
      ),
    );
  }
}

class _FriendSuggestionData {
  const _FriendSuggestionData({
    required this.name,
    required this.email,
    required this.details,
    this.avatarUrl,
    this.userId,
  });

  final String name;
  final String email;
  final List<String> details;
  final String? avatarUrl;
  final String? userId;
}

class _AllUsersList extends StatelessWidget {
  const _AllUsersList();

  @override
  Widget build(BuildContext context) {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      return const SizedBox.shrink();
    }

    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance.collection('users').snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(
            child: Padding(
              padding: EdgeInsets.all(40),
              child: CircularProgressIndicator(
                  color: DiscussionForumPage._primaryBlue),
            ),
          );
        }

        if (snapshot.hasError) {
          return Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(24),
              border: Border.all(color: DiscussionForumPage._borderColor),
            ),
            child: Text(
              'Error loading users: ${snapshot.error}',
              style: const TextStyle(
                  color: DiscussionForumPage._mutedColor, fontSize: 14),
            ),
          );
        }

        if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
          return Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(24),
              border: Border.all(color: DiscussionForumPage._borderColor),
            ),
            child: const Text(
              'No users found.',
              style: TextStyle(
                  color: DiscussionForumPage._mutedColor, fontSize: 14),
            ),
          );
        }

        final allUsers = snapshot.data!.docs
            .where((doc) => doc.id != currentUser.uid)
            .map((doc) {
          final data = doc.data() as Map<String, dynamic>;
          final firstName = data['firstName'] as String? ?? '';
          final lastName = data['lastName'] as String? ?? '';
          final displayName = data['displayName'] as String? ?? '';
          final email = data['email'] as String? ?? '';
          final agencyName = data['agencyName'] as String? ?? '';
          final title = data['title'] as String? ?? '';
          final location = data['location'] as String? ?? '';
          final role = data['role'] as String? ?? '';

          final name = firstName.isNotEmpty || lastName.isNotEmpty
              ? '$firstName $lastName'.trim()
              : displayName.isNotEmpty
                  ? displayName
                  : email.split('@').first;

          final details = <String>[];
          if (role.isNotEmpty) details.add(role);
          if (agencyName.isNotEmpty) details.add(agencyName);
          if (title.isNotEmpty && !details.contains(title)) details.add(title);
          if (location.isNotEmpty) details.add(location);

          return _FriendSuggestionData(
            name: name,
            email: email,
            details: details,
            avatarUrl: data['photoUrl'] as String?,
            userId: doc.id,
          );
        }).toList();

        if (allUsers.isEmpty) {
          return Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(24),
              border: Border.all(color: DiscussionForumPage._borderColor),
            ),
            child: const Text(
              'No other users to display.',
              style: TextStyle(
                  color: DiscussionForumPage._mutedColor, fontSize: 14),
            ),
          );
        }

        return Column(
          children: List.generate(allUsers.length, (index) {
            final data = allUsers[index];
            final bool isLast = index == allUsers.length - 1;
            return Padding(
              padding: EdgeInsets.only(bottom: isLast ? 0 : 18),
              child: _FriendSuggestionCard(data: data),
            );
          }),
        );
      },
    );
  }
}

/// Bottom sheet for viewing and managing incoming friend requests.
///
/// This widget is intentionally self-contained and resilient to unknown
/// Firestore schemas. It reads pending requests from
/// `users/{currentUserId}/friend_requests` and provides Accept/Decline
/// actions. If that path doesn't exist, it gracefully shows an empty state.
class _FriendRequestsSheet extends StatefulWidget {
  const _FriendRequestsSheet({required this.currentUserId});

  final String currentUserId;

  @override
  State<_FriendRequestsSheet> createState() => _FriendRequestsSheetState();
}

class _FriendRequestsSheetState extends State<_FriendRequestsSheet> {
  String? _processingUserId;

  bool get _isBusy => _processingUserId != null;

  Future<void> _accept(_FriendRequestRecord request) async {
    if (_isBusy) return;
    setState(() => _processingUserId = request.requesterId);
    try {
      final meRef = FirebaseFirestore.instance
          .collection('users')
          .doc(widget.currentUserId);
      final otherRef = FirebaseFirestore.instance
          .collection('users')
          .doc(request.requesterId);

      final batch = FirebaseFirestore.instance.batch();
      batch.set(
          meRef,
          {
            'friends': FieldValue.arrayUnion([request.requesterId])
          },
          SetOptions(merge: true));
      batch.set(
          otherRef,
          {
            'friends': FieldValue.arrayUnion([widget.currentUserId])
          },
          SetOptions(merge: true));
      batch
          .delete(meRef.collection('friend_requests').doc(request.requesterId));
      batch.delete(
          otherRef.collection('sent_requests').doc(widget.currentUserId));
      await batch.commit();

      if (!mounted) return;
      final String name =
          request.displayName.isEmpty ? 'Friend' : request.displayName;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('$name is now in your circle.'),
          backgroundColor: DiscussionForumPage._primaryBlue,
          behavior: SnackBarBehavior.floating,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Could not accept request: $e'),
          backgroundColor: Colors.red,
          behavior: SnackBarBehavior.floating,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    } finally {
      if (mounted) setState(() => _processingUserId = null);
    }
  }

  Future<void> _decline(_FriendRequestRecord request) async {
    if (_isBusy) return;
    setState(() => _processingUserId = request.requesterId);
    try {
      final meRef = FirebaseFirestore.instance
          .collection('users')
          .doc(widget.currentUserId);
      final otherRef = FirebaseFirestore.instance
          .collection('users')
          .doc(request.requesterId);

      final batch = FirebaseFirestore.instance.batch();
      batch
          .delete(meRef.collection('friend_requests').doc(request.requesterId));
      batch.delete(
          otherRef.collection('sent_requests').doc(widget.currentUserId));
      await batch.commit();

      if (!mounted) return;
      final String name =
          request.displayName.isEmpty ? 'Friend' : request.displayName;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Declined $name\'s request.'),
          backgroundColor: Colors.black87,
          behavior: SnackBarBehavior.floating,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Could not decline request: $e'),
          backgroundColor: Colors.red,
          behavior: SnackBarBehavior.floating,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        ),
      );
    } finally {
      if (mounted) setState(() => _processingUserId = null);
    }
  }

  Future<List<_FriendRequestRecord>> _loadFallbackFriendRequests() async {
    try {
      final doc = await FirebaseFirestore.instance
          .collection('users')
          .doc(widget.currentUserId)
          .get();
      final data = doc.data() ?? <String, dynamic>{};
      final raw = data['friend_requests'] ??
          data['friendRequests'] ??
          data['pendingRequests'];

      if (raw is! List) return const [];

      final List<_FriendRequestRecord> results = [];
      final List<String> idsToResolve = [];

      for (final entry in raw) {
        if (entry is String && entry.isNotEmpty) {
          idsToResolve.add(entry);
          continue;
        }

        if (entry is Map) {
          final map = Map<String, dynamic>.from(entry);
          final String? userId =
              (map['fromUserId'] ?? map['userId'] ?? map['id']) as String?;
          if (userId == null || userId.isEmpty) continue;
          final String name = (map['fromUserName'] ??
                  map['name'] ??
                  map['displayName'] ??
                  map['username'] ??
                  '') as String? ??
              '';
          final String email =
              (map['fromUserEmail'] ?? map['email'] ?? '') as String? ?? '';
          results.add(
            _FriendRequestRecord(
              requesterId: userId,
              displayName: name,
              email: email,
            ),
          );
        }
      }

      if (idsToResolve.isNotEmpty) {
        final profiles = await _fetchProfilesByIds(idsToResolve);
        for (final profile in profiles) {
          results.add(
            _FriendRequestRecord(
              requesterId: profile.id,
              displayName: profile.name,
              email: profile.email,
            ),
          );
        }
      }

      results.sort((a, b) =>
          a.displayName.toLowerCase().compareTo(b.displayName.toLowerCase()));
      return results;
    } catch (_) {
      return const [];
    }
  }

  Widget _buildRequestsList(
      {required List<_FriendRequestRecord> requests,
      required ScrollController controller}) {
    return ListView.separated(
      controller: controller,
      padding: const EdgeInsets.fromLTRB(16, 16, 16, 24),
      itemCount: requests.length,
      separatorBuilder: (_, __) => const SizedBox(height: 12),
      itemBuilder: (context, index) {
        final request = requests[index];
        final bool isProcessing = _processingUserId == request.requesterId;
        final bool isDisabled = _isBusy;
        return _FriendRequestTile(
          data: request,
          isProcessing: isProcessing,
          isDisabled: isDisabled,
          onAccept: () => _accept(request),
          onDecline: () => _decline(request),
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Container(
        decoration: const BoxDecoration(
          color: Colors.transparent,
        ),
        child: Container(
          clipBehavior: Clip.antiAlias,
          decoration: const BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.only(
              topLeft: Radius.circular(24),
              topRight: Radius.circular(24),
            ),
          ),
          child: DraggableScrollableSheet(
            expand: false,
            initialChildSize: 0.6,
            minChildSize: 0.4,
            maxChildSize: 0.9,
            builder: (context, controller) {
              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Padding(
                    padding: const EdgeInsets.fromLTRB(20, 16, 12, 8),
                    child: Row(
                      children: [
                        const Icon(Icons.group_add_outlined,
                            color: DiscussionForumPage._primaryBlue),
                        const SizedBox(width: 10),
                        const Expanded(
                          child: Text(
                            'Friend Requests',
                            style: TextStyle(
                              color: DiscussionForumPage._titleColor,
                              fontSize: 18,
                              fontWeight: FontWeight.w800,
                            ),
                          ),
                        ),
                        IconButton(
                          tooltip: 'Close',
                          onPressed: () => Navigator.of(context).pop(),
                          icon: const Icon(Icons.close,
                              color: DiscussionForumPage._mutedColor),
                        ),
                      ],
                    ),
                  ),
                  const Divider(
                      height: 1, color: DiscussionForumPage._borderColor),
                  Expanded(
                    child: StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
                      stream: (() {
                        try {
                          return FirebaseFirestore.instance
                              .collection('users')
                              .doc(widget.currentUserId)
                              .collection('friend_requests')
                              .where('status', isEqualTo: 'pending')
                              .snapshots();
                        } catch (_) {
                          return const Stream<
                              QuerySnapshot<Map<String, dynamic>>>.empty();
                        }
                      })(),
                      builder: (context, snapshot) {
                        if (snapshot.connectionState ==
                            ConnectionState.waiting) {
                          return const Center(
                              child: CircularProgressIndicator());
                        }
                        if (snapshot.hasError) {
                          return Center(
                            child: Padding(
                              padding: const EdgeInsets.all(24),
                              child: Text(
                                'Error loading requests: ${snapshot.error}',
                                style: const TextStyle(
                                    color: DiscussionForumPage._mutedColor),
                                textAlign: TextAlign.center,
                              ),
                            ),
                          );
                        }

                        final docs = snapshot.data?.docs ?? const [];
                        final List<_FriendRequestRecord> requests = docs
                            .map((doc) {
                              final data = doc.data();
                              final fromUserId =
                                  data['fromUserId'] as String? ?? doc.id;
                              if (fromUserId.isEmpty) return null;
                              final name =
                                  data['fromUserName'] as String? ?? '';
                              final email =
                                  data['fromUserEmail'] as String? ?? '';
                              return _FriendRequestRecord(
                                requesterId: fromUserId,
                                displayName: name,
                                email: email,
                              );
                            })
                            .whereType<_FriendRequestRecord>()
                            .toList(growable: false);

                        if (requests.isNotEmpty) {
                          return _buildRequestsList(
                              requests: requests, controller: controller);
                        }

                        return FutureBuilder<List<_FriendRequestRecord>>(
                          future: _loadFallbackFriendRequests(),
                          builder: (context, fallbackSnapshot) {
                            if (fallbackSnapshot.connectionState ==
                                ConnectionState.waiting) {
                              return const Center(
                                  child: CircularProgressIndicator());
                            }

                            if (fallbackSnapshot.hasError) {
                              return Center(
                                child: Padding(
                                  padding: const EdgeInsets.all(24),
                                  child: Text(
                                    'Error loading requests: ${fallbackSnapshot.error}',
                                    style: const TextStyle(
                                        color: DiscussionForumPage._mutedColor),
                                    textAlign: TextAlign.center,
                                  ),
                                ),
                              );
                            }

                            final fallbackRequests =
                                fallbackSnapshot.data ?? const [];
                            if (fallbackRequests.isEmpty) {
                              return const Center(
                                child: Padding(
                                  padding: EdgeInsets.all(24),
                                  child: Text(
                                    'No pending requests right now.',
                                    style: TextStyle(
                                        color: DiscussionForumPage._mutedColor),
                                  ),
                                ),
                              );
                            }

                            return _buildRequestsList(
                                requests: fallbackRequests,
                                controller: controller);
                          },
                        );
                      },
                    ),
                  ),
                ],
              );
            },
          ),
        ),
      ),
    );
  }
}

class _FriendRequestTile extends StatelessWidget {
  const _FriendRequestTile({
    required this.data,
    required this.isProcessing,
    required this.isDisabled,
    required this.onAccept,
    required this.onDecline,
  });

  final _FriendRequestRecord data;
  final bool isProcessing;
  final bool isDisabled;
  final VoidCallback onAccept;
  final VoidCallback onDecline;

  @override
  Widget build(BuildContext context) {
    final String trimmedName = data.displayName.trim();
    final String displayName =
        trimmedName.isEmpty ? 'Pending member' : trimmedName;
    final String initial =
        trimmedName.isEmpty ? '?' : trimmedName.substring(0, 1).toUpperCase();

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: DiscussionForumPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Row(
        children: [
          Container(
            width: 44,
            height: 44,
            decoration: BoxDecoration(
              color: const Color(0xFFF3F4F6),
              borderRadius: BorderRadius.circular(14),
            ),
            alignment: Alignment.center,
            child: Text(
              initial,
              style: const TextStyle(
                color: DiscussionForumPage._titleColor,
                fontWeight: FontWeight.w800,
              ),
            ),
          ),
          const SizedBox(width: 14),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  displayName,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: const TextStyle(
                    color: DiscussionForumPage._titleColor,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                if (data.email.isNotEmpty) ...[
                  const SizedBox(height: 4),
                  Text(
                    data.email,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: const TextStyle(
                      color: DiscussionForumPage._mutedColor,
                      fontSize: 12,
                    ),
                  ),
                ],
              ],
            ),
          ),
          const SizedBox(width: 12),
          Row(
            children: [
              OutlinedButton.icon(
                onPressed: isDisabled ? null : onDecline,
                style: OutlinedButton.styleFrom(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12)),
                  side:
                      const BorderSide(color: DiscussionForumPage._borderColor),
                ),
                icon: const Icon(Icons.close,
                    size: 18, color: DiscussionForumPage._mutedColor),
                label: const Text('Decline',
                    style: TextStyle(color: DiscussionForumPage._mutedColor)),
              ),
              const SizedBox(width: 8),
              ElevatedButton.icon(
                onPressed: isDisabled ? null : onAccept,
                style: ElevatedButton.styleFrom(
                  backgroundColor: DiscussionForumPage._primaryBlue,
                  foregroundColor: Colors.white,
                  padding:
                      const EdgeInsets.symmetric(horizontal: 14, vertical: 12),
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12)),
                  elevation: 0,
                ),
                icon: isProcessing
                    ? const SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(
                            strokeWidth: 2, color: Colors.white),
                      )
                    : const Icon(Icons.check_circle_outline, size: 18),
                label: Text(isProcessing ? 'Working...' : 'Accept',
                    style: const TextStyle(fontWeight: FontWeight.w700)),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class _MyFriendsSection extends StatelessWidget {
  const _MyFriendsSection();

  @override
  Widget build(BuildContext context) {
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      return _MyFriendsEmptyState(
        headline: 'My Friends',
        message: 'Sign in to build your Breakaway365 circle.',
      );
    }

    return StreamBuilder<DocumentSnapshot<Map<String, dynamic>>>(
      stream: FirebaseFirestore.instance
          .collection('users')
          .doc(currentUser.uid)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: const [
              _MyFriendsHeader(friendCount: null),
              SizedBox(height: 18),
              _FriendsLoadingPlaceholder(),
            ],
          );
        }

        if (snapshot.hasError) {
          return Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const _MyFriendsHeader(friendCount: 0),
              const SizedBox(height: 18),
              _MyFriendsEmptyState(
                headline: null,
                message: 'We hit a snag loading friends: ${snapshot.error}.',
              ),
            ],
          );
        }

        if (!snapshot.hasData || !snapshot.data!.exists) {
          return Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: const [
              _MyFriendsHeader(friendCount: 0),
              SizedBox(height: 18),
              _MyFriendsEmptyState(
                headline: null,
                message: 'We could not locate your profile. Try refreshing.',
              ),
            ],
          );
        }

        final data = snapshot.data!.data() ?? <String, dynamic>{};
        final List<String> friendIds = (data['friends'] as List?)
                ?.whereType<String>()
                .toList(growable: false) ??
            const [];
        final friendCount = friendIds.length;

        if (friendIds.isEmpty) {
          return Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: const [
              _MyFriendsHeader(friendCount: 0),
              SizedBox(height: 18),
              _MyFriendsEmptyState(
                headline: null,
                message:
                    'Your friends will appear here once requests are accepted.',
              ),
            ],
          );
        }

        return FutureBuilder<List<_FriendProfile>>(
          future: _fetchProfilesByIds(friendIds),
          builder: (context, profileSnapshot) {
            if (profileSnapshot.connectionState == ConnectionState.waiting) {
              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: const [
                  _MyFriendsHeader(friendCount: null),
                  SizedBox(height: 18),
                  _FriendsLoadingPlaceholder(),
                ],
              );
            }

            if (profileSnapshot.hasError) {
              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _MyFriendsHeader(friendCount: friendCount),
                  const SizedBox(height: 18),
                  _MyFriendsEmptyState(
                    headline: null,
                    message:
                        'Unable to load friend details right now. Please try again soon.',
                  ),
                ],
              );
            }

            final profiles = profileSnapshot.data ?? const [];
            if (profiles.isEmpty) {
              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: const [
                  _MyFriendsHeader(friendCount: 0),
                  SizedBox(height: 18),
                  _MyFriendsEmptyState(
                    headline: null,
                    message:
                        'Your friends will appear here once requests are accepted.',
                  ),
                ],
              );
            }

            final displayProfiles = profiles.take(8).toList(growable: false);
            final int remaining = profiles.length - displayProfiles.length;

            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _MyFriendsHeader(friendCount: profiles.length),
                const SizedBox(height: 18),
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(20),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(22),
                    border: Border.all(color: DiscussionForumPage._borderColor),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.04),
                        blurRadius: 18,
                        offset: const Offset(0, 10),
                      ),
                    ],
                  ),
                  child: LayoutBuilder(
                    builder: (context, constraints) {
                      final double maxWidth = constraints.maxWidth;
                      double cardWidth;
                      if (maxWidth >= 1024) {
                        cardWidth = 320;
                      } else if (maxWidth >= 820) {
                        cardWidth = 300;
                      } else if (maxWidth >= 640) {
                        cardWidth = 280;
                      } else if (maxWidth >= 480) {
                        cardWidth = 260;
                      } else {
                        cardWidth = maxWidth;
                      }

                      final double effectiveWidth =
                          math.min(cardWidth, constraints.maxWidth);

                      return Wrap(
                        spacing: 16,
                        runSpacing: 16,
                        children: [
                          for (final friend in displayProfiles)
                            SizedBox(
                              width: effectiveWidth,
                              child: _FriendSummaryCard(friend: friend),
                            ),
                          if (remaining > 0)
                            SizedBox(
                              width: effectiveWidth,
                              child:
                                  _MoreFriendsCard(remainingCount: remaining),
                            ),
                        ],
                      );
                    },
                  ),
                ),
              ],
            );
          },
        );
      },
    );
  }
}

class _MyFriendsHeader extends StatelessWidget {
  const _MyFriendsHeader({required this.friendCount});

  final int? friendCount;

  @override
  Widget build(BuildContext context) {
    final String label = friendCount == null
        ? 'Friends'
        : '${friendCount!} Friend${friendCount == 1 ? '' : 's'}';

    return Row(
      children: [
        const Text(
          'My Friends',
          style: TextStyle(
            color: DiscussionForumPage._titleColor,
            fontSize: 18,
            fontWeight: FontWeight.w700,
          ),
        ),
        const Spacer(),
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
          decoration: BoxDecoration(
            color: DiscussionForumPage._primaryBlue.withOpacity(0.08),
            borderRadius: BorderRadius.circular(999),
            border: Border.all(
                color: DiscussionForumPage._primaryBlue.withOpacity(0.18)),
          ),
          child: Text(
            label,
            style: const TextStyle(
              color: DiscussionForumPage._primaryBlue,
              fontSize: 13,
              fontWeight: FontWeight.w700,
            ),
          ),
        ),
      ],
    );
  }
}

class _MyFriendsEmptyState extends StatelessWidget {
  const _MyFriendsEmptyState({this.headline, required this.message});

  final String? headline;
  final String message;

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 28),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(22),
        border: Border.all(color: DiscussionForumPage._borderColor),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (headline != null) ...[
            Text(
              headline!,
              style: const TextStyle(
                color: DiscussionForumPage._titleColor,
                fontSize: 16,
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 10),
          ],
          Text(
            message,
            style: const TextStyle(
              color: DiscussionForumPage._mutedColor,
              fontSize: 13,
              height: 1.45,
            ),
          ),
        ],
      ),
    );
  }
}

class _FriendsLoadingPlaceholder extends StatelessWidget {
  const _FriendsLoadingPlaceholder();

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(22),
        border: Border.all(color: DiscussionForumPage._borderColor),
      ),
      child: const Center(
        child: SizedBox(
          width: 24,
          height: 24,
          child: CircularProgressIndicator(strokeWidth: 2.5),
        ),
      ),
    );
  }
}

class _FriendSummaryCard extends StatelessWidget {
  const _FriendSummaryCard({required this.friend});

  final _FriendProfile friend;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 18),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: DiscussionForumPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 16,
            offset: const Offset(0, 10),
          ),
        ],
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          _FriendAvatar(name: friend.name, photoUrl: friend.photoUrl),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  friend.name,
                  style: const TextStyle(
                    color: DiscussionForumPage._titleColor,
                    fontSize: 15,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                if (friend.email.isNotEmpty) ...[
                  const SizedBox(height: 4),
                  Text(
                    friend.email,
                    style: const TextStyle(
                      color: DiscussionForumPage._mutedColor,
                      fontSize: 12,
                    ),
                  ),
                ],
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _MoreFriendsCard extends StatelessWidget {
  const _MoreFriendsCard({required this.remainingCount});

  final int remainingCount;

  @override
  Widget build(BuildContext context) {
    final String label = '+$remainingCount more';
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 18),
      decoration: BoxDecoration(
        color: DiscussionForumPage._primaryBlue.withOpacity(0.08),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(
            color: DiscussionForumPage._primaryBlue.withOpacity(0.24)),
      ),
      alignment: Alignment.center,
      child: Text(
        label,
        style: const TextStyle(
          color: DiscussionForumPage._primaryBlue,
          fontSize: 14,
          fontWeight: FontWeight.w700,
        ),
      ),
    );
  }
}

class MessagesPage extends StatefulWidget {
  const MessagesPage({super.key});

  static const Color _titleColor = Color(0xFF111827);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE5E7EB);
  static const Color _chipInactive = Color(0xFFF3F4F6);
  static const Color _focusColor = Color(0xFF2563EB);

  @override
  State<MessagesPage> createState() => _MessagesPageState();
}

class _MessagesPageState extends State<MessagesPage> {
  String _activeTab = 'My Chats';
  final _myChatsKey = GlobalKey();
  final _unreadKey = GlobalKey();
  final _groupsKey = GlobalKey();
  String? _selectedChatId;

  void _scrollToSection(String tab) {
    setState(() => _activeTab = tab);
    GlobalKey? key;
    switch (tab) {
      case 'My Chats':
        key = _myChatsKey;
        break;
      case 'Unread':
        key = _unreadKey;
        break;
      case 'Groups':
        key = _groupsKey;
        break;
    }
    if (key?.currentContext != null) {
      Scrollable.ensureVisible(
        key!.currentContext!,
        duration: const Duration(milliseconds: 400),
        curve: Curves.easeInOut,
        alignment: 0.1,
      );
    }
  }

  Future<void> _openNewConversation() async {
    final chatId = await showModalBottomSheet<String>(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return NewConversationSheet(
          onChatOpened: (id) => Navigator.of(context).pop(id),
          onCreateGroup: () async {
            Navigator.of(context).pop();
            return _showCreateGroupDialog(context);
          },
        );
      },
    );

    if (chatId != null && mounted) {
      setState(() {
        _selectedChatId = chatId;
      });
    }
  }

  void _handleChatSelected(Map<String, dynamic> chat) {
    final id = chat['id'];
    if (id is String) {
      setState(() => _selectedChatId = id);
    }
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final double horizontalPadding = constraints.maxWidth > 1400
            ? 72.0
            : constraints.maxWidth > 1180
                ? 56.0
                : constraints.maxWidth > 900
                    ? 40.0
                    : 24.0;
        final bool stackPanels = constraints.maxWidth < 1120;
        final bool isCompact = constraints.maxWidth < 860;

        final Widget hero = _MessagesHeroBanner(isCompact: isCompact);
        final Widget searchAndActions = _MessageSearchAndActions(
          isCompact: isCompact,
          onNewConversation: _openNewConversation,
        );
        final Widget tabs = Wrap(
          spacing: 12,
          runSpacing: 12,
          children: [
            _MessageTabChip(
              label: 'My Chats',
              isActive: _activeTab == 'My Chats',
              icon: Icons.messenger_outline,
              onTap: () => _scrollToSection('My Chats'),
            ),
            _MessageTabChip(
              label: 'Unread',
              isActive: _activeTab == 'Unread',
              icon: Icons.mark_chat_unread_outlined,
              onTap: () => _scrollToSection('Unread'),
            ),
            _MessageTabChip(
              label: 'Groups',
              isActive: _activeTab == 'Groups',
              icon: Icons.groups_outlined,
              onTap: () => _scrollToSection('Groups'),
            ),
          ],
        );

        final Widget conversationPanel =
            ConversationPanel(chatId: _selectedChatId);

        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              hero,
              const SizedBox(height: 28),
              searchAndActions,
              const SizedBox(height: 24),
              conversationPanel,
              const SizedBox(height: 32),
              const _ConversationHeader(),
              const SizedBox(height: 24),
              tabs,
              const SizedBox(height: 24),
              _MessageSectionCard(
                key: _myChatsKey,
                icon: Icons.forum_outlined,
                title: 'My Chats',
                subtitle:
                    'Pick up where you left off and respond with momentum.',
                child: _MyChatsStrip(onChatSelected: _handleChatSelected),
              ),
              const SizedBox(height: 20),
              _MessageSectionCard(
                key: _unreadKey,
                icon: Icons.notifications_active_outlined,
                title: 'Unread',
                subtitle: 'All the conversations waiting for your response.',
                child: _UnreadChatsStrip(onChatSelected: _handleChatSelected),
              ),
              const SizedBox(height: 20),
              _MessageSectionCard(
                key: _groupsKey,
                icon: Icons.groups_outlined,
                title: 'Groups',
                subtitle: 'Stay in sync with community and cohort chatter.',
                child: _GroupChatsStrip(onChatSelected: _handleChatSelected),
              ),
            ],
          ),
        );
      },
    );
  }
}

class _MessageTabChip extends StatelessWidget {
  const _MessageTabChip({
    required this.label,
    this.isActive = false,
    this.icon,
    this.onTap,
  });

  final String label;
  final bool isActive;
  final IconData? icon;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final Color background =
        isActive ? Colors.white : MessagesPage._chipInactive;
    final Border border = isActive
        ? Border.all(
            color: MessagesPage._focusColor.withOpacity(0.4), width: 1.2)
        : Border.all(color: MessagesPage._borderColor);
    final List<BoxShadow>? shadow = isActive
        ? [
            BoxShadow(
              color: MessagesPage._focusColor.withOpacity(0.18),
              blurRadius: 16,
              offset: const Offset(0, 10),
            ),
          ]
        : null;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(999),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        decoration: BoxDecoration(
          color: background,
          borderRadius: BorderRadius.circular(999),
          border: border,
          boxShadow: shadow,
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (icon != null) ...[
              Icon(icon,
                  color: isActive
                      ? MessagesPage._focusColor
                      : MessagesPage._mutedColor,
                  size: 18),
              const SizedBox(width: 8),
            ],
            Text(
              label,
              style: TextStyle(
                color: isActive
                    ? MessagesPage._focusColor
                    : MessagesPage._titleColor,
                fontWeight: isActive ? FontWeight.w800 : FontWeight.w600,
                fontSize: 14,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

Future<String?> _showCreateGroupDialog(BuildContext context) {
  return showDialog<String>(
    context: context,
    builder: (context) => const _CreateGroupDialog(),
  );
}

class _CreateGroupDialog extends StatefulWidget {
  const _CreateGroupDialog();

  @override
  State<_CreateGroupDialog> createState() => _CreateGroupDialogState();
}

class _CreateGroupDialogState extends State<_CreateGroupDialog> {
  final _groupNameController = TextEditingController();
  final Set<String> _selectedUserIds = {};
  bool _isCreating = false;
  Uint8List? _avatarBytes;
  String? _avatarFileName;

  @override
  void dispose() {
    _groupNameController.dispose();
    super.dispose();
  }

  Future<void> _pickAvatar() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        withData: true,
      );
      if (result == null || result.files.isEmpty) {
        return;
      }
      final file = result.files.first;
      final bytes = file.bytes;
      if (bytes == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
              content:
                  Text('Failed to read image data. Please try another file.')),
        );
        return;
      }
      setState(() {
        _avatarBytes = bytes;
        _avatarFileName = file.name;
      });
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Could not select image: $e')),
      );
    }
  }

  Future<void> _createGroup() async {
    if (_groupNameController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter a group name')),
      );
      return;
    }
    if (_selectedUserIds.length < 2) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content: Text('Please select at least 2 members for the group')),
      );
      return;
    }

    setState(() => _isCreating = true);

    try {
      final currentUserId = FirebaseAuth.instance.currentUser?.uid;
      if (currentUserId == null) {
        throw Exception('You must be logged in to create a group');
      }

      final members = {currentUserId, ..._selectedUserIds}.toList();
      final docRef = FirebaseFirestore.instance.collection('chats').doc();
      final String groupName = _groupNameController.text.trim();
      final now = FieldValue.serverTimestamp();
      final Map<String, String> memberPrivileges = {
        for (final id in members) id: 'member',
      };
      memberPrivileges[currentUserId] = 'owner';

      String? photoUrl;
      if (_avatarBytes != null) {
        final ref = FirebaseStorage.instance.ref(
            'group_profiles/${docRef.id}_${DateTime.now().millisecondsSinceEpoch}');
        final metadata = SettableMetadata(contentType: 'image/png');
        await ref.putData(_avatarBytes!, metadata);
        photoUrl = await ref.getDownloadURL();
      }

      await docRef.set({
        'title': groupName,
        'groupName': groupName,
        'isGroup': true,
        'type': 'group',
        'members': members,
        'createdBy': currentUserId,
        'createdAt': now,
        'updatedAt': now,
        'unreadCount': 0,
        'memberPrivileges': memberPrivileges,
        'groupPhotoUrl': photoUrl,
      });

      if (!mounted) return;
      Navigator.of(context).pop(docRef.id);
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error creating group: $e')),
      );
    } finally {
      if (mounted) {
        setState(() => _isCreating = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
      child: Container(
        constraints: const BoxConstraints(maxWidth: 600, maxHeight: 700),
        padding: const EdgeInsets.all(32),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            Row(
              children: [
                Container(
                  width: 48,
                  height: 48,
                  decoration: BoxDecoration(
                    color: MessagesPage._focusColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(16),
                  ),
                  child: const Icon(Icons.group_add,
                      color: MessagesPage._focusColor, size: 24),
                ),
                const SizedBox(width: 16),
                const Expanded(
                  child: Text(
                    'Create Group Chat',
                    style: TextStyle(
                      color: MessagesPage._titleColor,
                      fontSize: 22,
                      fontWeight: FontWeight.w800,
                    ),
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ],
            ),
            const SizedBox(height: 24),
            Row(
              children: [
                GestureDetector(
                  onTap: _isCreating ? null : _pickAvatar,
                  child: Container(
                    width: 86,
                    height: 86,
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(24),
                      gradient: const LinearGradient(
                        colors: [Color(0xFF1E3A8A), Color(0xFF2563EB)],
                        begin: Alignment.topLeft,
                        end: Alignment.bottomRight,
                      ),
                    ),
                    child: Stack(
                      children: [
                        Positioned.fill(
                          child: ClipRRect(
                            borderRadius: BorderRadius.circular(24),
                            child: _avatarBytes == null
                                ? const Center(
                                    child: Icon(Icons.photo_camera_outlined,
                                        color: Colors.white70, size: 32),
                                  )
                                : Image.memory(
                                    _avatarBytes!,
                                    fit: BoxFit.cover,
                                  ),
                          ),
                        ),
                        if (_avatarBytes != null)
                          Positioned(
                            right: 8,
                            bottom: 8,
                            child: Container(
                              padding: const EdgeInsets.all(6),
                              decoration: BoxDecoration(
                                color: Colors.black.withOpacity(0.55),
                                borderRadius: BorderRadius.circular(12),
                              ),
                              child: const Icon(Icons.edit,
                                  size: 16, color: Colors.white),
                            ),
                          ),
                      ],
                    ),
                  ),
                ),
                const SizedBox(width: 18),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Group Avatar',
                        style: TextStyle(
                          color: MessagesPage._titleColor,
                          fontWeight: FontWeight.w700,
                          fontSize: 14,
                        ),
                      ),
                      const SizedBox(height: 6),
                      Text(
                        _avatarFileName ??
                            'Tap the image to upload a cover profile.',
                        style: const TextStyle(
                            color: MessagesPage._mutedColor, fontSize: 12),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 24),
            TextField(
              controller: _groupNameController,
              decoration: InputDecoration(
                labelText: 'Group Name',
                hintText: 'Enter group name',
                prefixIcon: const Icon(Icons.edit_outlined),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(16),
                ),
                focusedBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(16),
                  borderSide: const BorderSide(
                      color: MessagesPage._focusColor, width: 2),
                ),
              ),
            ),
            const SizedBox(height: 24),
            const Text(
              'Select Members',
              style: TextStyle(
                color: MessagesPage._titleColor,
                fontSize: 16,
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 12),
            Expanded(
              child: StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
                stream:
                    FirebaseFirestore.instance.collection('users').snapshots(),
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const Center(child: CircularProgressIndicator());
                  }

                  if (snapshot.hasError) {
                    return Center(child: Text('Error: ${snapshot.error}'));
                  }

                  final currentUserId = FirebaseAuth.instance.currentUser?.uid;
                  final users = (snapshot.data?.docs ?? [])
                      .where((doc) => doc.id != currentUserId)
                      .map((doc) {
                    final data = doc.data();
                    return {
                      'id': doc.id,
                      'name': data['username'] ??
                          data['first_name'] ??
                          data['email'] ??
                          'Unknown',
                      'email': data['email'] ?? '',
                    };
                  }).toList();

                  if (users.isEmpty) {
                    return const Center(
                      child: Text(
                        'No users available',
                        style: TextStyle(color: MessagesPage._mutedColor),
                      ),
                    );
                  }

                  return ListView.separated(
                    itemCount: users.length,
                    separatorBuilder: (_, __) => const SizedBox(height: 8),
                    itemBuilder: (context, index) {
                      final user = users[index];
                      final userId = user['id'] as String;
                      final isSelected = _selectedUserIds.contains(userId);

                      return InkWell(
                        borderRadius: BorderRadius.circular(12),
                        onTap: () {
                          setState(() {
                            if (isSelected) {
                              _selectedUserIds.remove(userId);
                            } else {
                              _selectedUserIds.add(userId);
                            }
                          });
                        },
                        child: Container(
                          padding: const EdgeInsets.all(16),
                          decoration: BoxDecoration(
                            color: isSelected
                                ? MessagesPage._focusColor.withOpacity(0.08)
                                : Colors.white,
                            borderRadius: BorderRadius.circular(12),
                            border: Border.all(
                              color: isSelected
                                  ? MessagesPage._focusColor
                                  : MessagesPage._borderColor,
                              width: isSelected ? 2 : 1,
                            ),
                          ),
                          child: Row(
                            children: [
                              Container(
                                width: 40,
                                height: 40,
                                decoration: BoxDecoration(
                                  color: MessagesPage._chipInactive,
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                alignment: Alignment.center,
                                child: Text(
                                  (user['name'] as String).isEmpty
                                      ? '?'
                                      : (user['name'] as String)
                                          .substring(0, 1)
                                          .toUpperCase(),
                                  style: const TextStyle(
                                    color: MessagesPage._titleColor,
                                    fontWeight: FontWeight.w700,
                                  ),
                                ),
                              ),
                              const SizedBox(width: 16),
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      user['name'] as String,
                                      style: const TextStyle(
                                        color: MessagesPage._titleColor,
                                        fontWeight: FontWeight.w700,
                                        fontSize: 14,
                                      ),
                                    ),
                                    if ((user['email'] as String)
                                        .isNotEmpty) ...[
                                      const SizedBox(height: 2),
                                      Text(
                                        user['email'] as String,
                                        style: const TextStyle(
                                          color: MessagesPage._mutedColor,
                                          fontSize: 12,
                                        ),
                                      ),
                                    ],
                                  ],
                                ),
                              ),
                              if (isSelected)
                                const Icon(
                                  Icons.check_circle,
                                  color: MessagesPage._focusColor,
                                  size: 24,
                                ),
                            ],
                          ),
                        ),
                      );
                    },
                  );
                },
              ),
            ),
            const SizedBox(height: 24),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed:
                        _isCreating ? null : () => Navigator.of(context).pop(),
                    style: OutlinedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12)),
                    ),
                    child: const Text('Cancel'),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: ElevatedButton(
                    onPressed: _isCreating ? null : _createGroup,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: MessagesPage._focusColor,
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12)),
                    ),
                    child: _isCreating
                        ? const SizedBox(
                            width: 20,
                            height: 20,
                            child: CircularProgressIndicator(
                                color: Colors.white, strokeWidth: 2),
                          )
                        : const Text('Create Group',
                            style: TextStyle(fontWeight: FontWeight.w700)),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

/// Horizontally-scrollable strip that lists the authenticated user's chats
/// pulled from the `chats` collection in Firestore. A chat document is
/// considered relevant if the current user's uid is present in the `members`
/// array. We try common title fields for display and fall back to the doc id.
class _MyChatsStrip extends StatelessWidget {
  const _MyChatsStrip({required this.onChatSelected});

  final ValueChanged<Map<String, dynamic>> onChatSelected;

  @override
  Widget build(BuildContext context) {
    // Delay Firebase imports to compile in non-Firebase preview contexts
    // ignore: avoid_dynamic_calls
    return SizedBox(
      height: 90,
      child: _MyChatsStreamBuilder(
        builder: (context, chats) {
          if (chats.isEmpty) {
            return _emptyState();
          }

          return ListView.separated(
            scrollDirection: Axis.horizontal,
            padding: const EdgeInsets.symmetric(horizontal: 4),
            itemCount: chats.length,
            separatorBuilder: (_, __) => const SizedBox(width: 12),
            itemBuilder: (context, index) {
              final data = chats[index];
              final String title = _resolveTitle(data);
              final String subtitle = _resolveSubtitle(data);
              final int unread = _resolveUnread(data);
              final bool isGroup = _isGroup(data);

              return _ChatPill(
                title: title,
                subtitle: subtitle,
                unreadCount: unread,
                isGroup: isGroup,
                onTap: () => onChatSelected(data),
              );
            },
          );
        },
      ),
    );
  }

  static Widget _emptyState() {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: MessagesPage._borderColor),
      ),
      padding: const EdgeInsets.symmetric(horizontal: 16),
      alignment: Alignment.centerLeft,
      child: const Text(
        'No chats yet ‚Äî start a conversation!',
        style: TextStyle(color: MessagesPage._mutedColor, fontSize: 14),
      ),
    );
  }

  static String _resolveTitle(Map<String, dynamic> data) {
    final participantLabels = data['participantLabels'];
    if (participantLabels is Map) {
      final uid = FirebaseAuth.instance.currentUser?.uid;
      if (uid != null) {
        final label = participantLabels[uid];
        if (label is String && label.trim().isNotEmpty) {
          return label.trim();
        }
      }
    }
    for (final key in const ['title', 'name', 'chatName']) {
      final v = data[key];
      if (v is String && v.trim().isNotEmpty) return v.trim();
    }
    final id = data['id'];
    return id is String ? id : 'Conversation';
  }

  static String _resolveSubtitle(Map<String, dynamic> data) {
    // Look for last message text in common locations
    final last = data['lastMessage'];
    if (last is Map<String, dynamic>) {
      final txt = last['text'];
      if (txt is String && txt.trim().isNotEmpty) return txt.trim();
    }
    for (final key in const ['lastText', 'preview']) {
      final v = data[key];
      if (v is String && v.trim().isNotEmpty) return v.trim();
    }
    return '‚Äî';
  }

  static int _resolveUnread(Map<String, dynamic> data) {
    final v = data['unreadCount'];
    if (v is int) return v;
    if (v is num) return v.toInt();
    return 0;
  }

  static bool _isGroup(Map<String, dynamic> data) {
    final isGroup = data['isGroup'];
    if (isGroup is bool && isGroup) return true;
    final type = data['type'];
    if (type is String && type.toLowerCase() == 'group') return true;
    final members = data['members'];
    if (members is List && members.length >= 3) return true;
    if (data['groupName'] is String) return true;
    return false;
  }
}

/// Unread chats for the authenticated user from the Chat collection.
class _UnreadChatsStrip extends StatelessWidget {
  const _UnreadChatsStrip({required this.onChatSelected});

  final ValueChanged<Map<String, dynamic>> onChatSelected;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 90,
      child: _MyChatsStreamBuilder(
        builder: (context, chats) {
          final String? uid = FirebaseAuth.instance.currentUser?.uid;
          if (uid == null) return const SizedBox.shrink();
          final filtered =
              chats.where((c) => _isUnreadForUser(c, uid)).toList();
          if (filtered.isEmpty) {
            // Render nothing if there are no unread conversations.
            return const SizedBox.shrink();
          }
          return ListView.separated(
            scrollDirection: Axis.horizontal,
            padding: const EdgeInsets.symmetric(horizontal: 4),
            itemCount: filtered.length,
            separatorBuilder: (_, __) => const SizedBox(width: 12),
            itemBuilder: (context, index) {
              final data = filtered[index];
              final String title = _MyChatsStrip._resolveTitle(data);
              final String subtitle = _MyChatsStrip._resolveSubtitle(data);
              final int unread = _MyChatsStrip._resolveUnread(data);
              final bool isGroup = _MyChatsStrip._isGroup(data);
              return _ChatPill(
                title: title,
                subtitle: subtitle,
                unreadCount: unread,
                isGroup: isGroup,
                onTap: () => onChatSelected(data),
              );
            },
          );
        },
      ),
    );
  }

  static bool _isUnreadForUser(Map<String, dynamic> data, String uid) {
    // 1) unreadCount (global)
    final unreadCount = data['unreadCount'];
    if (unreadCount is num && unreadCount.toInt() > 0) return true;

    // 2) unreadBy: [uid, ...]
    final unreadBy = data['unreadBy'];
    if (unreadBy is List && unreadBy.contains(uid)) return true;

    // 3) unreadCounts: {uid: n}
    final unreadCounts = data['unreadCounts'];
    if (unreadCounts is Map &&
        (unreadCounts[uid] is num) &&
        (unreadCounts[uid] as num) > 0) {
      return true;
    }

    // 4) lastMessage.timestamp vs readReceipts[uid]
    DateTime? lastTs;
    final last = data['lastMessage'];
    if (last is Map) {
      final ts = last['timestamp'];
      if (ts is Timestamp) lastTs = ts.toDate();
      if (ts is DateTime) lastTs = ts;
      if (ts is num) lastTs = DateTime.fromMillisecondsSinceEpoch(ts.toInt());
      if (ts is String) lastTs = DateTime.tryParse(ts);
    }
    DateTime? readTs;
    final receipts = data['readReceipts'];
    if (receipts is Map) {
      final v = receipts[uid];
      if (v is Timestamp) readTs = v.toDate();
      if (v is DateTime) readTs = v;
      if (v is num) readTs = DateTime.fromMillisecondsSinceEpoch(v.toInt());
      if (v is String) readTs = DateTime.tryParse(v);
    }
    if (lastTs != null && (readTs == null || lastTs.isAfter(readTs))) {
      return true;
    }

    return false;
  }
}

/// Group chats for the authenticated user from the Chat collection.
class _GroupChatsStrip extends StatelessWidget {
  const _GroupChatsStrip({required this.onChatSelected});

  final ValueChanged<Map<String, dynamic>> onChatSelected;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 90,
      child: _MyChatsStreamBuilder(
        builder: (context, chats) {
          final groups = chats.where(_isGroupChat).toList();
          if (groups.isEmpty) {
            return _emptyGroupState(context, onChatSelected);
          }
          return ListView.separated(
            scrollDirection: Axis.horizontal,
            padding: const EdgeInsets.symmetric(horizontal: 4),
            itemCount: groups.length + 1,
            separatorBuilder: (_, __) => const SizedBox(width: 12),
            itemBuilder: (context, index) {
              if (index == groups.length) {
                return _createGroupButton(context, onChatSelected);
              }
              final data = groups[index];
              final String title = _MyChatsStrip._resolveTitle(data);
              final String subtitle = _MyChatsStrip._resolveSubtitle(data);
              final int unread = _MyChatsStrip._resolveUnread(data);
              return _ChatPill(
                title: title,
                subtitle: subtitle,
                unreadCount: unread,
                isGroup: true,
                onTap: () => onChatSelected(data),
              );
            },
          );
        },
      ),
    );
  }

  static Widget _emptyGroupState(
      BuildContext context, ValueChanged<Map<String, dynamic>> onChatSelected) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: MessagesPage._borderColor),
      ),
      padding: const EdgeInsets.symmetric(horizontal: 16),
      alignment: Alignment.center,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Text(
            'No groups yet',
            style: TextStyle(color: MessagesPage._mutedColor, fontSize: 14),
          ),
          const SizedBox(width: 12),
          TextButton.icon(
            onPressed: () async {
              final newId = await _showCreateGroupDialog(context);
              if (newId != null) {
                final snapshot = await FirebaseFirestore.instance
                    .collection('chats')
                    .doc(newId)
                    .get();
                final data = snapshot.data();
                if (data != null) {
                  final chat = {...data, 'id': snapshot.id};
                  onChatSelected(chat);
                }
              }
            },
            icon: const Icon(Icons.add_circle_outline, size: 18),
            label: const Text('Create Group'),
            style: TextButton.styleFrom(
              foregroundColor: MessagesPage._focusColor,
              textStyle:
                  const TextStyle(fontWeight: FontWeight.w700, fontSize: 14),
            ),
          ),
        ],
      ),
    );
  }

  static Widget _createGroupButton(
      BuildContext context, ValueChanged<Map<String, dynamic>> onChatSelected) {
    return InkWell(
      borderRadius: BorderRadius.circular(16),
      onTap: () async {
        final newId = await _showCreateGroupDialog(context);
        if (newId != null) {
          final snapshot = await FirebaseFirestore.instance
              .collection('chats')
              .doc(newId)
              .get();
          final data = snapshot.data();
          if (data != null) {
            final chat = {...data, 'id': snapshot.id};
            onChatSelected(chat);
          }
        }
      },
      child: Container(
        width: 200,
        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 16),
        decoration: BoxDecoration(
          color: MessagesPage._focusColor.withOpacity(0.06),
          borderRadius: BorderRadius.circular(16),
          border: Border.all(
              color: MessagesPage._focusColor.withOpacity(0.4),
              style: BorderStyle.solid,
              width: 2),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: const [
            Icon(Icons.add_circle_outline,
                color: MessagesPage._focusColor, size: 24),
            SizedBox(width: 12),
            Text(
              'Create Group',
              style: TextStyle(
                color: MessagesPage._focusColor,
                fontWeight: FontWeight.w700,
                fontSize: 14,
              ),
            ),
          ],
        ),
      ),
    );
  }

  static bool _isGroupChat(Map<String, dynamic> data) {
    // Explicit flags first
    final isGroup = data['isGroup'];
    if (isGroup is bool && isGroup) return true;
    final type = data['type'];
    if (type is String && type.toLowerCase() == 'group') return true;
    // Fallback: members length >= 3 is considered a group
    final members = data['members'];
    if (members is List && members.length >= 3) return true;
    // Presence of groupName is also a hint
    if (data['groupName'] is String) return true;
    return false;
  }
}

class _ChatPill extends StatelessWidget {
  const _ChatPill({
    required this.title,
    required this.subtitle,
    required this.unreadCount,
    this.onTap,
    this.isGroup = false,
  });

  final String title;
  final String subtitle;
  final int unreadCount;
  final VoidCallback? onTap;
  final bool isGroup;

  @override
  Widget build(BuildContext context) {
    final bool hasUnread = unreadCount > 0;
    return InkWell(
      borderRadius: BorderRadius.circular(16),
      onTap: onTap,
      child: Container(
        width: 270,
        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 16),
        decoration: BoxDecoration(
          color: hasUnread
              ? MessagesPage._focusColor.withOpacity(0.06)
              : Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(
              color: hasUnread
                  ? MessagesPage._focusColor.withOpacity(0.4)
                  : MessagesPage._borderColor),
          boxShadow: [
            BoxShadow(
              color: hasUnread
                  ? MessagesPage._focusColor.withOpacity(0.22)
                  : Colors.black.withOpacity(0.04),
              blurRadius: 14,
              offset: const Offset(0, 10),
            ),
          ],
        ),
        child: Row(
          children: [
            Container(
              width: 44,
              height: 44,
              decoration: BoxDecoration(
                gradient: hasUnread
                    ? const LinearGradient(
                        colors: [Color(0xFF2563EB), Color(0xFF1E40AF)],
                        begin: Alignment.topLeft,
                        end: Alignment.bottomRight,
                      )
                    : null,
                color: hasUnread ? null : MessagesPage._chipInactive,
                borderRadius: BorderRadius.circular(14),
                border: Border.all(
                    color: hasUnread
                        ? Colors.white.withOpacity(0.4)
                        : MessagesPage._borderColor),
              ),
              alignment: Alignment.center,
              child: Icon(
                isGroup ? Icons.group_outlined : Icons.person_outline,
                color: hasUnread ? Colors.white : MessagesPage._titleColor,
                size: 20,
              ),
            ),
            const SizedBox(width: 14),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(
                    title,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: const TextStyle(
                      color: MessagesPage._titleColor,
                      fontWeight: FontWeight.w700,
                      fontSize: 14,
                    ),
                  ),
                  const SizedBox(height: 2),
                  Text(
                    subtitle,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: const TextStyle(
                      color: MessagesPage._mutedColor,
                      fontSize: 12,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
            if (unreadCount > 0) ...[
              Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
                decoration: BoxDecoration(
                  color: MessagesPage._focusColor,
                  borderRadius: BorderRadius.circular(999),
                ),
                child: Text(
                  '$unreadCount',
                  style: const TextStyle(
                      color: Colors.white,
                      fontSize: 11,
                      fontWeight: FontWeight.w700),
                ),
              ),
            ],
            const SizedBox(width: 10),
            Icon(Icons.chevron_right_rounded,
                color: hasUnread
                    ? MessagesPage._focusColor
                    : MessagesPage._mutedColor,
                size: 20),
          ],
        ),
      ),
    );
  }
}

/// Thin wrapper that hosts the StreamBuilder and isolates imports.
class _MyChatsStreamBuilder extends StatelessWidget {
  const _MyChatsStreamBuilder({required this.builder});

  final Widget Function(BuildContext, List<Map<String, dynamic>>) builder;

  @override
  Widget build(BuildContext context) {
    // Import here to keep this file cohesive while avoiding unused import warnings
    // in other parts of the file if MessagesPage isn't mounted.
    // ignore: import_of_legacy_library_into_null_safe
    return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
      stream: (() {
        try {
          // Lazily access Firebase to avoid build-time issues when not configured yet.
          // These imports are required at runtime and are declared in pubspec.
          // ignore: unnecessary_import
          return FirebaseFirestore.instance
              // Use 'chats' collection as requested
              .collection('chats')
              .where('members',
                  arrayContains: FirebaseAuth.instance.currentUser?.uid)
              .withConverter<Map<String, dynamic>>(
                  fromFirestore: (snap, _) =>
                      snap.data() ?? <String, dynamic>{},
                  toFirestore: (data, _) => data)
              .snapshots();
        } catch (_) {
          return const Stream<QuerySnapshot<Map<String, dynamic>>>.empty();
        }
      })(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const _MyChatsLoading();
        }

        if (snapshot.hasError) {
          return _errorPill('${snapshot.error}');
        }

        final qs = snapshot.data;
        final List<Map<String, dynamic>> items =
            (qs?.docs ?? const <QueryDocumentSnapshot<Map<String, dynamic>>>[])
                .map((d) {
          final map = Map<String, dynamic>.from(d.data());
          map['id'] = d.id;
          return map;
        }).toList();

        // Sort by updatedAt if present
        items.sort((a, b) {
          DateTime parse(dynamic v) {
            if (v is Timestamp) return v.toDate();
            if (v is DateTime) return v;
            if (v is num) return DateTime.fromMillisecondsSinceEpoch(v.toInt());
            if (v is String) {
              final dt = DateTime.tryParse(v);
              if (dt != null) return dt;
            }
            return DateTime.fromMillisecondsSinceEpoch(0);
          }

          final da = parse(a['updatedAt'] ?? (a['lastMessage']?['timestamp']));
          final db = parse(b['updatedAt'] ?? (b['lastMessage']?['timestamp']));
          return db.compareTo(da);
        });

        return builder(context, items);
      },
    );
  }

  static Widget _errorPill(String message) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: MessagesPage._borderColor),
      ),
      padding: const EdgeInsets.symmetric(horizontal: 16),
      alignment: Alignment.centerLeft,
      child: Row(
        children: [
          const Icon(Icons.error_outline, color: Colors.redAccent, size: 18),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              'Failed to load chats: $message',
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
              style: const TextStyle(
                  color: MessagesPage._mutedColor, fontSize: 13),
            ),
          ),
        ],
      ),
    );
  }
}

class _MyChatsLoading extends StatelessWidget {
  const _MyChatsLoading();

  @override
  Widget build(BuildContext context) {
    return ShimmerList.horizontal(
      itemWidth: 220,
      itemHeight: 72,
      itemCount: 3,
      borderRadius: 16,
    );
  }
}

/// Right-side members panel shown on MessagesPage. Displays a simple, styled
/// roster list inside a fixed-height card.
class _ChatMembersPanel extends StatelessWidget {
  const _ChatMembersPanel({required this.height});

  final double height;

  static const List<_FriendSuggestionData> _mockMembers = [
    _FriendSuggestionData(
      name: 'Alex Johnson',
      email: 'alex.j@company.com',
      details: ['Coach', 'Active'],
    ),
    _FriendSuggestionData(
      name: 'Sam Lee',
      email: 'sam.lee@company.com',
      details: ['Member'],
    ),
    _FriendSuggestionData(
      name: 'Taylor Brooks',
      email: 'taylor@company.com',
      details: ['Member', 'Unread 2'],
    ),
    _FriendSuggestionData(
      name: 'Jordan Kim',
      email: 'j.kim@company.com',
      details: ['Coach'],
    ),
    _FriendSuggestionData(
      name: 'Riley Chen',
      email: 'riley@company.com',
      details: ['Member'],
    ),
  ];

  @override
  Widget build(BuildContext context) {
    final int totalMembers = _mockMembers.length;
    return Container(
      constraints: BoxConstraints(minHeight: height),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(22),
        border: Border.all(color: MessagesPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(20, 18, 20, 18),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Container(
                      width: 40,
                      height: 40,
                      decoration: BoxDecoration(
                        color: MessagesPage._focusColor.withOpacity(0.08),
                        borderRadius: BorderRadius.circular(14),
                      ),
                      child: const Icon(Icons.people_outline,
                          color: MessagesPage._focusColor, size: 20),
                    ),
                    const SizedBox(width: 12),
                    const Expanded(
                      child: Text(
                        'Members',
                        style: TextStyle(
                          color: MessagesPage._titleColor,
                          fontSize: 16,
                          fontWeight: FontWeight.w800,
                        ),
                      ),
                    ),
                    Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 12, vertical: 6),
                      decoration: BoxDecoration(
                        color: MessagesPage._chipInactive,
                        borderRadius: BorderRadius.circular(999),
                        border: Border.all(color: MessagesPage._borderColor),
                      ),
                      child: Text(
                        '$totalMembers',
                        style: const TextStyle(
                            color: MessagesPage._titleColor,
                            fontSize: 12,
                            fontWeight: FontWeight.w700),
                      ),
                    ),
                    const SizedBox(width: 12),
                    IconButton(
                      tooltip: 'Add member',
                      splashRadius: 20,
                      onPressed: () => _showCreateGroupDialog(context),
                      icon: const Icon(Icons.person_add_alt_1,
                          color: MessagesPage._focusColor),
                    ),
                  ],
                ),
                const SizedBox(height: 10),
                const Text(
                  'Keep everyone close at hand ‚Äî search, filter, and jump into a profile in seconds.',
                  style: TextStyle(
                      color: MessagesPage._mutedColor,
                      fontSize: 12,
                      height: 1.4,
                      fontWeight: FontWeight.w500),
                ),
                const SizedBox(height: 16),
                SizedBox(
                  height: 46,
                  child: TextField(
                    decoration: InputDecoration(
                      hintText: 'Search roster',
                      hintStyle: const TextStyle(
                          color: MessagesPage._mutedColor, fontSize: 12),
                      prefixIcon: const Icon(Icons.search,
                          color: MessagesPage._mutedColor, size: 18),
                      filled: true,
                      fillColor: Colors.white,
                      contentPadding: const EdgeInsets.symmetric(
                          horizontal: 16, vertical: 12),
                      enabledBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(15),
                        borderSide:
                            const BorderSide(color: MessagesPage._borderColor),
                      ),
                      focusedBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(15),
                        borderSide: const BorderSide(
                            color: MessagesPage._focusColor, width: 1.4),
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 14),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: const [
                    _MemberFilterChip(label: 'All', isActive: true),
                    _MemberFilterChip(label: 'Coaches'),
                    _MemberFilterChip(label: 'Members'),
                    _MemberFilterChip(label: 'Unread'),
                  ],
                ),
              ],
            ),
          ),
          const Divider(height: 1, color: MessagesPage._borderColor),
          SizedBox(
            height: 240,
            child: Scrollbar(
              child: ListView.separated(
                padding: const EdgeInsets.fromLTRB(20, 18, 20, 24),
                itemCount: _mockMembers.length,
                separatorBuilder: (_, __) => const SizedBox(height: 12),
                itemBuilder: (context, index) {
                  final m = _mockMembers[index];
                  return _MemberRow(data: m, isHighlighted: index == 0);
                },
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _MemberFilterChip extends StatelessWidget {
  const _MemberFilterChip({required this.label, this.isActive = false});

  final String label;
  final bool isActive;

  @override
  Widget build(BuildContext context) {
    final Color foreground =
        isActive ? MessagesPage._focusColor : MessagesPage._titleColor;
    return InkWell(
      onTap: () {},
      borderRadius: BorderRadius.circular(999),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
        decoration: BoxDecoration(
          color: isActive
              ? MessagesPage._focusColor.withOpacity(0.1)
              : MessagesPage._chipInactive,
          borderRadius: BorderRadius.circular(999),
          border: Border.all(
              color: isActive
                  ? MessagesPage._focusColor.withOpacity(0.28)
                  : MessagesPage._borderColor),
        ),
        child: Text(
          label,
          style: TextStyle(
              color: foreground, fontSize: 12, fontWeight: FontWeight.w700),
        ),
      ),
    );
  }
}

class _MemberRow extends StatelessWidget {
  const _MemberRow({required this.data, this.isHighlighted = false});

  final _FriendSuggestionData data;
  final bool isHighlighted;

  @override
  Widget build(BuildContext context) {
    final Color background = isHighlighted
        ? MessagesPage._focusColor.withOpacity(0.08)
        : Colors.white;
    final List<BoxShadow>? shadow = isHighlighted
        ? [
            BoxShadow(
              color: MessagesPage._focusColor.withOpacity(0.16),
              blurRadius: 18,
              offset: const Offset(0, 10),
            ),
          ]
        : null;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: background,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
            color: isHighlighted
                ? MessagesPage._focusColor.withOpacity(0.32)
                : MessagesPage._borderColor),
        boxShadow: shadow,
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _Avatar(name: data.name),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        data.name,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                        style: const TextStyle(
                          color: MessagesPage._titleColor,
                          fontWeight: FontWeight.w800,
                          fontSize: 14,
                        ),
                      ),
                    ),
                    const SizedBox(width: 8),
                    IconButton(
                      tooltip: 'Message ${data.name}',
                      onPressed: () {},
                      icon: const Icon(Icons.send_outlined,
                          size: 18, color: MessagesPage._focusColor),
                    ),
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  data.email,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: const TextStyle(
                      color: MessagesPage._mutedColor,
                      fontSize: 12,
                      fontWeight: FontWeight.w500),
                ),
                const SizedBox(height: 12),
                Wrap(
                  spacing: 6,
                  runSpacing: 6,
                  children: data.details
                      .map((d) => Container(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 10, vertical: 6),
                            decoration: BoxDecoration(
                              color: Colors.white,
                              borderRadius: BorderRadius.circular(999),
                              border:
                                  Border.all(color: MessagesPage._borderColor),
                            ),
                            child: Text(
                              d,
                              style: const TextStyle(
                                color: MessagesPage._titleColor,
                                fontSize: 11,
                                fontWeight: FontWeight.w700,
                              ),
                            ),
                          ))
                      .toList(),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _Avatar extends StatelessWidget {
  const _Avatar({required this.name});

  final String name;

  @override
  Widget build(BuildContext context) {
    String initials() {
      final parts = name.trim().split(RegExp(r"\s+"));
      if (parts.isEmpty) return '?';
      final first = parts.first.isNotEmpty ? parts.first[0] : '';
      final second = parts.length > 1 && parts[1].isNotEmpty ? parts[1][0] : '';
      return (first + second).toUpperCase();
    }

    return Container(
      width: 36,
      height: 36,
      decoration: BoxDecoration(
        color: MessagesPage._chipInactive,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: MessagesPage._borderColor),
      ),
      alignment: Alignment.center,
      child: Text(
        initials(),
        style: const TextStyle(
          color: MessagesPage._titleColor,
          fontWeight: FontWeight.w800,
          fontSize: 12,
        ),
      ),
    );
  }
}

class ScorecardPage extends StatefulWidget {
  const ScorecardPage({super.key, this.onViewDetails});

  final ValueChanged<String>? onViewDetails;

  static const Color _titleColor = Color(0xFF111827);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE5E7EB);
  static const Color _buttonBlue = Color(0xFF2563EB);
  static const Color _indicatorColor = Color(0xFF8AC7C9);

  static const List<Map<String, String>> _metricTitlesAndDescriptions = [
    {
      'title': 'DeepThrive Sessions',
      'description':
          'Regular sessions of uninterrupted, deep work on high-value activities'
    },
    {
      'title': 'Delegation Success',
      'description':
          'Measure how effectively you hand off responsibilities and follow through on outcomes'
    },
    {
      'title': 'Core4 Alignment',
      'description':
          'Track alignment to your Core4 priorities and the habits that reinforce them'
    },
    {
      'title': 'Guiding GeniusTime',
      'description':
          'Log the intentional hours you dedicate to your highest-leverage GeniusTime focus areas'
    },
    {
      'title': 'Right People Right Seats',
      'description':
          'Evaluate how well team members are positioned in roles where they can thrive'
    },
    {
      'title': 'Blueprint Utilization',
      'description':
          'Capture how consistently you apply the Breakaway365 blueprint in daily execution'
    },
  ];

  static int metricNumberForTitle(String title) {
    final index =
        _metricTitlesAndDescriptions.indexWhere((m) => m['title'] == title);
    return index == -1 ? 1 : index + 1;
  }

  static String metricDescriptionForTitle(String title) {
    final metric = _metricTitlesAndDescriptions.firstWhere(
      (m) => m['title'] == title,
      orElse: () => _metricTitlesAndDescriptions.first,
    );
    return metric['description'] ?? '';
  }

  @override
  State<ScorecardPage> createState() => _ScorecardPageState();
}

class _ScorecardPageState extends State<ScorecardPage> {
  // Map to store last updated times for each metric from their collections
  Map<String, DateTime?> _lastUpdatedTimes = {};
  Map<String, double> _metricProgress = {};
  bool _isLoading = true;
  String _userFullName = '';
  List<Map<String, dynamic>> _customMetrics = [];

  // Collection mapping based on user requirements
  static const Map<String, String> _collectionMap = {
    'DeepThrive Sessions': 'DEEPTHRIVESESSIONS',
    'Delegation Success': 'Delegation',
    'Core4 Alignment': 'CORE4ALIGNMENTSCORE',
    'Guiding GeniusTime': 'GuildingGeniusTime',
    'Right People Right Seats': 'RightPeopleRightSeats',
    'Blueprint Utilization': 'BlueprintUtilization',
  };

  // Field mapping for user reference and date fields
  static const Map<String, Map<String, String>> _fieldMap = {
    'DEEPTHRIVESESSIONS': {'userRef': 'useref', 'dateField': 'lastpdated'},
    'Delegation': {'userRef': 'user', 'dateField': 'dateupdated'},
    'CORE4ALIGNMENTSCORE': {'userRef': 'useref', 'dateField': 'updateddate'},
    'GuildingGeniusTime': {'userRef': 'memberId', 'dateField': 'updatedtime'},
    'RightPeopleRightSeats': {
      'userRef': 'memberId',
      'dateField': 'updatedtime'
    },
    'BlueprintUtilization': {'userRef': 'memberId', 'dateField': 'updatedtime'},
  };

  @override
  void initState() {
    super.initState();
    _loadScorecardData();
    _loadUserName();
    _loadCustomMetrics();
  }

  Future<void> _loadUserName() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    try {
      final doc =
          await FirebaseFirestore.instance.collection('users').doc(uid).get();
      if (doc.exists && mounted) {
        final data = doc.data()!;
        final firstName =
            data['first_name'] as String? ?? data['firstName'] as String? ?? '';
        final lastName =
            data['last_name'] as String? ?? data['lastName'] as String? ?? '';
        final fullName = '$firstName $lastName'.trim();
        if (fullName.isNotEmpty) {
          setState(() => _userFullName = fullName);
        } else {
          // Fallback to display_name or displayName
          final displayName = data['display_name'] as String? ??
              data['displayName'] as String? ??
              '';
          if (displayName.isNotEmpty && mounted) {
            setState(() => _userFullName = displayName);
          }
        }
      }
    } catch (e) {
      debugPrint('Error loading user name: $e');
    }
  }

  Future<void> _loadCustomMetrics() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    try {
      final snapshot = await FirebaseFirestore.instance
          .collection('users')
          .doc(uid)
          .collection('customMetrics')
          .orderBy('createdAt', descending: true)
          .get();
      if (mounted) {
        setState(() {
          _customMetrics = snapshot.docs.map((doc) {
            final data = doc.data();
            return {'id': doc.id, ...data};
          }).toList();
        });
      }
    } catch (e) {
      debugPrint('Error loading custom metrics: $e');
    }
  }

  void _showCustomMetricsDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => _CustomMetricsDialog(
        customMetrics: _customMetrics,
        onMetricAdded: _addCustomMetric,
        onMetricDeleted: _deleteCustomMetric,
        onMetricUpdated: _updateCustomMetric,
      ),
    );
  }

  Future<void> _addCustomMetric(
      String title, String description, double targetValue) async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    try {
      final docRef = await FirebaseFirestore.instance
          .collection('users')
          .doc(uid)
          .collection('customMetrics')
          .add({
        'title': title,
        'description': description,
        'targetValue': targetValue,
        'currentValue': 0.0,
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      if (mounted) {
        setState(() {
          _customMetrics.insert(0, {
            'id': docRef.id,
            'title': title,
            'description': description,
            'targetValue': targetValue,
            'currentValue': 0.0,
          });
        });
      }
    } catch (e) {
      debugPrint('Error adding custom metric: $e');
    }
  }

  Future<void> _deleteCustomMetric(String metricId) async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    try {
      await FirebaseFirestore.instance
          .collection('users')
          .doc(uid)
          .collection('customMetrics')
          .doc(metricId)
          .delete();
      if (mounted) {
        setState(() {
          _customMetrics.removeWhere((m) => m['id'] == metricId);
        });
      }
    } catch (e) {
      debugPrint('Error deleting custom metric: $e');
    }
  }

  Future<void> _updateCustomMetric(String metricId, double currentValue) async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;
    try {
      await FirebaseFirestore.instance
          .collection('users')
          .doc(uid)
          .collection('customMetrics')
          .doc(metricId)
          .update({
        'currentValue': currentValue,
        'updatedAt': FieldValue.serverTimestamp(),
      });
      if (mounted) {
        setState(() {
          final index = _customMetrics.indexWhere((m) => m['id'] == metricId);
          if (index != -1) {
            _customMetrics[index]['currentValue'] = currentValue;
          }
        });
      }
    } catch (e) {
      debugPrint('Error updating custom metric: $e');
    }
  }

  Future<void> _loadScorecardData() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) {
      setState(() => _isLoading = false);
      return;
    }

    try {
      final Map<String, DateTime?> lastUpdates = {};
      final Map<String, double> progress = {};

      // Query metricUpdates collection for each metric type
      final metricNames = [
        'DeepThrive Sessions',
        'Delegation Success',
        'Core4 Alignment',
        'Guiding GeniusTime',
        'Right People Right Seats',
        'Blueprint Utilization',
      ];

      for (final metricName in metricNames) {
        try {
          final snapshot = await FirebaseFirestore.instance
              .collection('metricUpdates')
              .where('userId', isEqualTo: uid)
              .where('metricName', isEqualTo: metricName)
              .get();

          if (snapshot.docs.isNotEmpty) {
            // Find the most recent entry by comparing updatedAt or createdAt
            DateTime? latestDate;
            double latestProgress = 0.0;

            for (final doc in snapshot.docs) {
              final data = doc.data();
              DateTime? docDate;

              // Try updatedAt first, then createdAt, then date
              if (data['updatedAt'] is Timestamp) {
                docDate = (data['updatedAt'] as Timestamp).toDate();
              } else if (data['createdAt'] is Timestamp) {
                docDate = (data['createdAt'] as Timestamp).toDate();
              } else if (data['date'] is Timestamp) {
                docDate = (data['date'] as Timestamp).toDate();
              }

              if (docDate != null &&
                  (latestDate == null || docDate.isAfter(latestDate))) {
                latestDate = docDate;
                // Get progress value (stored as 0-100)
                final progressValue = data['progress'];
                if (progressValue is num) {
                  latestProgress = (progressValue / 100).clamp(0.0, 1.0);
                }
              }
            }

            if (latestDate != null) {
              lastUpdates[metricName] = latestDate;
              progress[metricName] = latestProgress;
            }
          }
        } catch (e) {
          debugPrint('Error loading metric $metricName: $e');
        }
      }

      if (mounted) {
        setState(() {
          _lastUpdatedTimes = lastUpdates;
          _metricProgress = progress;
          _isLoading = false;
        });
      }
    } catch (e) {
      debugPrint('Error loading scorecard data: $e');
      if (mounted) setState(() => _isLoading = false);
    }
  }

  String _formatLastUpdated(DateTime? date) {
    if (date == null) return 'No time';
    final now = DateTime.now();
    final diff = now.difference(date);
    if (diff.inDays > 0) return '${diff.inDays}d ago';
    if (diff.inHours > 0) return '${diff.inHours}h ago';
    if (diff.inMinutes > 0) return '${diff.inMinutes}m ago';
    return 'Just now';
  }

  List<_ScoreMetricData> get _metrics => [
        _ScoreMetricData(
          title: 'DeepThrive Sessions',
          icon: Icons.groups_outlined,
          lastUpdated:
              _formatLastUpdated(_lastUpdatedTimes['DeepThrive Sessions']),
          description:
              'Regular sessions of uninterrupted, deep work on high-value activities',
          progress: _metricProgress['DeepThrive Sessions'] ?? 0,
        ),
        _ScoreMetricData(
          title: 'Delegation Success',
          icon: Icons.speed_outlined,
          lastUpdated:
              _formatLastUpdated(_lastUpdatedTimes['Delegation Success']),
          description:
              'Measure how effectively you hand off responsibilities and follow through on outcomes',
          progress: _metricProgress['Delegation Success'] ?? 0,
        ),
        _ScoreMetricData(
          title: 'Core4 Alignment',
          icon: Icons.apps_outlined,
          lastUpdated: _formatLastUpdated(_lastUpdatedTimes['Core4 Alignment']),
          description:
              'Track alignment to your Core4 priorities and the habits that reinforce them',
          progress: _metricProgress['Core4 Alignment'] ?? 0,
        ),
        _ScoreMetricData(
          title: 'Guiding GeniusTime',
          icon: Icons.psychology_outlined,
          lastUpdated:
              _formatLastUpdated(_lastUpdatedTimes['Guiding GeniusTime']),
          description:
              'Log the intentional hours you dedicate to your highest-leverage GeniusTime focus areas',
          progress: _metricProgress['Guiding GeniusTime'] ?? 0,
        ),
        _ScoreMetricData(
          title: 'Right People Right Seats',
          icon: Icons.people_alt_outlined,
          lastUpdated:
              _formatLastUpdated(_lastUpdatedTimes['Right People Right Seats']),
          description:
              'Evaluate how well team members are positioned in roles where they can thrive',
          progress: _metricProgress['Right People Right Seats'] ?? 0,
        ),
        _ScoreMetricData(
          title: 'Blueprint Utilization',
          icon: Icons.description_outlined,
          lastUpdated:
              _formatLastUpdated(_lastUpdatedTimes['Blueprint Utilization']),
          description:
              'Capture how consistently you apply the Breakaway365 blueprint in daily execution',
          progress: _metricProgress['Blueprint Utilization'] ?? 0,
        ),
      ];

  static const List<String> _metricForms = [
    'DeepThrive Sessions',
    'Delegation Success',
    'Core4 Alignment',
    'Guiding GeniusTime',
    'Right People Right Seats',
    'Blueprint Utilization',
    'Custom Metric',
  ];

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }
    return LayoutBuilder(
      builder: (context, constraints) {
        final double horizontalPadding =
            constraints.maxWidth > 1180 ? 56.0 : 32.0;
        final double contentWidth =
            constraints.maxWidth - (horizontalPadding * 2);

        int columnsForWidth(double width) {
          if (width >= 1400) return 3;
          if (width >= 900) return 2;
          return 1;
        }

        final int columns = columnsForWidth(contentWidth);
        final bool stackHeader = contentWidth < 860;
        final bool stackSearchRow = contentWidth < 760;

        Widget moreInfoAndButton() {
          return _moreInformationCard();
        }

        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Score Card',
                style: TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.w700,
                  color: ScorecardPage._titleColor,
                ),
              ),
              const SizedBox(height: 24),
              moreInfoAndButton(),
              const SizedBox(height: 36),
              Text(
                'Key Metrics',
                style: TextStyle(
                  color: ScorecardPage._titleColor,
                  fontSize: 18,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 20),
              GridView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: columns,
                  mainAxisSpacing: 24,
                  crossAxisSpacing: 24,
                  childAspectRatio: columns == 1
                      ? 1.6
                      : columns == 2
                          ? 1.35
                          : 1.25,
                ),
                itemCount: _metrics.length,
                itemBuilder: (context, index) => _ScoreMetricCard(
                  data: _metrics[index],
                  onViewDetails: widget.onViewDetails,
                ),
              ),
              const SizedBox(height: 32),
              const _CoachCommitmentCard(),
              const SizedBox(height: 32),
              _metricFormsSection(),
            ],
          ),
        );
      },
    );
  }

  Widget _moreInformationCard() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 28, vertical: 24),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: ScorecardPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.04),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'More Information',
            style: TextStyle(
              color: ScorecardPage._titleColor,
              fontSize: 18,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 24),
          const Text(
            'Name',
            style: TextStyle(
              color: ScorecardPage._mutedColor,
              fontSize: 13,
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            _userFullName.isNotEmpty ? _userFullName : 'Loading...',
            style: const TextStyle(
              color: ScorecardPage._titleColor,
              fontSize: 20,
              fontWeight: FontWeight.w700,
            ),
          ),
        ],
      ),
    );
  }

  Widget _metricFormsSection() {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: ScorecardPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.04),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Metric Forms',
            style: TextStyle(
              color: ScorecardPage._titleColor,
              fontSize: 18,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 6),
          const Text(
            'Update your Scorecard metrics and progress',
            style: TextStyle(color: ScorecardPage._mutedColor, fontSize: 14),
          ),
          const SizedBox(height: 24),
          Wrap(
            spacing: 20,
            runSpacing: 20,
            children: _metricForms
                .map(
                  (label) => _MetricFormChip(label: label),
                )
                .toList(),
          ),
        ],
      ),
    );
  }
}

class _CustomMetricsDialog extends StatefulWidget {
  const _CustomMetricsDialog({
    required this.customMetrics,
    required this.onMetricAdded,
    required this.onMetricDeleted,
    required this.onMetricUpdated,
  });

  final List<Map<String, dynamic>> customMetrics;
  final Future<void> Function(
      String title, String description, double targetValue) onMetricAdded;
  final Future<void> Function(String metricId) onMetricDeleted;
  final Future<void> Function(String metricId, double currentValue)
      onMetricUpdated;

  @override
  State<_CustomMetricsDialog> createState() => _CustomMetricsDialogState();
}

class _CustomMetricsDialogState extends State<_CustomMetricsDialog> {
  bool _isAddingNew = false;
  final _titleController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _targetController = TextEditingController();
  bool _isSaving = false;

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    _targetController.dispose();
    super.dispose();
  }

  void _resetForm() {
    _titleController.clear();
    _descriptionController.clear();
    _targetController.clear();
    setState(() => _isAddingNew = false);
  }

  Future<void> _saveMetric() async {
    if (_titleController.text.trim().isEmpty) return;
    final targetValue = double.tryParse(_targetController.text.trim()) ?? 100.0;
    setState(() => _isSaving = true);
    await widget.onMetricAdded(
      _titleController.text.trim(),
      _descriptionController.text.trim(),
      targetValue,
    );
    setState(() => _isSaving = false);
    _resetForm();
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      backgroundColor: Colors.white,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      child: Container(
        width: 500,
        constraints: const BoxConstraints(maxHeight: 600),
        padding: const EdgeInsets.all(28),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Expanded(
                  child: Text(
                    'Custom Metrics',
                    style: TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.w700,
                      color: Color(0xFF111827),
                    ),
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.close, color: Color(0xFF6B7280)),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ],
            ),
            const SizedBox(height: 8),
            const Text(
              'Define and track your own personal metrics to measure progress.',
              style: TextStyle(fontSize: 14, color: Color(0xFF6B7280)),
            ),
            const SizedBox(height: 20),
            if (_isAddingNew) ...[
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: const Color(0xFFF9FAFB),
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: const Color(0xFFE5E7EB)),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text('New Metric',
                        style: TextStyle(
                            fontWeight: FontWeight.w600, fontSize: 14)),
                    const SizedBox(height: 12),
                    TextField(
                      controller: _titleController,
                      decoration: InputDecoration(
                        labelText: 'Metric Name',
                        hintText: 'e.g., Weekly Sales Calls',
                        filled: true,
                        fillColor: Colors.white,
                        border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(8)),
                        contentPadding: const EdgeInsets.symmetric(
                            horizontal: 12, vertical: 10),
                      ),
                    ),
                    const SizedBox(height: 12),
                    TextField(
                      controller: _descriptionController,
                      decoration: InputDecoration(
                        labelText: 'Description (optional)',
                        hintText: 'What does this metric measure?',
                        filled: true,
                        fillColor: Colors.white,
                        border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(8)),
                        contentPadding: const EdgeInsets.symmetric(
                            horizontal: 12, vertical: 10),
                      ),
                      maxLines: 2,
                    ),
                    const SizedBox(height: 12),
                    TextField(
                      controller: _targetController,
                      keyboardType:
                          const TextInputType.numberWithOptions(decimal: true),
                      decoration: InputDecoration(
                        labelText: 'Target Value',
                        hintText: '100',
                        filled: true,
                        fillColor: Colors.white,
                        border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(8)),
                        contentPadding: const EdgeInsets.symmetric(
                            horizontal: 12, vertical: 10),
                      ),
                    ),
                    const SizedBox(height: 16),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        TextButton(
                          onPressed: _resetForm,
                          child: const Text('Cancel'),
                        ),
                        const SizedBox(width: 8),
                        ElevatedButton(
                          onPressed: _isSaving ? null : _saveMetric,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: const Color(0xFF2563EB),
                            foregroundColor: Colors.white,
                            shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(8)),
                          ),
                          child: _isSaving
                              ? const SizedBox(
                                  width: 16,
                                  height: 16,
                                  child: CircularProgressIndicator(
                                      strokeWidth: 2, color: Colors.white))
                              : const Text('Save Metric'),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 16),
            ] else ...[
              SizedBox(
                width: double.infinity,
                child: OutlinedButton.icon(
                  onPressed: () => setState(() => _isAddingNew = true),
                  icon: const Icon(Icons.add, size: 18),
                  label: const Text('Add New Metric'),
                  style: OutlinedButton.styleFrom(
                    foregroundColor: const Color(0xFF2563EB),
                    side: const BorderSide(color: Color(0xFF2563EB)),
                    padding: const EdgeInsets.symmetric(vertical: 14),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(10)),
                  ),
                ),
              ),
              const SizedBox(height: 16),
            ],
            if (widget.customMetrics.isEmpty && !_isAddingNew)
              const Padding(
                padding: EdgeInsets.symmetric(vertical: 32),
                child: Center(
                  child: Text(
                    'No custom metrics yet.\nClick "Add New Metric" to create one.',
                    textAlign: TextAlign.center,
                    style: TextStyle(color: Color(0xFF9CA3AF), fontSize: 14),
                  ),
                ),
              )
            else if (widget.customMetrics.isNotEmpty)
              Flexible(
                child: ListView.separated(
                  shrinkWrap: true,
                  itemCount: widget.customMetrics.length,
                  separatorBuilder: (_, __) => const SizedBox(height: 12),
                  itemBuilder: (context, index) {
                    final metric = widget.customMetrics[index];
                    final title = metric['title'] as String? ?? 'Untitled';
                    final description = metric['description'] as String? ?? '';
                    final targetValue =
                        (metric['targetValue'] as num?)?.toDouble() ?? 100.0;
                    final currentValue =
                        (metric['currentValue'] as num?)?.toDouble() ?? 0.0;
                    final progress = targetValue > 0
                        ? (currentValue / targetValue).clamp(0.0, 1.0)
                        : 0.0;
                    return _CustomMetricTile(
                      title: title,
                      description: description,
                      targetValue: targetValue,
                      currentValue: currentValue,
                      progress: progress,
                      onDelete: () =>
                          widget.onMetricDeleted(metric['id'] as String),
                      onUpdateValue: (value) =>
                          widget.onMetricUpdated(metric['id'] as String, value),
                    );
                  },
                ),
              ),
          ],
        ),
      ),
    );
  }
}

class _CustomMetricTile extends StatefulWidget {
  const _CustomMetricTile({
    required this.title,
    required this.description,
    required this.targetValue,
    required this.currentValue,
    required this.progress,
    required this.onDelete,
    required this.onUpdateValue,
  });

  final String title;
  final String description;
  final double targetValue;
  final double currentValue;
  final double progress;
  final VoidCallback onDelete;
  final ValueChanged<double> onUpdateValue;

  @override
  State<_CustomMetricTile> createState() => _CustomMetricTileState();
}

class _CustomMetricTileState extends State<_CustomMetricTile> {
  bool _isEditing = false;
  late TextEditingController _valueController;

  @override
  void initState() {
    super.initState();
    _valueController =
        TextEditingController(text: widget.currentValue.toStringAsFixed(1));
  }

  @override
  void didUpdateWidget(covariant _CustomMetricTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.currentValue != widget.currentValue && !_isEditing) {
      _valueController.text = widget.currentValue.toStringAsFixed(1);
    }
  }

  @override
  void dispose() {
    _valueController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: const Color(0xFFE5E7EB)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.03),
            blurRadius: 6,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Expanded(
                child: Text(
                  widget.title,
                  style: const TextStyle(
                      fontWeight: FontWeight.w600,
                      fontSize: 15,
                      color: Color(0xFF111827)),
                ),
              ),
              IconButton(
                icon: const Icon(Icons.delete_outline,
                    size: 18, color: Color(0xFFDC2626)),
                onPressed: widget.onDelete,
                tooltip: 'Delete',
              ),
            ],
          ),
          if (widget.description.isNotEmpty) ...[
            const SizedBox(height: 4),
            Text(widget.description,
                style: const TextStyle(fontSize: 13, color: Color(0xFF6B7280))),
          ],
          const SizedBox(height: 12),
          Row(
            children: [
              Expanded(
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(6),
                  child: LinearProgressIndicator(
                    value: widget.progress,
                    backgroundColor: const Color(0xFFE5E7EB),
                    valueColor: const AlwaysStoppedAnimation(Color(0xFF2563EB)),
                    minHeight: 8,
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Text(
                '${(widget.progress * 100).toStringAsFixed(0)}%',
                style: const TextStyle(
                    fontWeight: FontWeight.w600,
                    fontSize: 13,
                    color: Color(0xFF111827)),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Row(
            children: [
              const Text('Progress:',
                  style: TextStyle(fontSize: 13, color: Color(0xFF6B7280))),
              const SizedBox(width: 8),
              if (_isEditing)
                SizedBox(
                  width: 80,
                  child: TextField(
                    controller: _valueController,
                    keyboardType:
                        const TextInputType.numberWithOptions(decimal: true),
                    autofocus: true,
                    decoration: InputDecoration(
                      isDense: true,
                      contentPadding: const EdgeInsets.symmetric(
                          horizontal: 8, vertical: 6),
                      border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(6)),
                    ),
                    onSubmitted: (value) {
                      final newValue =
                          double.tryParse(value) ?? widget.currentValue;
                      widget.onUpdateValue(newValue);
                      setState(() => _isEditing = false);
                    },
                  ),
                )
              else
                GestureDetector(
                  onTap: () => setState(() => _isEditing = true),
                  child: Container(
                    padding:
                        const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    decoration: BoxDecoration(
                      color: const Color(0xFFF3F4F6),
                      borderRadius: BorderRadius.circular(6),
                    ),
                    child: Text(
                      '${widget.currentValue.toStringAsFixed(1)} / ${widget.targetValue.toStringAsFixed(1)}',
                      style: const TextStyle(
                          fontWeight: FontWeight.w500,
                          fontSize: 13,
                          color: Color(0xFF111827)),
                    ),
                  ),
                ),
              const Spacer(),
              if (!_isEditing)
                TextButton.icon(
                  onPressed: () => setState(() => _isEditing = true),
                  icon: const Icon(Icons.edit, size: 14),
                  label: const Text('Update'),
                  style: TextButton.styleFrom(
                    foregroundColor: const Color(0xFF2563EB),
                    textStyle: const TextStyle(fontSize: 12),
                  ),
                ),
            ],
          ),
        ],
      ),
    );
  }
}

class _CoachCommitmentCard extends StatelessWidget {
  const _CoachCommitmentCard();

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.fromLTRB(28, 28, 28, 32),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: ScorecardPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Coach Feedback',
            style: TextStyle(
              color: ScorecardPage._titleColor,
              fontSize: 16,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 8),
          Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 18),
            decoration: BoxDecoration(
              color: const Color(0xFFF3F4F6),
              borderRadius: BorderRadius.circular(16),
              border: Border.all(color: ScorecardPage._borderColor),
            ),
            child: const Text(
              'Coach is yet to give feedback',
              style: TextStyle(color: ScorecardPage._mutedColor, fontSize: 14),
            ),
          ),
          const SizedBox(height: 28),
          const Text(
            "Member's Commitment",
            style: TextStyle(
              color: ScorecardPage._titleColor,
              fontSize: 16,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 12),
          TextField(
            minLines: 4,
            maxLines: 6,
            decoration: InputDecoration(
              hintText: 'Enter your commitment for the next month...',
              filled: true,
              fillColor: Colors.white,
              contentPadding:
                  const EdgeInsets.symmetric(horizontal: 20, vertical: 18),
              enabledBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(16),
                borderSide: const BorderSide(color: ScorecardPage._borderColor),
              ),
              focusedBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(16),
                borderSide: const BorderSide(
                    color: ScorecardPage._buttonBlue, width: 1.4),
              ),
            ),
          ),
          const SizedBox(height: 16),
          Align(
            alignment: Alignment.centerRight,
            child: ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: ScorecardPage._buttonBlue,
                foregroundColor: Colors.white,
                padding:
                    const EdgeInsets.symmetric(horizontal: 28, vertical: 16),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(14)),
                elevation: 0,
              ),
              onPressed: () {},
              child: const Text(
                'Save commitment',
                style: TextStyle(fontWeight: FontWeight.w600, fontSize: 15),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _ScoreMetricCard extends StatelessWidget {
  const _ScoreMetricCard({required this.data, this.onViewDetails});

  final _ScoreMetricData data;
  final ValueChanged<String>? onViewDetails;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.fromLTRB(24, 24, 24, 20),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: ScorecardPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 10,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            data.title,
            style: const TextStyle(
              color: ScorecardPage._titleColor,
              fontSize: 16,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 16),
          Container(
            width: 96,
            height: 96,
            decoration: BoxDecoration(
              color: const Color(0xFFE6F4F4),
              borderRadius: BorderRadius.circular(20),
            ),
            child: data.title == 'DeepThrive Sessions'
                ? ClipRRect(
                    borderRadius: BorderRadius.circular(20),
                    child: Image.asset(
                      'assets/images/Right_People.png',
                      width: 96,
                      height: 96,
                      fit: BoxFit.cover,
                    ),
                  )
                : data.title == 'Delegation Success'
                    ? ClipRRect(
                        borderRadius: BorderRadius.circular(20),
                        child: Image.asset(
                          'assets/images/Delegation.jpg',
                          width: 96,
                          height: 96,
                          fit: BoxFit.cover,
                        ),
                      )
                    : data.title == 'Core4 Alignment'
                        ? ClipRRect(
                            borderRadius: BorderRadius.circular(20),
                            child: Image.asset(
                              'assets/images/Core4Alignment.jpg',
                              width: 96,
                              height: 96,
                              fit: BoxFit.contain,
                            ),
                          )
                        : data.title == 'Guiding GeniusTime'
                            ? ClipRRect(
                                borderRadius: BorderRadius.circular(20),
                                child: Image.asset(
                                  'assets/images/Guiding_Genius.jpg',
                                  width: 96,
                                  height: 96,
                                  fit: BoxFit.cover,
                                ),
                              )
                            : data.title == 'Right People Right Seats'
                                ? ClipRRect(
                                    borderRadius: BorderRadius.circular(20),
                                    child: Image.asset(
                                      'assets/images/Right_People.png',
                                      width: 96,
                                      height: 96,
                                      fit: BoxFit.cover,
                                    ),
                                  )
                                : data.title == 'Blueprint Utilization'
                                    ? ClipRRect(
                                        borderRadius: BorderRadius.circular(20),
                                        child: Image.asset(
                                          'assets/images/Blueprint.jpg',
                                          width: 96,
                                          height: 96,
                                          fit: BoxFit.cover,
                                        ),
                                      )
                                    : Icon(data.icon,
                                        color: ScorecardPage._indicatorColor,
                                        size: 48),
          ),
          const SizedBox(height: 18),
          const Text(
            'Learning Consistency',
            style: TextStyle(
                color: ScorecardPage._mutedColor,
                fontSize: 13,
                fontWeight: FontWeight.w600),
          ),
          const SizedBox(height: 12),
          ClipRRect(
            borderRadius: BorderRadius.circular(8),
            child: LinearProgressIndicator(
              value: data.progress,
              minHeight: 8,
              backgroundColor: const Color(0xFFE5E7EB),
              valueColor: const AlwaysStoppedAnimation<Color>(
                  ScorecardPage._indicatorColor),
            ),
          ),
          const SizedBox(height: 18),
          Row(
            children: [
              Text(
                'Last Updated: ${data.lastUpdated}',
                style: const TextStyle(
                    color: ScorecardPage._mutedColor, fontSize: 13),
              ),
              const Spacer(),
              TextButton(
                onPressed: () => onViewDetails?.call(data.title),
                style: TextButton.styleFrom(
                  padding: EdgeInsets.zero,
                  foregroundColor: const Color(0xFF2563EB),
                  textStyle: const TextStyle(
                      fontWeight: FontWeight.w600, fontSize: 13),
                ),
                child: const Text('View Details'),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class _MetricFormChip extends StatelessWidget {
  const _MetricFormChip({required this.label});

  final String label;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      borderRadius: BorderRadius.circular(18),
      onTap: () => _showUpdateMetricDialog(context, label),
      child: Container(
        constraints: const BoxConstraints(minWidth: 220),
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 18),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(18),
          border: Border.all(color: ScorecardPage._borderColor),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withValues(alpha: 0.03),
              blurRadius: 8,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              label,
              style: const TextStyle(
                color: ScorecardPage._titleColor,
                fontSize: 15,
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 12),
            Row(
              mainAxisSize: MainAxisSize.min,
              children: const [
                Icon(Icons.edit_outlined,
                    color: ScorecardPage._mutedColor, size: 18),
                SizedBox(width: 6),
                Text(
                  'Update Metric',
                  style: TextStyle(
                      color: Color(0xFF2563EB),
                      fontSize: 13,
                      fontWeight: FontWeight.w600),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  void _showUpdateMetricDialog(BuildContext context, String metricLabel) {
    showDialog(
      context: context,
      builder: (context) => _UpdateMetricDialog(metricLabel: metricLabel),
    );
  }
}

class _UpdateMetricDialog extends StatefulWidget {
  const _UpdateMetricDialog({required this.metricLabel});

  final String metricLabel;

  @override
  State<_UpdateMetricDialog> createState() => _UpdateMetricDialogState();
}

class _UpdateMetricDialogState extends State<_UpdateMetricDialog> {
  final _formKey = GlobalKey<FormState>();
  final _valueController = TextEditingController();
  final _notesController = TextEditingController();
  DateTime _selectedDate = DateTime.now();
  String _selectedProgress = 'On Track';
  bool _isSaving = false;

  static const List<String> _progressOptions = [
    'On Track',
    'Needs Attention',
    'At Risk',
    'Exceeding',
  ];

  @override
  void dispose() {
    _valueController.dispose();
    _notesController.dispose();
    super.dispose();
  }

  Future<void> _saveMetric() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isSaving = true);

    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
              content: Text('Please sign in to update metrics'),
              backgroundColor: Colors.red),
        );
        setState(() => _isSaving = false);
        return;
      }

      await FirebaseFirestore.instance.collection('metricUpdates').add({
        'userId': user.uid,
        'userEmail': user.email,
        'metricName': widget.metricLabel,
        'value': _valueController.text.trim(),
        'progress': _selectedProgress,
        'notes': _notesController.text.trim(),
        'date': Timestamp.fromDate(_selectedDate),
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      });

      debugPrint('[_UpdateMetricDialog] Metric saved: ${widget.metricLabel}');

      // Create notification for scorecard submission
      await NotificationService.notifyScorecardSubmission(
        recipientId: user.uid,
        metricName: widget.metricLabel,
      );

      if (mounted) {
        Navigator.of(context).pop();
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${widget.metricLabel} updated successfully'),
            backgroundColor: const Color(0xFF22C55E),
          ),
        );
      }
    } catch (e) {
      debugPrint('[_UpdateMetricDialog] Error saving metric: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text('Error updating metric: $e'),
              backgroundColor: Colors.red),
        );
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  Future<void> _pickDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2020),
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );
    if (picked != null) setState(() => _selectedDate = picked);
  }

  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;
    final dialogWidth = screenWidth < 500 ? screenWidth * 0.95 : 480.0;

    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
      child: Container(
        width: dialogWidth,
        constraints: const BoxConstraints(maxHeight: 620),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(24),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withValues(alpha: 0.1),
              blurRadius: 24,
              offset: const Offset(0, 8),
            ),
          ],
        ),
        child: SingleChildScrollView(
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // Header
                Container(
                  padding: const EdgeInsets.all(24),
                  decoration: BoxDecoration(
                    gradient: const LinearGradient(
                      colors: [Color(0xFF2F55EE), Color(0xFF8B5CF6)],
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                    ),
                    borderRadius:
                        const BorderRadius.vertical(top: Radius.circular(24)),
                  ),
                  child: Row(
                    children: [
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.white.withValues(alpha: 0.2),
                          borderRadius: BorderRadius.circular(14),
                        ),
                        child: const Icon(Icons.analytics_outlined,
                            color: Colors.white, size: 24),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Text(
                              'Update Metric',
                              style: TextStyle(
                                  color: Colors.white,
                                  fontSize: 18,
                                  fontWeight: FontWeight.w700),
                            ),
                            const SizedBox(height: 4),
                            Text(
                              widget.metricLabel,
                              style: TextStyle(
                                  color: Colors.white.withValues(alpha: 0.9),
                                  fontSize: 14),
                            ),
                          ],
                        ),
                      ),
                      IconButton(
                        onPressed: () => Navigator.of(context).pop(),
                        icon: const Icon(Icons.close, color: Colors.white),
                        style: IconButton.styleFrom(
                          backgroundColor: Colors.white.withValues(alpha: 0.2),
                        ),
                      ),
                    ],
                  ),
                ),
                // Form Content
                Padding(
                  padding: const EdgeInsets.all(24),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Date Picker
                      const Text(
                        'Date',
                        style: TextStyle(
                            color: Color(0xFF0F172A),
                            fontSize: 14,
                            fontWeight: FontWeight.w600),
                      ),
                      const SizedBox(height: 8),
                      InkWell(
                        borderRadius: BorderRadius.circular(12),
                        onTap: _pickDate,
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 16, vertical: 14),
                          decoration: BoxDecoration(
                            border: Border.all(color: const Color(0xFFE2E8F0)),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Row(
                            children: [
                              const Icon(Icons.calendar_today_outlined,
                                  color: Color(0xFF6B7280), size: 20),
                              const SizedBox(width: 12),
                              Text(
                                '${_selectedDate.day}/${_selectedDate.month}/${_selectedDate.year}',
                                style: const TextStyle(
                                    color: Color(0xFF0F172A), fontSize: 15),
                              ),
                              const Spacer(),
                              const Icon(Icons.keyboard_arrow_down,
                                  color: Color(0xFF6B7280)),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 20),
                      // Metric Value
                      const Text(
                        'Metric Value',
                        style: TextStyle(
                            color: Color(0xFF0F172A),
                            fontSize: 14,
                            fontWeight: FontWeight.w600),
                      ),
                      const SizedBox(height: 8),
                      TextFormField(
                        controller: _valueController,
                        keyboardType: TextInputType.text,
                        decoration: InputDecoration(
                          hintText:
                              'Enter value (e.g., 85%, 4 hours, 10 sessions)',
                          hintStyle: const TextStyle(color: Color(0xFF9CA3AF)),
                          filled: true,
                          fillColor: Colors.white,
                          contentPadding: const EdgeInsets.symmetric(
                              horizontal: 16, vertical: 14),
                          enabledBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(12),
                            borderSide:
                                const BorderSide(color: Color(0xFFE2E8F0)),
                          ),
                          focusedBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(12),
                            borderSide: const BorderSide(
                                color: Color(0xFF2563EB), width: 1.5),
                          ),
                          errorBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(12),
                            borderSide: const BorderSide(color: Colors.red),
                          ),
                          focusedErrorBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(12),
                            borderSide:
                                const BorderSide(color: Colors.red, width: 1.5),
                          ),
                        ),
                        validator: (v) => (v == null || v.trim().isEmpty)
                            ? 'Please enter a value'
                            : null,
                      ),
                      const SizedBox(height: 20),
                      // Progress Status
                      const Text(
                        'Progress Status',
                        style: TextStyle(
                            color: Color(0xFF0F172A),
                            fontSize: 14,
                            fontWeight: FontWeight.w600),
                      ),
                      const SizedBox(height: 8),
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 16),
                        decoration: BoxDecoration(
                          border: Border.all(color: const Color(0xFFE2E8F0)),
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: DropdownButtonHideUnderline(
                          child: DropdownButton<String>(
                            value: _selectedProgress,
                            isExpanded: true,
                            icon: const Icon(Icons.keyboard_arrow_down,
                                color: Color(0xFF6B7280)),
                            items: _progressOptions
                                .map((p) =>
                                    DropdownMenuItem(value: p, child: Text(p)))
                                .toList(),
                            onChanged: (v) {
                              if (v != null) {
                                setState(() => _selectedProgress = v);
                              }
                            },
                          ),
                        ),
                      ),
                      const SizedBox(height: 20),
                      // Notes
                      const Text(
                        'Notes (Optional)',
                        style: TextStyle(
                            color: Color(0xFF0F172A),
                            fontSize: 14,
                            fontWeight: FontWeight.w600),
                      ),
                      const SizedBox(height: 8),
                      TextFormField(
                        controller: _notesController,
                        maxLines: 3,
                        decoration: InputDecoration(
                          hintText: 'Add any additional notes or context...',
                          hintStyle: const TextStyle(color: Color(0xFF9CA3AF)),
                          filled: true,
                          fillColor: Colors.white,
                          contentPadding: const EdgeInsets.symmetric(
                              horizontal: 16, vertical: 14),
                          enabledBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(12),
                            borderSide:
                                const BorderSide(color: Color(0xFFE2E8F0)),
                          ),
                          focusedBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(12),
                            borderSide: const BorderSide(
                                color: Color(0xFF2563EB), width: 1.5),
                          ),
                        ),
                      ),
                      const SizedBox(height: 28),
                      // Actions
                      Row(
                        children: [
                          Expanded(
                            child: OutlinedButton(
                              onPressed: () => Navigator.of(context).pop(),
                              style: OutlinedButton.styleFrom(
                                padding:
                                    const EdgeInsets.symmetric(vertical: 14),
                                side:
                                    const BorderSide(color: Color(0xFFE2E8F0)),
                                shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(12)),
                              ),
                              child: const Text(
                                'Cancel',
                                style: TextStyle(
                                    color: Color(0xFF6B7280),
                                    fontWeight: FontWeight.w600),
                              ),
                            ),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: ElevatedButton(
                              onPressed: _isSaving ? null : _saveMetric,
                              style: ElevatedButton.styleFrom(
                                backgroundColor: const Color(0xFF2563EB),
                                foregroundColor: Colors.white,
                                padding:
                                    const EdgeInsets.symmetric(vertical: 14),
                                shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(12)),
                                elevation: 0,
                              ),
                              child: _isSaving
                                  ? const SizedBox(
                                      width: 20,
                                      height: 20,
                                      child: CircularProgressIndicator(
                                        strokeWidth: 2,
                                        valueColor:
                                            AlwaysStoppedAnimation<Color>(
                                                Colors.white),
                                      ),
                                    )
                                  : const Text(
                                      'Save Update',
                                      style: TextStyle(
                                          fontWeight: FontWeight.w600),
                                    ),
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class ScoreMetricDetailsPage extends StatefulWidget {
  const ScoreMetricDetailsPage(
      {super.key, required this.metricTitle, required this.onBack});

  final String metricTitle;
  final VoidCallback onBack;

  @override
  State<ScoreMetricDetailsPage> createState() => _ScoreMetricDetailsPageState();
}

class _ScoreMetricDetailsPageState extends State<ScoreMetricDetailsPage> {
  static const Color _heroGradientStart = Color(0xFF2F55EE);
  static const Color _heroGradientEnd = Color(0xFF8B5CF6);
  static const Color _heroAccent = Color(0xFF22C55E);
  static const Color _heroOverlay = Color(0x332F55EE);
  static const Color _sectionTitleColor = Color(0xFF0F172A);
  static const Color _sectionMutedColor = Color(0xFF6B7280);
  static const Color _cardShadowColor = Color(0x140F172A);
  static const Color _insightCardBackground = Color(0xFFF8FAFF);
  static const Color _chipBorderColor = Color(0xFFE2E8F0);
  static const Color _surfaceGradientStart = Color(0xFFF2F6FF);
  static const Color _surfaceGradientEnd = Color(0xFFFFF6F0);
  static const Color _surfaceBorderColor = Color(0xFFDCE4FF);
  static const Color _pillHighlight = Color(0xFF2563EB);
  static const Color _mutedOnSurface = Color(0xFF5F6C80);
  static const Color _glowShadow = Color(0x332F55EE);

  final _formKey = GlobalKey<FormState>();
  DateTime? _date;
  String _focusArea = 'none';
  String _valueGenerated = 'Select...';
  String _note = '';
  int _weeklyGoalHours = 0;
  int _achievementPct = 0;
  String _mostValuable = '';
  String _envImprovements = '';
  double _durationHours = 0.0;
  String? _userDisplayName;

  // Delegation Success specific fields
  final List<_DelegationEntry> _delegationEntries = [_DelegationEntry()];
  int _delegationWeeklyGoal = 0;
  int _delegationAchievement = 0;
  String _highValueOpportunities = '';

  // Core4 Alignment specific fields
  DateTime? _core4AssessmentDate;
  int _core4Score = 0;
  String _core4ChangeFromPrevious = 'Select...';
  String _core4KeyInsights = '';
  String _core4WeeklyGoal = '';
  String _core4StrongestAlignment = '';
  String _core4AreasForGrowth = '';

  // Blueprint Utilization specific fields
  int _blueprintWeek = 1;
  String _blueprintIssueOpportunity = '';
  String _blueprintToolUsed = '';
  String _blueprintOutcome = '';
  int _blueprintMonthlyUtilization = 0;
  int _blueprintEffectivenessRating = 0;
  String _blueprintMostValuableApplication = '';

  // Right People Right Seats specific fields
  final List<_RightPeopleRightSeatsEntry> _rightPeopleEntries = [
    _RightPeopleRightSeatsEntry()
  ];
  String _requirementDevelopmentPriorities = '';

  // Guiding GeniusTime specific fields
  final List<_GeniusTimeEntry> _geniusTimeEntries = [_GeniusTimeEntry()];
  double _geniusTimeMonthlyAverage = 0;
  double _geniusTimeTargetPercent = 0;
  double _geniusTimeActualPercent = 0;
  String _geniusActivitiesIdentified = '';
  String _geniusTimeStrategies = '';

  @override
  void initState() {
    super.initState();
    _loadUserDisplayName();
  }

  Future<void> _loadUserDisplayName() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return;

    try {
      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .get();
      if (userDoc.exists) {
        final data = userDoc.data();
        if (data != null) {
          // Prioritize first name + last name over display_name
          final firstName = data['first_name'] as String? ??
              data['firstName'] as String? ??
              '';
          final lastName =
              data['last_name'] as String? ?? data['lastName'] as String? ?? '';
          final fullName = '$firstName $lastName'.trim();
          // Only fall back to display_name if first/last name are not available
          final displayName = data['display_name'] as String? ??
              data['displayName'] as String? ??
              '';
          final name = fullName.isNotEmpty ? fullName : displayName;
          if (mounted) {
            setState(() {
              _userDisplayName = name.isNotEmpty
                  ? name
                  : user.email?.split('@').first ?? 'User';
            });
          }
        }
      }
    } catch (e) {
      debugPrint('Error loading user display name: $e');
    }
  }

  String get _headingNumberedTitle {
    final number = ScorecardPage.metricNumberForTitle(widget.metricTitle);
    final upper = widget.metricTitle.toUpperCase();
    return '$number. $upper';
  }

  String get _metricDescription =>
      ScorecardPage.metricDescriptionForTitle(widget.metricTitle);

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final double maxWidth = constraints.maxWidth;

        double resolveHorizontalPadding() {
          if (maxWidth >= 1440) return 72;
          if (maxWidth >= 1180) return 56;
          if (maxWidth >= 960) return 40;
          if (maxWidth >= 720) return 28;
          return 20;
        }

        final double horizontalPadding = resolveHorizontalPadding();
        final bool wrapActions = maxWidth < 1100;
        final bool stackActions = maxWidth < 640;

        final backButton = TextButton.icon(
          onPressed: widget.onBack,
          icon: const Icon(Icons.chevron_left),
          label: const Text(
            'Back to scorecard',
            style: TextStyle(
              color: ScorecardPage._titleColor,
              fontWeight: FontWeight.w600,
            ),
          ),
          style: TextButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
            foregroundColor: ScorecardPage._titleColor,
            textStyle: const TextStyle(fontWeight: FontWeight.w600),
          ),
        );

        final previousButton = OutlinedButton.icon(
          onPressed: _openPreviousScorecards,
          icon: const Icon(Icons.history_toggle_off_outlined),
          label: const Text(
            'Previous Score Cards',
            style: TextStyle(fontWeight: FontWeight.w600),
          ),
          style: OutlinedButton.styleFrom(
            side: const BorderSide(color: ScorecardPage._borderColor),
            foregroundColor: ScorecardPage._buttonBlue,
            padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );

        final printButton = OutlinedButton.icon(
          onPressed: _downloadScorecardAsPdf,
          icon: const Icon(Icons.download, color: ScorecardPage._titleColor),
          label: const Text(
            'Download PDF',
            style: TextStyle(
                color: ScorecardPage._titleColor, fontWeight: FontWeight.w600),
          ),
          style: OutlinedButton.styleFrom(
            side: const BorderSide(color: ScorecardPage._borderColor),
            foregroundColor: ScorecardPage._titleColor,
            padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );

        final saveButton = ElevatedButton.icon(
          onPressed: _saveFormToFirestore,
          icon: const Icon(Icons.save_alt),
          label: const Text('Save Form'),
          style: ElevatedButton.styleFrom(
            backgroundColor: ScorecardPage._buttonBlue,
            foregroundColor: Colors.white,
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 14),
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
            elevation: 0,
          ),
        );

        Widget stretchIfNeeded(Widget child) => stackActions
            ? SizedBox(width: double.infinity, child: child)
            : child;

        final Widget actionsBar;
        if (stackActions) {
          actionsBar = Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Align(alignment: Alignment.centerLeft, child: backButton),
              const SizedBox(height: 16),
              stretchIfNeeded(previousButton),
              const SizedBox(height: 12),
              stretchIfNeeded(printButton),
              const SizedBox(height: 12),
              stretchIfNeeded(saveButton),
            ],
          );
        } else if (wrapActions) {
          actionsBar = Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              backButton,
              const SizedBox(height: 12),
              Wrap(
                spacing: 12,
                runSpacing: 12,
                children: [
                  previousButton,
                  printButton,
                  saveButton,
                ],
              ),
            ],
          );
        } else {
          actionsBar = Row(
            children: [
              backButton,
              const Spacer(),
              previousButton,
              const SizedBox(width: 12),
              printButton,
              const SizedBox(width: 12),
              saveButton,
            ],
          );
        }

        return SingleChildScrollView(
          padding: EdgeInsets.fromLTRB(
            horizontalPadding,
            stackActions ? 24 : 32,
            horizontalPadding,
            stackActions ? 40 : 56,
          ),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                actionsBar,
                const SizedBox(height: 24),
                _buildHeroSection(maxWidth),
                const SizedBox(height: 28),
                _buildFormCard(maxWidth),
                const SizedBox(height: 32),
                _buildGuidancePanel(),
              ],
            ),
          ),
        );
      },
    );
  }

  void _openPreviousScorecards() {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      if (!mounted) return;
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          const SnackBar(
            content: Text('Please sign in to view your previous score cards.'),
          ),
        );
      return;
    }

    showDialog<void>(
      context: context,
      barrierColor: Colors.black.withOpacity(0.45),
      builder: (_) => PreviousScorecardsDialog(
        metricTitle: widget.metricTitle,
        uid: user.uid,
        userEmail: user.email,
      ),
    );
  }

  Future<void> _saveFormToFirestore() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      if (!mounted) return;
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          const SnackBar(
            content: Text('Please sign in to save your score card.'),
          ),
        );
      return;
    }

    if (_formKey.currentState?.validate() ?? false) {
      _formKey.currentState?.save();

      try {
        final firestore = FirebaseFirestore.instance;
        final userRef = firestore.collection('users').doc(user.uid);

        Map<String, dynamic> data;

        // Handle Delegation Success form differently
        if (widget.metricTitle == 'Delegation Success') {
          final int totalTimeSaved =
              _delegationEntries.fold(0, (sum, e) => sum + e.timeSavedMinutes);
          data = {
            'user_ref': userRef,
            'user_email': user.email,
            'metric_title': widget.metricTitle,
            'delegation_entries':
                _delegationEntries.map((e) => e.toMap()).toList(),
            'total_time_saved_minutes': totalTimeSaved,
            'weekly_goal_percentage': _delegationWeeklyGoal,
            'achievement_scale': _delegationAchievement,
            'high_value_opportunities': _highValueOpportunities.isNotEmpty
                ? _highValueOpportunities
                : null,
            'submitted_at': FieldValue.serverTimestamp(),
            'status': 'submitted',
          };
        } else if (widget.metricTitle == 'Core4 Alignment') {
          // Handle Core4 Alignment form
          data = {
            'user_ref': userRef,
            'user_email': user.email,
            'metric_title': widget.metricTitle,
            'assessment_date': _core4AssessmentDate != null
                ? Timestamp.fromDate(_core4AssessmentDate!)
                : FieldValue.serverTimestamp(),
            'score': _core4Score,
            'change_from_previous': _core4ChangeFromPrevious != 'Select...'
                ? _core4ChangeFromPrevious
                : null,
            'key_insights':
                _core4KeyInsights.isNotEmpty ? _core4KeyInsights : null,
            'weekly_goal':
                _core4WeeklyGoal.isNotEmpty ? _core4WeeklyGoal : null,
            'strongest_alignment_areas': _core4StrongestAlignment.isNotEmpty
                ? _core4StrongestAlignment
                : null,
            'areas_for_growth':
                _core4AreasForGrowth.isNotEmpty ? _core4AreasForGrowth : null,
            'submitted_at': FieldValue.serverTimestamp(),
            'status': 'submitted',
          };
        } else if (widget.metricTitle == 'Blueprint Utilization') {
          // Handle Blueprint Utilization form
          data = {
            'user_ref': userRef,
            'user_email': user.email,
            'metric_title': widget.metricTitle,
            'week': _blueprintWeek,
            'issue_opportunity': _blueprintIssueOpportunity.isNotEmpty
                ? _blueprintIssueOpportunity
                : null,
            'blueprint_tool_used':
                _blueprintToolUsed.isNotEmpty ? _blueprintToolUsed : null,
            'outcome': _blueprintOutcome.isNotEmpty ? _blueprintOutcome : null,
            'monthly_utilization': _blueprintMonthlyUtilization,
            'effectiveness_rating': _blueprintEffectivenessRating,
            'most_valuable_application':
                _blueprintMostValuableApplication.isNotEmpty
                    ? _blueprintMostValuableApplication
                    : null,
            'submitted_at': FieldValue.serverTimestamp(),
            'status': 'submitted',
          };
        } else if (widget.metricTitle == 'Right People Right Seats') {
          // Handle Right People Right Seats form
          data = {
            'user_ref': userRef,
            'user_email': user.email,
            'metric_title': widget.metricTitle,
            'team_members': _rightPeopleEntries.map((e) => e.toMap()).toList(),
            'genius_activities_identified':
                _geniusActivitiesIdentified.isNotEmpty
                    ? _geniusActivitiesIdentified
                    : null,
            'requirement_development_priorities':
                _requirementDevelopmentPriorities.isNotEmpty
                    ? _requirementDevelopmentPriorities
                    : null,
            'submitted_at': FieldValue.serverTimestamp(),
            'status': 'submitted',
          };
        } else if (widget.metricTitle == 'Guiding GeniusTime') {
          // Handle Guiding GeniusTime form
          data = {
            'user_ref': userRef,
            'user_email': user.email,
            'metric_title': widget.metricTitle,
            'weekly_entries': _geniusTimeEntries.map((e) => e.toMap()).toList(),
            'monthly_average_hours_per_week': _geniusTimeMonthlyAverage,
            'target_percent': _geniusTimeTargetPercent,
            'actual_percent': _geniusTimeActualPercent,
            'genius_activities_identified':
                _geniusActivitiesIdentified.isNotEmpty
                    ? _geniusActivitiesIdentified
                    : null,
            'strategies_to_increase':
                _geniusTimeStrategies.isNotEmpty ? _geniusTimeStrategies : null,
            'submitted_at': FieldValue.serverTimestamp(),
            'status': 'submitted',
          };
        } else {
          data = {
            'user_ref': userRef,
            'user_email': user.email,
            'metric_title': widget.metricTitle,
            'date': _date != null
                ? Timestamp.fromDate(_date!)
                : FieldValue.serverTimestamp(),
            'focus_area': _focusArea != 'none' ? _focusArea : null,
            'duration_hours': _durationHours,
            'value_generated':
                _valueGenerated != 'Select...' ? _valueGenerated : null,
            'notes': _note.isNotEmpty ? _note : null,
            'weekly_goal_hours': _weeklyGoalHours,
            'achievement_percentage': _achievementPct,
            'most_valuable_activity':
                _mostValuable.isNotEmpty ? _mostValuable : null,
            'environment_improvements':
                _envImprovements.isNotEmpty ? _envImprovements : null,
            'submitted_at': FieldValue.serverTimestamp(),
            'status': 'submitted',
          };
        }

        await firestore.collection('scorecards').add(data);

        if (!mounted) return;
        ScaffoldMessenger.of(context)
          ..hideCurrentSnackBar()
          ..showSnackBar(
            const SnackBar(
              content: Text('‚úì Scorecard saved successfully!'),
              backgroundColor: Color(0xFF22C55E),
            ),
          );
      } catch (e) {
        if (!mounted) return;
        ScaffoldMessenger.of(context)
          ..hideCurrentSnackBar()
          ..showSnackBar(
            SnackBar(
              content: Text('Error saving scorecard: ${e.toString()}'),
              backgroundColor: Colors.red,
            ),
          );
      }
    }
  }

  Future<void> _downloadScorecardAsPdf() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      if (!mounted) return;
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          const SnackBar(
            content: Text('Please sign in to download the scorecard.'),
          ),
        );
      return;
    }

    // Save form data first
    _formKey.currentState?.save();

    try {
      final pdf = pw.Document();

      final metricNumber =
          ScorecardPage.metricNumberForTitle(widget.metricTitle);
      final metricUpper = widget.metricTitle.toUpperCase();
      final metricDescription =
          ScorecardPage.metricDescriptionForTitle(widget.metricTitle);

      pdf.addPage(
        pw.Page(
          pageFormat: PdfPageFormat.a4,
          margin: const pw.EdgeInsets.all(40),
          build: (pw.Context context) {
            return pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                // Header
                pw.Container(
                  padding: const pw.EdgeInsets.all(24),
                  decoration: pw.BoxDecoration(
                    color: PdfColor.fromHex('#2F55EE'),
                    borderRadius: pw.BorderRadius.circular(16),
                  ),
                  child: pw.Column(
                    crossAxisAlignment: pw.CrossAxisAlignment.start,
                    children: [
                      pw.Text(
                        '$metricNumber. $metricUpper',
                        style: pw.TextStyle(
                          color: PdfColors.white,
                          fontSize: 24,
                          fontWeight: pw.FontWeight.bold,
                        ),
                      ),
                      pw.SizedBox(height: 8),
                      pw.Text(
                        metricDescription,
                        style: const pw.TextStyle(
                          color: PdfColors.white,
                          fontSize: 14,
                        ),
                      ),
                      pw.SizedBox(height: 12),
                      pw.Row(
                        children: [
                          pw.Text(
                            'Submitted by: ${_userDisplayName ?? user.email ?? "Unknown"}',
                            style: const pw.TextStyle(
                              color: PdfColors.white,
                              fontSize: 12,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                pw.SizedBox(height: 24),

                // Form Details
                pw.Text(
                  'Form Details',
                  style: pw.TextStyle(
                    fontSize: 18,
                    fontWeight: pw.FontWeight.bold,
                    color: PdfColor.fromHex('#0F172A'),
                  ),
                ),
                pw.SizedBox(height: 16),

                // Date, Focus Area, Duration, Value Generated
                pw.Row(
                  mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                  children: [
                    _buildPdfField(
                        'Date',
                        _date != null
                            ? '${_date!.month.toString().padLeft(2, '0')}/${_date!.day.toString().padLeft(2, '0')}/${_date!.year}'
                            : 'Not set'),
                    _buildPdfField('Focus Area',
                        _focusArea != 'none' ? _focusArea : 'Not set'),
                  ],
                ),
                pw.SizedBox(height: 12),
                pw.Row(
                  mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                  children: [
                    _buildPdfField('Duration',
                        _durationHours > 0 ? '$_durationHours hrs' : 'Not set'),
                    _buildPdfField(
                        'Value Generated',
                        _valueGenerated != 'Select...'
                            ? _valueGenerated
                            : 'Not set'),
                  ],
                ),
                pw.SizedBox(height: 16),

                // Notes
                if (_note.isNotEmpty) ...[
                  _buildPdfFieldLarge('Notes', _note),
                  pw.SizedBox(height: 16),
                ],

                // Weekly Goal & Achievement
                pw.Row(
                  mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                  children: [
                    _buildPdfField('Weekly Goal', '$_weeklyGoalHours Hours'),
                    _buildPdfField('Achievement', '$_achievementPct% of Goal'),
                  ],
                ),
                pw.SizedBox(height: 16),

                // Most Valuable Activity
                if (_mostValuable.isNotEmpty) ...[
                  _buildPdfFieldLarge('Most Valuable Activity', _mostValuable),
                  pw.SizedBox(height: 16),
                ],

                // Environment Improvements
                if (_envImprovements.isNotEmpty) ...[
                  _buildPdfFieldLarge(
                      'Environment Improvements', _envImprovements),
                ],

                pw.Spacer(),

                // Footer
                pw.Divider(color: PdfColor.fromHex('#E2E8F0')),
                pw.SizedBox(height: 8),
                pw.Text(
                  'Generated on ${DateTime.now().toString().split('.')[0]}',
                  style: pw.TextStyle(
                    fontSize: 10,
                    color: PdfColor.fromHex('#6B7280'),
                  ),
                ),
              ],
            );
          },
        ),
      );

      // Download the PDF
      final bytes = await pdf.save();
      final fileName =
          'Scorecard_${widget.metricTitle.replaceAll(' ', '_')}_${DateTime.now().millisecondsSinceEpoch}.pdf';

      // Web-compatible download using universal_html
      if (kIsWeb) {
        final blob = html.Blob([bytes], 'application/pdf');
        final url = html.Url.createObjectUrlFromBlob(blob);
        final anchor = html.AnchorElement(href: url)
          ..setAttribute('download', fileName)
          ..click();
        html.Url.revokeObjectUrl(url);
      } else {
        // For mobile platforms
        await Printing.sharePdf(bytes: bytes, filename: fileName);
      }

      if (!mounted) return;
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          const SnackBar(
            content: Text('‚úì PDF downloaded successfully!'),
            backgroundColor: Color(0xFF22C55E),
          ),
        );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar()
        ..showSnackBar(
          SnackBar(
            content: Text('Error generating PDF: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
    }
  }

  pw.Widget _buildPdfField(String label, String value) {
    return pw.Expanded(
      child: pw.Container(
        padding: const pw.EdgeInsets.all(12),
        decoration: pw.BoxDecoration(
          border: pw.Border.all(color: PdfColor.fromHex('#E2E8F0')),
          borderRadius: pw.BorderRadius.circular(8),
        ),
        child: pw.Column(
          crossAxisAlignment: pw.CrossAxisAlignment.start,
          children: [
            pw.Text(
              label,
              style: pw.TextStyle(
                fontSize: 10,
                color: PdfColor.fromHex('#6B7280'),
                fontWeight: pw.FontWeight.bold,
              ),
            ),
            pw.SizedBox(height: 4),
            pw.Text(
              value,
              style: pw.TextStyle(
                fontSize: 12,
                color: PdfColor.fromHex('#0F172A'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  pw.Widget _buildPdfFieldLarge(String label, String value) {
    return pw.Container(
      width: double.infinity,
      padding: const pw.EdgeInsets.all(12),
      decoration: pw.BoxDecoration(
        border: pw.Border.all(color: PdfColor.fromHex('#E2E8F0')),
        borderRadius: pw.BorderRadius.circular(8),
      ),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Text(
            label,
            style: pw.TextStyle(
              fontSize: 10,
              color: PdfColor.fromHex('#6B7280'),
              fontWeight: pw.FontWeight.bold,
            ),
          ),
          pw.SizedBox(height: 4),
          pw.Text(
            value,
            style: pw.TextStyle(
              fontSize: 12,
              color: PdfColor.fromHex('#0F172A'),
            ),
          ),
        ],
      ),
    );
  }

  // Header hero for the metric details page
  Widget _buildHeroSection(double maxWidth) {
    final bool isMobile = maxWidth < 720;
    final bool isTablet = maxWidth < 1120;
    final double horizontal = isMobile
        ? 18
        : isTablet
            ? 24
            : 28;
    final double vertical = isMobile
        ? 18
        : isTablet
            ? 22
            : 24;
    final double titleFontSize = isMobile ? 18 : 20;
    final double descriptionFontSize = isMobile ? 13 : 14;

    return Container(
      width: double.infinity,
      padding: EdgeInsets.symmetric(horizontal: horizontal, vertical: vertical),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(20),
        gradient: const LinearGradient(
          colors: [_heroGradientStart, _heroGradientEnd],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        boxShadow: const [
          BoxShadow(color: _glowShadow, blurRadius: 20, offset: Offset(0, 10)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            _headingNumberedTitle,
            style: TextStyle(
              color: Colors.white,
              fontWeight: FontWeight.w800,
              fontSize: titleFontSize,
            ),
          ),
          const SizedBox(height: 10),
          Text(
            _metricDescription,
            style: TextStyle(
              color: Colors.white.withValues(alpha: 0.9),
              fontWeight: FontWeight.w600,
              fontSize: descriptionFontSize,
              height: 1.4,
            ),
          ),
          const SizedBox(height: 14),
          Wrap(
            spacing: 10,
            runSpacing: 10,
            children: const [
              _MetricPill(label: 'Score Metric', icon: Icons.bar_chart_rounded),
              _MetricPill(label: 'Weekly', icon: Icons.calendar_today_rounded),
              _MetricPill(label: 'Guidance', icon: Icons.lightbulb_outline),
            ],
          ),
        ],
      ),
    );
  }

  // Main form card composed of the small fields row, goals row, and larger notes
  Widget _buildFormCard(double maxWidth) {
    final bool isMobile = maxWidth < 720;
    final bool isTablet = maxWidth < 1024;
    final EdgeInsets padding = EdgeInsets.fromLTRB(
      isMobile
          ? 20
          : isTablet
              ? 22
              : 24,
      isMobile
          ? 20
          : isTablet
              ? 22
              : 24,
      isMobile
          ? 20
          : isTablet
              ? 22
              : 24,
      isMobile
          ? 24
          : isTablet
              ? 26
              : 28,
    );

    // Use specialized form for Delegation Success
    if (widget.metricTitle == 'Delegation Success') {
      return _buildDelegationSuccessForm(maxWidth, padding);
    }

    // Use specialized form for Core4 Alignment
    if (widget.metricTitle == 'Core4 Alignment') {
      return _buildCore4AlignmentForm(maxWidth, padding);
    }

    // Use specialized form for Blueprint Utilization
    if (widget.metricTitle == 'Blueprint Utilization') {
      return _buildBlueprintUtilizationForm(maxWidth, padding);
    }

    // Use specialized form for Right People Right Seats
    if (widget.metricTitle == 'Right People Right Seats') {
      return _buildRightPeopleRightSeatsForm(maxWidth, padding);
    }

    // Use specialized form for Guiding GeniusTime
    if (widget.metricTitle == 'Guiding GeniusTime') {
      return _buildGuidingGeniusTimeForm(maxWidth, padding);
    }

    return Container(
      width: double.infinity,
      padding: padding,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: const Border.fromBorderSide(
            BorderSide(color: ScorecardPage._borderColor)),
        boxShadow: const [
          BoxShadow(
              color: _cardShadowColor, blurRadius: 12, offset: Offset(0, 6)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Form Entry',
            style: TextStyle(
              color: ScorecardPage._titleColor,
              fontSize: 18,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 8),
          const Text(
            'Update your metric inputs and notes',
            style: TextStyle(color: ScorecardPage._mutedColor, fontSize: 14),
          ),
          const SizedBox(height: 20),
          LayoutBuilder(
            builder: (context, fieldConstraints) =>
                _buildFieldsForWidth(fieldConstraints.maxWidth),
          ),
          const SizedBox(height: 16),
          _largeField(
            'Notes',
            'none',
            (v) => _note = v?.trim() ?? '',
          ),
          const SizedBox(height: 20),
          LayoutBuilder(
            builder: (context, fieldConstraints) =>
                _weeklyGoalAndAchievement(fieldConstraints.maxWidth),
          ),
          const SizedBox(height: 20),
          _largeField(
            'Most Valuable Activity',
            'Describe the most valuable activity you focused on...',
            (v) => _mostValuable = v?.trim() ?? '',
          ),
          const SizedBox(height: 16),
          _largeField(
            'Environment Improvements',
            'What environmental changes improved your focus or output?',
            (v) => _envImprovements = v?.trim() ?? '',
          ),
        ],
      ),
    );
  }

  // Delegation Success specialized form
  Widget _buildDelegationSuccessForm(double maxWidth, EdgeInsets padding) {
    final bool isMobile = maxWidth < 720;
    final int totalTimeSaved =
        _delegationEntries.fold(0, (sum, e) => sum + e.timeSavedMinutes);

    return Container(
      width: double.infinity,
      padding: padding,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: const Border.fromBorderSide(
            BorderSide(color: ScorecardPage._borderColor)),
        boxShadow: const [
          BoxShadow(
              color: _cardShadowColor, blurRadius: 12, offset: Offset(0, 6)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header row with column labels
          if (!isMobile) _buildDelegationTableHeader(),
          // Delegation entries
          ..._delegationEntries.asMap().entries.map((entry) =>
              _buildDelegationEntryRow(entry.key, entry.value, isMobile)),
          const SizedBox(height: 20),
          // Total Time Saved display
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
            decoration: BoxDecoration(
              color: const Color(0xFFF0FDF4),
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                  color: const Color(0xFF22C55E).withValues(alpha: 0.3)),
            ),
            child: Row(
              children: [
                const Icon(Icons.access_time_filled,
                    color: Color(0xFF22C55E), size: 20),
                const SizedBox(width: 12),
                Text(
                  'Total Time saved:',
                  style: TextStyle(
                    color: _sectionTitleColor,
                    fontWeight: FontWeight.w600,
                    fontSize: 15,
                  ),
                ),
                const SizedBox(width: 8),
                Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    color: const Color(0xFF22C55E),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Text(
                    '$totalTimeSaved min',
                    style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.w700,
                      fontSize: 14,
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 24),
          // Weekly Goal and Achievement row
          LayoutBuilder(
            builder: (context, constraints) =>
                _buildDelegationGoalAndAchievement(constraints.maxWidth),
          ),
          const SizedBox(height: 24),
          // High-Value Delegation Opportunities
          _smallLabeled(
            label: 'High-Value Delegation Opportunities:',
            child: Container(
              decoration: BoxDecoration(
                color: const Color(0xFFF9FAFB),
                borderRadius: BorderRadius.circular(16),
                border: const Border.fromBorderSide(
                    BorderSide(color: ScorecardPage._borderColor)),
              ),
              child: TextFormField(
                minLines: 4,
                maxLines: 8,
                initialValue: _highValueOpportunities,
                decoration: const InputDecoration(
                  hintText:
                      'Describe high-value delegation opportunities you\'ve identified...',
                  border: InputBorder.none,
                  contentPadding:
                      EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                  hintStyle: TextStyle(color: ScorecardPage._mutedColor),
                ),
                style: const TextStyle(color: ScorecardPage._titleColor),
                onChanged: (v) => _highValueOpportunities = v,
              ),
            ),
          ),
        ],
      ),
    );
  }

  // Core4 Alignment specialized form
  Widget _buildCore4AlignmentForm(double maxWidth, EdgeInsets padding) {
    final bool isMobile = maxWidth < 720;
    final bool isTablet = maxWidth < 1024;

    return Container(
      width: double.infinity,
      padding: padding,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: const Border.fromBorderSide(
            BorderSide(color: ScorecardPage._borderColor)),
        boxShadow: const [
          BoxShadow(
              color: _cardShadowColor, blurRadius: 12, offset: Offset(0, 6)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header row with column labels for desktop/tablet
          if (!isMobile) _buildCore4TableHeader(),
          // Main form entry row
          _buildCore4EntryRow(isMobile, isTablet),
          const SizedBox(height: 28),
          // Areas of Strongest Alignment
          _buildCore4TextArea(
            label: 'Areas of Strongest Alignment:',
            hintText: 'Enter Areas of Strongest Alignment',
            value: _core4StrongestAlignment,
            onChanged: (v) => _core4StrongestAlignment = v,
            icon: Icons.star_rounded,
            iconColor: const Color(0xFF22C55E),
          ),
          const SizedBox(height: 24),
          // Areas for Growth
          _buildCore4TextArea(
            label: 'Areas for Growth:',
            hintText: 'Enter areas for growth...',
            value: _core4AreasForGrowth,
            onChanged: (v) => _core4AreasForGrowth = v,
            icon: Icons.trending_up_rounded,
            iconColor: const Color(0xFF3B82F6),
          ),
        ],
      ),
    );
  }

  // Blueprint Utilization specialized form
  Widget _buildBlueprintUtilizationForm(double maxWidth, EdgeInsets padding) {
    final bool isMobile = maxWidth < 720;

    return Container(
      width: double.infinity,
      padding: padding,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: const Border.fromBorderSide(
            BorderSide(color: ScorecardPage._borderColor)),
        boxShadow: const [
          BoxShadow(
              color: _cardShadowColor, blurRadius: 12, offset: Offset(0, 6)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Description
          const Text(
            'Using the Breakaway365 Blueprint tool for problem-solving and growth',
            style: TextStyle(color: ScorecardPage._mutedColor, fontSize: 14),
          ),
          const SizedBox(height: 20),
          // Header row with column labels for desktop/tablet
          if (!isMobile) _buildBlueprintTableHeader(),
          // Main form entry row
          _buildBlueprintEntryRow(isMobile),
          const SizedBox(height: 28),
          // Monthly Utilization and Blueprint Effectiveness Rating row
          LayoutBuilder(
            builder: (context, constraints) =>
                _buildBlueprintUtilizationAndRating(constraints.maxWidth),
          ),
          const SizedBox(height: 24),
          // Most Valuable Application
          _smallLabeled(
            label: 'Most valuable Application:',
            child: Container(
              decoration: BoxDecoration(
                color: const Color(0xFFF9FAFB),
                borderRadius: BorderRadius.circular(16),
                border: const Border.fromBorderSide(
                    BorderSide(color: ScorecardPage._borderColor)),
              ),
              child: TextFormField(
                minLines: 4,
                maxLines: 8,
                initialValue: _blueprintMostValuableApplication,
                decoration: const InputDecoration(
                  hintText: 'none',
                  border: InputBorder.none,
                  contentPadding:
                      EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                  hintStyle: TextStyle(color: ScorecardPage._mutedColor),
                ),
                style: const TextStyle(color: ScorecardPage._titleColor),
                onChanged: (v) => _blueprintMostValuableApplication = v,
              ),
            ),
          ),
        ],
      ),
    );
  }

  // Right People Right Seats specialized form
  Widget _buildRightPeopleRightSeatsForm(double maxWidth, EdgeInsets padding) {
    final bool isMobile = maxWidth < 720;

    return Container(
      width: double.infinity,
      padding: padding,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: const Border.fromBorderSide(
            BorderSide(color: ScorecardPage._borderColor)),
        boxShadow: const [
          BoxShadow(
              color: _cardShadowColor, blurRadius: 12, offset: Offset(0, 6)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Description
          const Text(
            'Evaluating team alignment, roles and responsibilities',
            style: TextStyle(color: ScorecardPage._mutedColor, fontSize: 14),
          ),
          const SizedBox(height: 20),
          // Header row with column labels for desktop/tablet
          if (!isMobile) _buildRightPeopleTableHeader(),
          // Team member entries
          ..._rightPeopleEntries.asMap().entries.map((entry) =>
              _buildRightPeopleEntryRow(entry.key, entry.value, isMobile)),
          const SizedBox(height: 16),
          // Add row button
          TextButton.icon(
            onPressed: () {
              setState(() {
                _rightPeopleEntries.add(_RightPeopleRightSeatsEntry());
              });
            },
            icon: const Icon(Icons.add_circle_outline,
                color: ScorecardPage._buttonBlue, size: 20),
            label: const Text(
              'Add Team Member',
              style: TextStyle(
                  color: ScorecardPage._buttonBlue,
                  fontWeight: FontWeight.w600),
            ),
          ),
          const SizedBox(height: 24),
          // Genius Activities Identified
          _smallLabeled(
            label: 'Genius Activities Identified:',
            child: Container(
              decoration: BoxDecoration(
                color: const Color(0xFFF9FAFB),
                borderRadius: BorderRadius.circular(16),
                border: const Border.fromBorderSide(
                    BorderSide(color: ScorecardPage._borderColor)),
              ),
              child: TextFormField(
                minLines: 3,
                maxLines: 6,
                initialValue: _geniusActivitiesIdentified,
                decoration: const InputDecoration(
                  hintText: 'none',
                  border: InputBorder.none,
                  contentPadding:
                      EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                  hintStyle: TextStyle(color: ScorecardPage._mutedColor),
                ),
                style: const TextStyle(color: ScorecardPage._titleColor),
                onChanged: (v) => _geniusActivitiesIdentified = v,
              ),
            ),
          ),
          const SizedBox(height: 20),
          // Requirement/Development Priorities
          _smallLabeled(
            label: 'Requirement/Development Priorities:',
            child: Container(
              decoration: BoxDecoration(
                color: const Color(0xFFF9FAFB),
                borderRadius: BorderRadius.circular(16),
                border: const Border.fromBorderSide(
                    BorderSide(color: ScorecardPage._borderColor)),
              ),
              child: TextFormField(
                minLines: 3,
                maxLines: 6,
                initialValue: _requirementDevelopmentPriorities,
                decoration: const InputDecoration(
                  hintText: 'none',
                  border: InputBorder.none,
                  contentPadding:
                      EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                  hintStyle: TextStyle(color: ScorecardPage._mutedColor),
                ),
                style: const TextStyle(color: ScorecardPage._titleColor),
                onChanged: (v) => _requirementDevelopmentPriorities = v,
              ),
            ),
          ),
        ],
      ),
    );
  }

  // Guiding GeniusTime specialized form
  Widget _buildGuidingGeniusTimeForm(double maxWidth, EdgeInsets padding) {
    final bool isMobile = maxWidth < 720;

    return Container(
      width: double.infinity,
      padding: padding,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: const Border.fromBorderSide(
            BorderSide(color: ScorecardPage._borderColor)),
        boxShadow: const [
          BoxShadow(
              color: _cardShadowColor, blurRadius: 12, offset: Offset(0, 6)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header row with column labels for desktop/tablet
          if (!isMobile) _buildGeniusTimeTableHeader(),
          // Weekly entries
          ..._geniusTimeEntries.asMap().entries.map((entry) =>
              _buildGeniusTimeEntryRow(entry.key, entry.value, isMobile)),
          const SizedBox(height: 16),
          // Add row button
          TextButton.icon(
            onPressed: () {
              setState(() {
                final newEntry = _GeniusTimeEntry();
                newEntry.week = _geniusTimeEntries.length + 1;
                _geniusTimeEntries.add(newEntry);
              });
            },
            icon: const Icon(Icons.add_circle_outline,
                color: ScorecardPage._buttonBlue, size: 20),
            label: const Text(
              'Add Week',
              style: TextStyle(
                  color: ScorecardPage._buttonBlue,
                  fontWeight: FontWeight.w600),
            ),
          ),
          const SizedBox(height: 24),
          // Monthly Average, Target %, Actual % row
          _buildGeniusTimeSummaryRow(isMobile),
          const SizedBox(height: 24),
          // Genius Activities Identified
          _smallLabeled(
            label: 'Genius Activities Identified:',
            child: Container(
              decoration: BoxDecoration(
                color: const Color(0xFFF9FAFB),
                borderRadius: BorderRadius.circular(16),
                border: const Border.fromBorderSide(
                    BorderSide(color: ScorecardPage._borderColor)),
              ),
              child: TextFormField(
                minLines: 3,
                maxLines: 6,
                initialValue: _geniusActivitiesIdentified,
                decoration: const InputDecoration(
                  hintText: 'none',
                  border: InputBorder.none,
                  contentPadding:
                      EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                  hintStyle: TextStyle(color: ScorecardPage._mutedColor),
                ),
                style: const TextStyle(color: ScorecardPage._titleColor),
                onChanged: (v) => _geniusActivitiesIdentified = v,
              ),
            ),
          ),
          const SizedBox(height: 20),
          // Strategies to Increase GeniusTime
          _smallLabeled(
            label: 'Strategies to IncreaseGeniusTime:',
            child: Container(
              decoration: BoxDecoration(
                color: const Color(0xFFF9FAFB),
                borderRadius: BorderRadius.circular(16),
                border: const Border.fromBorderSide(
                    BorderSide(color: ScorecardPage._borderColor)),
              ),
              child: TextFormField(
                minLines: 3,
                maxLines: 6,
                initialValue: _geniusTimeStrategies,
                decoration: const InputDecoration(
                  hintText: 'none',
                  border: InputBorder.none,
                  contentPadding:
                      EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                  hintStyle: TextStyle(color: ScorecardPage._mutedColor),
                ),
                style: const TextStyle(color: ScorecardPage._titleColor),
                onChanged: (v) => _geniusTimeStrategies = v,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildGeniusTimeTableHeader() {
    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.symmetric(vertical: 14, horizontal: 12),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            const Color(0xFFF8FAFC),
            const Color(0xFFF1F5F9),
          ],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: Row(
        children: const [
          Expanded(
            flex: 12,
            child: Text(
              'Week',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          SizedBox(width: 10),
          Expanded(
            flex: 18,
            child: Text(
              'Goal (hours)',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          SizedBox(width: 10),
          Expanded(
            flex: 18,
            child: Text(
              'Actual Hours',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          SizedBox(width: 10),
          Expanded(
            flex: 18,
            child: Text(
              '% of Work Time',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          SizedBox(width: 10),
          Expanded(
            flex: 20,
            child: Text(
              'Energy Level (1-10)',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildGeniusTimeEntryRow(
      int index, _GeniusTimeEntry entry, bool isMobile) {
    if (isMobile) {
      // Mobile: Stack fields vertically
      return Container(
        margin: const EdgeInsets.only(bottom: 16),
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: const Color(0xFFE2E8F0)),
          boxShadow: [
            BoxShadow(
                color: Colors.black.withValues(alpha: 0.03),
                blurRadius: 8,
                offset: const Offset(0, 2)),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Week ${entry.week}',
                  style: const TextStyle(
                    fontWeight: FontWeight.w700,
                    fontSize: 14,
                    color: Color(0xFF475569),
                  ),
                ),
                if (_geniusTimeEntries.length > 1)
                  IconButton(
                    onPressed: () {
                      setState(() {
                        _geniusTimeEntries.removeAt(index);
                        // Re-number weeks
                        for (int i = 0; i < _geniusTimeEntries.length; i++) {
                          _geniusTimeEntries[i].week = i + 1;
                        }
                      });
                    },
                    icon: const Icon(Icons.close, color: Colors.red, size: 20),
                    padding: EdgeInsets.zero,
                    constraints: const BoxConstraints(),
                  ),
              ],
            ),
            const SizedBox(height: 12),
            _geniusTimeMobileField(
              label: 'Goal (hours)',
              hintText: '0',
              value: entry.goalHours.toString(),
              onChanged: (v) => entry.goalHours = double.tryParse(v) ?? 0,
              isNumeric: true,
            ),
            const SizedBox(height: 12),
            _geniusTimeMobileField(
              label: 'Actual Hours',
              hintText: '0',
              value: entry.actualHours.toString(),
              onChanged: (v) => entry.actualHours = double.tryParse(v) ?? 0,
              isNumeric: true,
            ),
            const SizedBox(height: 12),
            _geniusTimeMobileField(
              label: '% of Work Time',
              hintText: '0',
              value: entry.percentOfWorkTime.toString(),
              onChanged: (v) =>
                  entry.percentOfWorkTime = double.tryParse(v) ?? 0,
              isNumeric: true,
            ),
            const SizedBox(height: 12),
            _geniusTimeMobileField(
              label: 'Energy Level (1-10)',
              hintText: '0',
              value: entry.energyLevel.toString(),
              onChanged: (v) => entry.energyLevel = int.tryParse(v) ?? 0,
              isNumeric: true,
            ),
          ],
        ),
      );
    }

    // Desktop/Tablet: Horizontal row
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 12),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Expanded(
            flex: 12,
            child: _geniusTimeCompactField(
              hintText: entry.week.toString(),
              value: entry.week.toString(),
              onChanged: (v) => entry.week = int.tryParse(v) ?? entry.week,
              isNumeric: true,
            ),
          ),
          const SizedBox(width: 10),
          Expanded(
            flex: 18,
            child: _geniusTimeCompactField(
              hintText: '0',
              value: entry.goalHours == 0 ? '' : entry.goalHours.toString(),
              onChanged: (v) => entry.goalHours = double.tryParse(v) ?? 0,
              isNumeric: true,
            ),
          ),
          const SizedBox(width: 10),
          Expanded(
            flex: 18,
            child: _geniusTimeCompactField(
              hintText: '0',
              value: entry.actualHours == 0 ? '' : entry.actualHours.toString(),
              onChanged: (v) => entry.actualHours = double.tryParse(v) ?? 0,
              isNumeric: true,
            ),
          ),
          const SizedBox(width: 10),
          Expanded(
            flex: 18,
            child: _geniusTimeCompactField(
              hintText: '0',
              value: entry.percentOfWorkTime == 0
                  ? ''
                  : entry.percentOfWorkTime.toString(),
              onChanged: (v) =>
                  entry.percentOfWorkTime = double.tryParse(v) ?? 0,
              isNumeric: true,
            ),
          ),
          const SizedBox(width: 10),
          Expanded(
            flex: 20,
            child: _geniusTimeCompactField(
              hintText: '0',
              value: entry.energyLevel == 0 ? '' : entry.energyLevel.toString(),
              onChanged: (v) => entry.energyLevel = int.tryParse(v) ?? 0,
              isNumeric: true,
            ),
          ),
          if (_geniusTimeEntries.length > 1)
            IconButton(
              onPressed: () {
                setState(() {
                  _geniusTimeEntries.removeAt(index);
                  // Re-number weeks
                  for (int i = 0; i < _geniusTimeEntries.length; i++) {
                    _geniusTimeEntries[i].week = i + 1;
                  }
                });
              },
              icon: const Icon(Icons.close, color: Colors.red, size: 18),
              padding: const EdgeInsets.only(left: 8),
              constraints: const BoxConstraints(),
            ),
        ],
      ),
    );
  }

  Widget _geniusTimeCompactField({
    required String hintText,
    required String value,
    required ValueChanged<String> onChanged,
    bool isNumeric = false,
  }) {
    return Container(
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: TextFormField(
        initialValue:
            value.isEmpty || value == '0' || value == '0.0' ? '' : value,
        keyboardType: isNumeric ? TextInputType.number : TextInputType.text,
        decoration: InputDecoration(
          hintText: hintText,
          border: InputBorder.none,
          contentPadding:
              const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
          hintStyle: const TextStyle(color: ScorecardPage._mutedColor),
        ),
        style: const TextStyle(color: ScorecardPage._titleColor, fontSize: 14),
        onChanged: onChanged,
      ),
    );
  }

  Widget _geniusTimeMobileField({
    required String label,
    required String hintText,
    required String value,
    required ValueChanged<String> onChanged,
    bool isNumeric = false,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: const TextStyle(
            fontWeight: FontWeight.w600,
            fontSize: 13,
            color: Color(0xFF475569),
          ),
        ),
        const SizedBox(height: 6),
        Container(
          decoration: BoxDecoration(
            color: const Color(0xFFF9FAFB),
            borderRadius: BorderRadius.circular(10),
            border: Border.all(color: const Color(0xFFE2E8F0)),
          ),
          child: TextFormField(
            initialValue:
                value.isEmpty || value == '0' || value == '0.0' ? '' : value,
            keyboardType: isNumeric ? TextInputType.number : TextInputType.text,
            decoration: InputDecoration(
              hintText: hintText,
              border: InputBorder.none,
              contentPadding:
                  const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
              hintStyle: const TextStyle(color: ScorecardPage._mutedColor),
            ),
            style:
                const TextStyle(color: ScorecardPage._titleColor, fontSize: 14),
            onChanged: onChanged,
          ),
        ),
      ],
    );
  }

  Widget _buildGeniusTimeSummaryRow(bool isMobile) {
    final List<double> monthlyAverageOptions = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      15,
      20,
      25,
      30
    ];
    final List<double> percentOptions = [
      0,
      5,
      10,
      15,
      20,
      25,
      30,
      35,
      40,
      45,
      50,
      55,
      60,
      65,
      70,
      75,
      80,
      85,
      90,
      95,
      100
    ];

    if (isMobile) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildGeniusTimeDropdownField(
            label: 'Monthly Average:',
            value: _geniusTimeMonthlyAverage,
            options: monthlyAverageOptions,
            suffix: 'hours/week',
            onChanged: (v) =>
                setState(() => _geniusTimeMonthlyAverage = v ?? 0),
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              Expanded(
                child: _buildGeniusTimeDropdownField(
                  label: 'Target %:',
                  value: _geniusTimeTargetPercent,
                  options: percentOptions,
                  suffix: '%',
                  onChanged: (v) =>
                      setState(() => _geniusTimeTargetPercent = v ?? 0),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: _buildGeniusTimeDropdownField(
                  label: 'Actual %:',
                  value: _geniusTimeActualPercent,
                  options: percentOptions,
                  suffix: '%',
                  onChanged: (v) =>
                      setState(() => _geniusTimeActualPercent = v ?? 0),
                ),
              ),
            ],
          ),
        ],
      );
    }

    return Row(
      children: [
        const Text(
          'Monthly Average:',
          style: TextStyle(
            fontWeight: FontWeight.w600,
            fontSize: 14,
            color: Color(0xFF475569),
          ),
        ),
        const SizedBox(width: 12),
        _buildCompactDropdown(
          value: _geniusTimeMonthlyAverage,
          options: monthlyAverageOptions,
          onChanged: (v) => setState(() => _geniusTimeMonthlyAverage = v ?? 0),
        ),
        const SizedBox(width: 8),
        const Text(
          'hours/week',
          style: TextStyle(fontSize: 13, color: Color(0xFF6B7280)),
        ),
        const Spacer(),
        const Text(
          'Target %:',
          style: TextStyle(
            fontWeight: FontWeight.w600,
            fontSize: 14,
            color: Color(0xFF475569),
          ),
        ),
        const SizedBox(width: 12),
        _buildCompactDropdown(
          value: _geniusTimeTargetPercent,
          options: percentOptions,
          onChanged: (v) => setState(() => _geniusTimeTargetPercent = v ?? 0),
        ),
        const SizedBox(width: 8),
        const Text(
          '%',
          style: TextStyle(fontSize: 13, color: Color(0xFF6B7280)),
        ),
        const SizedBox(width: 24),
        const Text(
          'Actual %:',
          style: TextStyle(
            fontWeight: FontWeight.w600,
            fontSize: 14,
            color: Color(0xFF475569),
          ),
        ),
        const SizedBox(width: 12),
        _buildCompactDropdown(
          value: _geniusTimeActualPercent,
          options: percentOptions,
          onChanged: (v) => setState(() => _geniusTimeActualPercent = v ?? 0),
        ),
        const SizedBox(width: 8),
        const Text(
          '%',
          style: TextStyle(fontSize: 13, color: Color(0xFF6B7280)),
        ),
      ],
    );
  }

  Widget _buildCompactDropdown({
    required double value,
    required List<double> options,
    required ValueChanged<double?> onChanged,
  }) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: DropdownButton<double>(
        value: options.contains(value) ? value : options.first,
        underline: const SizedBox.shrink(),
        isDense: true,
        style: const TextStyle(
          fontSize: 14,
          color: ScorecardPage._titleColor,
        ),
        items: options
            .map((opt) => DropdownMenuItem<double>(
                  value: opt,
                  child: Text(
                      opt % 1 == 0 ? opt.toInt().toString() : opt.toString()),
                ))
            .toList(),
        onChanged: onChanged,
      ),
    );
  }

  Widget _buildGeniusTimeDropdownField({
    required String label,
    required double value,
    required List<double> options,
    required String suffix,
    required ValueChanged<double?> onChanged,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: const TextStyle(
            fontWeight: FontWeight.w600,
            fontSize: 13,
            color: Color(0xFF475569),
          ),
        ),
        const SizedBox(height: 6),
        Row(
          children: [
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 12),
              decoration: BoxDecoration(
                color: const Color(0xFFF9FAFB),
                borderRadius: BorderRadius.circular(10),
                border: Border.all(color: const Color(0xFFE2E8F0)),
              ),
              child: DropdownButton<double>(
                value: options.contains(value) ? value : options.first,
                underline: const SizedBox.shrink(),
                style: const TextStyle(
                  fontSize: 14,
                  color: ScorecardPage._titleColor,
                ),
                items: options
                    .map((opt) => DropdownMenuItem<double>(
                          value: opt,
                          child: Text(opt % 1 == 0
                              ? opt.toInt().toString()
                              : opt.toString()),
                        ))
                    .toList(),
                onChanged: onChanged,
              ),
            ),
            const SizedBox(width: 8),
            Text(
              suffix,
              style: const TextStyle(fontSize: 13, color: Color(0xFF6B7280)),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildRightPeopleTableHeader() {
    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.symmetric(vertical: 14, horizontal: 12),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            const Color(0xFFF8FAFC),
            const Color(0xFFF1F5F9),
          ],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: Row(
        children: const [
          Expanded(
            flex: 20,
            child: Text(
              'Team Member',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          SizedBox(width: 10),
          Expanded(
            flex: 20,
            child: Text(
              'Current Role',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          SizedBox(width: 10),
          Expanded(
            flex: 15,
            child: Text(
              'Right Person?',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          SizedBox(width: 10),
          Expanded(
            flex: 15,
            child: Text(
              'Right Seat?',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          SizedBox(width: 10),
          Expanded(
            flex: 20,
            child: Text(
              'Action Needed',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildRightPeopleEntryRow(
      int index, _RightPeopleRightSeatsEntry entry, bool isMobile) {
    if (isMobile) {
      // Mobile: Stack fields vertically
      return Container(
        margin: const EdgeInsets.only(bottom: 16),
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: const Color(0xFFE2E8F0)),
          boxShadow: [
            BoxShadow(
                color: Colors.black.withValues(alpha: 0.03),
                blurRadius: 8,
                offset: const Offset(0, 2)),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Team Member ${index + 1}',
                  style: const TextStyle(
                    fontWeight: FontWeight.w700,
                    fontSize: 14,
                    color: Color(0xFF475569),
                  ),
                ),
                if (_rightPeopleEntries.length > 1)
                  IconButton(
                    onPressed: () {
                      setState(() {
                        _rightPeopleEntries.removeAt(index);
                      });
                    },
                    icon: const Icon(Icons.close, color: Colors.red, size: 20),
                    padding: EdgeInsets.zero,
                    constraints: const BoxConstraints(),
                  ),
              ],
            ),
            const SizedBox(height: 12),
            _rightPeopleMobileField(
              label: 'Team Member',
              icon: Icons.person_outline,
              hintText: 'none',
              value: entry.teamMember,
              onChanged: (v) => entry.teamMember = v,
            ),
            const SizedBox(height: 12),
            _rightPeopleMobileField(
              label: 'Current Role',
              icon: Icons.work_outline,
              hintText: 'none',
              value: entry.currentRole,
              onChanged: (v) => entry.currentRole = v,
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: _rightPeopleCheckboxField(
                    label: 'Right Person?',
                    value: entry.rightPerson,
                    onChanged: (v) {
                      setState(() {
                        entry.rightPerson = v ?? false;
                      });
                    },
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: _rightPeopleCheckboxField(
                    label: 'Right Seat?',
                    value: entry.rightSeat,
                    onChanged: (v) {
                      setState(() {
                        entry.rightSeat = v ?? false;
                      });
                    },
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            _rightPeopleMobileField(
              label: 'Action Needed',
              icon: Icons.task_alt_outlined,
              hintText: 'none',
              value: entry.actionNeeded,
              onChanged: (v) => entry.actionNeeded = v,
            ),
          ],
        ),
      );
    }

    // Desktop/Tablet: Horizontal row
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 12),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Expanded(
            flex: 20,
            child: _rightPeopleCompactField(
              hintText: 'none',
              value: entry.teamMember,
              onChanged: (v) => entry.teamMember = v,
            ),
          ),
          const SizedBox(width: 10),
          Expanded(
            flex: 20,
            child: _rightPeopleCompactField(
              hintText: 'none',
              value: entry.currentRole,
              onChanged: (v) => entry.currentRole = v,
            ),
          ),
          const SizedBox(width: 10),
          Expanded(
            flex: 15,
            child: _rightPeopleCheckboxCompact(
              value: entry.rightPerson,
              onChanged: (v) {
                setState(() {
                  entry.rightPerson = v ?? false;
                });
              },
            ),
          ),
          const SizedBox(width: 10),
          Expanded(
            flex: 15,
            child: _rightPeopleCheckboxCompact(
              value: entry.rightSeat,
              onChanged: (v) {
                setState(() {
                  entry.rightSeat = v ?? false;
                });
              },
            ),
          ),
          const SizedBox(width: 10),
          Expanded(
            flex: 20,
            child: _rightPeopleCompactField(
              hintText: 'none',
              value: entry.actionNeeded,
              onChanged: (v) => entry.actionNeeded = v,
            ),
          ),
          if (_rightPeopleEntries.length > 1)
            IconButton(
              onPressed: () {
                setState(() {
                  _rightPeopleEntries.removeAt(index);
                });
              },
              icon: const Icon(Icons.close, color: Colors.red, size: 20),
              padding: const EdgeInsets.only(left: 8),
              constraints: const BoxConstraints(),
            ),
        ],
      ),
    );
  }

  Widget _rightPeopleMobileField({
    required String label,
    required IconData icon,
    required String hintText,
    required String value,
    required ValueChanged<String> onChanged,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(icon, size: 16, color: const Color(0xFF6B7280)),
            const SizedBox(width: 6),
            Text(
              label,
              style: const TextStyle(
                fontWeight: FontWeight.w600,
                fontSize: 12,
                color: Color(0xFF6B7280),
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
          decoration: BoxDecoration(
            color: const Color(0xFFF9FAFB),
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: const Color(0xFFE2E8F0)),
          ),
          child: TextFormField(
            initialValue: value,
            decoration: InputDecoration(
              border: InputBorder.none,
              isDense: true,
              contentPadding: EdgeInsets.zero,
              hintText: hintText,
              hintStyle: const TextStyle(color: ScorecardPage._mutedColor),
            ),
            style: const TextStyle(
              color: ScorecardPage._titleColor,
              fontWeight: FontWeight.w500,
              fontSize: 14,
            ),
            onChanged: onChanged,
          ),
        ),
      ],
    );
  }

  Widget _rightPeopleCheckboxField({
    required String label,
    required bool value,
    required ValueChanged<bool?> onChanged,
  }) {
    return Row(
      children: [
        Checkbox(
          value: value,
          onChanged: onChanged,
          activeColor: ScorecardPage._buttonBlue,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(4),
          ),
        ),
        Text(
          label,
          style: const TextStyle(
            fontSize: 13,
            fontWeight: FontWeight.w500,
            color: ScorecardPage._titleColor,
          ),
        ),
      ],
    );
  }

  Widget _rightPeopleCompactField({
    required String hintText,
    required String value,
    required ValueChanged<String> onChanged,
  }) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: TextFormField(
        initialValue: value,
        decoration: InputDecoration(
          border: InputBorder.none,
          isDense: true,
          contentPadding: EdgeInsets.zero,
          hintText: hintText,
          hintStyle:
              const TextStyle(color: ScorecardPage._mutedColor, fontSize: 14),
        ),
        style: const TextStyle(
          color: ScorecardPage._titleColor,
          fontSize: 14,
        ),
        onChanged: onChanged,
      ),
    );
  }

  Widget _rightPeopleCheckboxCompact({
    required bool value,
    required ValueChanged<bool?> onChanged,
  }) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.start,
      children: [
        SizedBox(
          width: 20,
          height: 20,
          child: Checkbox(
            value: value,
            onChanged: onChanged,
            activeColor: ScorecardPage._buttonBlue,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(4),
            ),
            materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
          ),
        ),
        const SizedBox(width: 6),
        Text(
          value ? 'Yes' : 'No',
          style: TextStyle(
            fontSize: 13,
            fontWeight: FontWeight.w500,
            color:
                value ? ScorecardPage._buttonBlue : ScorecardPage._mutedColor,
          ),
        ),
      ],
    );
  }

  Widget _buildBlueprintTableHeader() {
    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.symmetric(vertical: 14, horizontal: 12),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            const Color(0xFFF8FAFC),
            const Color(0xFFF1F5F9),
          ],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: Row(
        children: const [
          Expanded(
            flex: 10,
            child: Text(
              'Week',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          SizedBox(width: 10),
          Expanded(
            flex: 25,
            child: Text(
              'Issue/Opportunity',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          SizedBox(width: 10),
          Expanded(
            flex: 25,
            child: Text(
              'Blueprint Tool Used',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          SizedBox(width: 10),
          Expanded(
            flex: 25,
            child: Text(
              'Outcome',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildBlueprintEntryRow(bool isMobile) {
    if (isMobile) {
      // Mobile: Stack fields vertically
      return Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: const Color(0xFFE2E8F0)),
          boxShadow: [
            BoxShadow(
                color: Colors.black.withValues(alpha: 0.03),
                blurRadius: 8,
                offset: const Offset(0, 2)),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _blueprintWeekFieldMobile(),
            const SizedBox(height: 16),
            _blueprintIssueFieldMobile(),
            const SizedBox(height: 16),
            _blueprintToolFieldMobile(),
            const SizedBox(height: 16),
            _blueprintOutcomeFieldMobile(),
          ],
        ),
      );
    }

    // Desktop/Tablet: Horizontal row
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 12),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Expanded(flex: 10, child: _blueprintWeekFieldCompact()),
          const SizedBox(width: 10),
          Expanded(flex: 25, child: _blueprintIssueFieldCompact()),
          const SizedBox(width: 10),
          Expanded(flex: 25, child: _blueprintToolFieldCompact()),
          const SizedBox(width: 10),
          Expanded(flex: 25, child: _blueprintOutcomeFieldCompact()),
        ],
      ),
    );
  }

  // Mobile field widgets for Blueprint Utilization
  Widget _blueprintWeekFieldMobile() {
    return _blueprintMobileFieldWrapper(
      label: 'Week',
      icon: Icons.calendar_view_week_rounded,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
        decoration: BoxDecoration(
          color: const Color(0xFFF9FAFB),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: const Color(0xFFE2E8F0)),
        ),
        child: TextFormField(
          initialValue: _blueprintWeek.toString(),
          keyboardType: TextInputType.number,
          decoration: const InputDecoration(
            border: InputBorder.none,
            isDense: true,
            contentPadding: EdgeInsets.zero,
            hintText: '1',
            hintStyle: TextStyle(color: ScorecardPage._mutedColor),
          ),
          style: const TextStyle(
            color: ScorecardPage._titleColor,
            fontWeight: FontWeight.w600,
            fontSize: 15,
          ),
          onChanged: (v) => _blueprintWeek = int.tryParse(v) ?? 1,
        ),
      ),
    );
  }

  Widget _blueprintIssueFieldMobile() {
    return _blueprintMobileFieldWrapper(
      label: 'Issue/Opportunity',
      icon: Icons.lightbulb_outline_rounded,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
        decoration: BoxDecoration(
          color: const Color(0xFFF9FAFB),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: const Color(0xFFE2E8F0)),
        ),
        child: TextFormField(
          initialValue: _blueprintIssueOpportunity,
          decoration: const InputDecoration(
            border: InputBorder.none,
            isDense: true,
            contentPadding: EdgeInsets.zero,
            hintText: 'none',
            hintStyle: TextStyle(color: ScorecardPage._mutedColor),
          ),
          style: const TextStyle(
            color: ScorecardPage._titleColor,
            fontWeight: FontWeight.w600,
            fontSize: 15,
          ),
          onChanged: (v) => _blueprintIssueOpportunity = v,
        ),
      ),
    );
  }

  Widget _blueprintToolFieldMobile() {
    return _blueprintMobileFieldWrapper(
      label: 'Blueprint Tool Used',
      icon: Icons.build_outlined,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
        decoration: BoxDecoration(
          color: const Color(0xFFF9FAFB),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: const Color(0xFFE2E8F0)),
        ),
        child: TextFormField(
          initialValue: _blueprintToolUsed,
          decoration: const InputDecoration(
            border: InputBorder.none,
            isDense: true,
            contentPadding: EdgeInsets.zero,
            hintText: 'none',
            hintStyle: TextStyle(color: ScorecardPage._mutedColor),
          ),
          style: const TextStyle(
            color: ScorecardPage._titleColor,
            fontWeight: FontWeight.w600,
            fontSize: 15,
          ),
          onChanged: (v) => _blueprintToolUsed = v,
        ),
      ),
    );
  }

  Widget _blueprintOutcomeFieldMobile() {
    return _blueprintMobileFieldWrapper(
      label: 'Outcome',
      icon: Icons.check_circle_outline_rounded,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
        decoration: BoxDecoration(
          color: const Color(0xFFF9FAFB),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: const Color(0xFFE2E8F0)),
        ),
        child: TextFormField(
          initialValue: _blueprintOutcome,
          decoration: const InputDecoration(
            border: InputBorder.none,
            isDense: true,
            contentPadding: EdgeInsets.zero,
            hintText: 'none',
            hintStyle: TextStyle(color: ScorecardPage._mutedColor),
          ),
          style: const TextStyle(
            color: ScorecardPage._titleColor,
            fontWeight: FontWeight.w600,
            fontSize: 15,
          ),
          onChanged: (v) => _blueprintOutcome = v,
        ),
      ),
    );
  }

  Widget _blueprintMobileFieldWrapper({
    required String label,
    required IconData icon,
    required Widget child,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(icon, size: 16, color: const Color(0xFF6B7280)),
            const SizedBox(width: 8),
            Text(
              label,
              style: const TextStyle(
                fontWeight: FontWeight.w600,
                fontSize: 13,
                color: Color(0xFF475569),
              ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        child,
      ],
    );
  }

  // Compact field widgets for Blueprint Utilization (Desktop/Tablet)
  Widget _blueprintWeekFieldCompact() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: TextFormField(
        initialValue: _blueprintWeek.toString(),
        keyboardType: TextInputType.number,
        decoration: const InputDecoration(
          border: InputBorder.none,
          isDense: true,
          contentPadding: EdgeInsets.zero,
          hintText: '1',
          hintStyle: TextStyle(color: ScorecardPage._mutedColor, fontSize: 14),
        ),
        style: const TextStyle(
          color: ScorecardPage._titleColor,
          fontWeight: FontWeight.w500,
          fontSize: 14,
        ),
        onChanged: (v) => _blueprintWeek = int.tryParse(v) ?? 1,
      ),
    );
  }

  Widget _blueprintIssueFieldCompact() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: TextFormField(
        initialValue: _blueprintIssueOpportunity,
        decoration: const InputDecoration(
          border: InputBorder.none,
          isDense: true,
          contentPadding: EdgeInsets.zero,
          hintText: 'none',
          hintStyle: TextStyle(color: ScorecardPage._mutedColor, fontSize: 14),
        ),
        style: const TextStyle(
          color: ScorecardPage._titleColor,
          fontWeight: FontWeight.w500,
          fontSize: 14,
        ),
        onChanged: (v) => _blueprintIssueOpportunity = v,
      ),
    );
  }

  Widget _blueprintToolFieldCompact() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: TextFormField(
        initialValue: _blueprintToolUsed,
        decoration: const InputDecoration(
          border: InputBorder.none,
          isDense: true,
          contentPadding: EdgeInsets.zero,
          hintText: 'none',
          hintStyle: TextStyle(color: ScorecardPage._mutedColor, fontSize: 14),
        ),
        style: const TextStyle(
          color: ScorecardPage._titleColor,
          fontWeight: FontWeight.w500,
          fontSize: 14,
        ),
        onChanged: (v) => _blueprintToolUsed = v,
      ),
    );
  }

  Widget _blueprintOutcomeFieldCompact() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: TextFormField(
        initialValue: _blueprintOutcome,
        decoration: const InputDecoration(
          border: InputBorder.none,
          isDense: true,
          contentPadding: EdgeInsets.zero,
          hintText: 'none',
          hintStyle: TextStyle(color: ScorecardPage._mutedColor, fontSize: 14),
        ),
        style: const TextStyle(
          color: ScorecardPage._titleColor,
          fontWeight: FontWeight.w500,
          fontSize: 14,
        ),
        onChanged: (v) => _blueprintOutcome = v,
      ),
    );
  }

  Widget _buildBlueprintUtilizationAndRating(double width) {
    final bool isMobile = width < 600;

    if (isMobile) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _blueprintMonthlyUtilizationField(),
          const SizedBox(height: 16),
          _blueprintEffectivenessRatingField(),
        ],
      );
    }

    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Expanded(child: _blueprintMonthlyUtilizationField()),
        const SizedBox(width: 24),
        Expanded(child: _blueprintEffectivenessRatingField()),
      ],
    );
  }

  Widget _blueprintMonthlyUtilizationField() {
    return Row(
      children: [
        const Text(
          'Monthly Utilization:',
          style: TextStyle(
            fontWeight: FontWeight.w600,
            fontSize: 14,
            color: ScorecardPage._titleColor,
          ),
        ),
        const SizedBox(width: 12),
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 8),
          decoration: BoxDecoration(
            color: const Color(0xFFF9FAFB),
            borderRadius: BorderRadius.circular(10),
            border: Border.all(color: const Color(0xFFE2E8F0)),
          ),
          child: DropdownButtonHideUnderline(
            child: DropdownButton<int>(
              value: _blueprintMonthlyUtilization,
              items: List.generate(
                11,
                (i) => DropdownMenuItem(
                  value: i,
                  child: Text(
                    '$i',
                    style: const TextStyle(
                      color: ScorecardPage._titleColor,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
              ),
              onChanged: (v) {
                if (v != null) {
                  setState(() => _blueprintMonthlyUtilization = v);
                }
              },
              icon: const Icon(Icons.keyboard_arrow_down,
                  color: Color(0xFF6B7280)),
            ),
          ),
        ),
        const SizedBox(width: 8),
        const Text(
          'times',
          style: TextStyle(
            fontSize: 14,
            color: ScorecardPage._mutedColor,
          ),
        ),
      ],
    );
  }

  Widget _blueprintEffectivenessRatingField() {
    return Row(
      children: [
        const Text(
          'Blueprint Effectiveness Rating (1-10):',
          style: TextStyle(
            fontWeight: FontWeight.w600,
            fontSize: 14,
            color: ScorecardPage._titleColor,
          ),
        ),
        const SizedBox(width: 12),
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 8),
          decoration: BoxDecoration(
            color: const Color(0xFFF9FAFB),
            borderRadius: BorderRadius.circular(10),
            border: Border.all(color: const Color(0xFFE2E8F0)),
          ),
          child: DropdownButtonHideUnderline(
            child: DropdownButton<int>(
              value: _blueprintEffectivenessRating,
              items: List.generate(
                11,
                (i) => DropdownMenuItem(
                  value: i,
                  child: Text(
                    '$i',
                    style: const TextStyle(
                      color: ScorecardPage._titleColor,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
              ),
              onChanged: (v) {
                if (v != null) {
                  setState(() => _blueprintEffectivenessRating = v);
                }
              },
              icon: const Icon(Icons.keyboard_arrow_down,
                  color: Color(0xFF6B7280)),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildCore4TableHeader() {
    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.symmetric(vertical: 14, horizontal: 12),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            const Color(0xFFF8FAFC),
            const Color(0xFFF1F5F9),
          ],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: Row(
        children: const [
          Expanded(
            flex: 18,
            child: Text(
              'Assessment Date',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          Expanded(
            flex: 14,
            child: Text(
              'score (0-100)',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          Expanded(
            flex: 18,
            child: Text(
              'Change from Previous',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          Expanded(
            flex: 22,
            child: Text(
              'Key Insights',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
          Expanded(
            flex: 18,
            child: Text(
              'Weekly Goal',
              style: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 13,
                  color: Color(0xFF475569)),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCore4EntryRow(bool isMobile, bool isTablet) {
    if (isMobile) {
      // Mobile: Stack fields vertically in cards
      return Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: const Color(0xFFE2E8F0)),
          boxShadow: [
            BoxShadow(
                color: Colors.black.withValues(alpha: 0.03),
                blurRadius: 8,
                offset: const Offset(0, 2)),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _core4DateFieldMobile(),
            const SizedBox(height: 16),
            _core4ScoreFieldMobile(),
            const SizedBox(height: 16),
            _core4ChangeFieldMobile(),
            const SizedBox(height: 16),
            _core4InsightsFieldMobile(),
            const SizedBox(height: 16),
            _core4WeeklyGoalFieldMobile(),
          ],
        ),
      );
    }

    // Desktop/Tablet: Horizontal row
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 12),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Expanded(flex: 18, child: _core4DateFieldCompact()),
          const SizedBox(width: 10),
          Expanded(flex: 14, child: _core4ScoreFieldCompact()),
          const SizedBox(width: 10),
          Expanded(flex: 18, child: _core4ChangeFieldCompact()),
          const SizedBox(width: 10),
          Expanded(flex: 22, child: _core4InsightsFieldCompact()),
          const SizedBox(width: 10),
          Expanded(flex: 18, child: _core4WeeklyGoalFieldCompact()),
        ],
      ),
    );
  }

  // Mobile field widgets for Core4
  Widget _core4DateFieldMobile() {
    return _core4MobileFieldWrapper(
      label: 'Assessment Date',
      icon: Icons.calendar_today_rounded,
      child: InkWell(
        onTap: () async {
          final picked = await showDatePicker(
            context: context,
            initialDate: _core4AssessmentDate ?? DateTime.now(),
            firstDate: DateTime(2020),
            lastDate: DateTime(2100),
          );
          if (picked != null) setState(() => _core4AssessmentDate = picked);
        },
        borderRadius: BorderRadius.circular(12),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 14),
          decoration: BoxDecoration(
            color: const Color(0xFFF9FAFB),
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: const Color(0xFFE2E8F0)),
          ),
          child: Row(
            children: [
              Expanded(
                child: Text(
                  _core4AssessmentDate != null
                      ? '${_core4AssessmentDate!.month.toString().padLeft(2, '0')}/${_core4AssessmentDate!.day.toString().padLeft(2, '0')}/${_core4AssessmentDate!.year}'
                      : 'mm/dd/yyyy',
                  style: TextStyle(
                    color: _core4AssessmentDate != null
                        ? ScorecardPage._titleColor
                        : ScorecardPage._mutedColor,
                    fontSize: 15,
                  ),
                ),
              ),
              Icon(Icons.calendar_month_rounded,
                  color: ScorecardPage._mutedColor, size: 20),
            ],
          ),
        ),
      ),
    );
  }

  Widget _core4ScoreFieldMobile() {
    return _core4MobileFieldWrapper(
      label: 'Score (0-100)',
      icon: Icons.analytics_rounded,
      child: Container(
        decoration: BoxDecoration(
          color: const Color(0xFFF9FAFB),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: const Color(0xFFE2E8F0)),
        ),
        child: TextFormField(
          initialValue: _core4Score.toString(),
          keyboardType: TextInputType.number,
          decoration: const InputDecoration(
            hintText: '0',
            border: InputBorder.none,
            contentPadding: EdgeInsets.symmetric(horizontal: 14, vertical: 14),
            hintStyle: TextStyle(color: ScorecardPage._mutedColor),
          ),
          style:
              const TextStyle(color: ScorecardPage._titleColor, fontSize: 15),
          onChanged: (v) => _core4Score = int.tryParse(v) ?? 0,
        ),
      ),
    );
  }

  Widget _core4ChangeFieldMobile() {
    return _core4MobileFieldWrapper(
      label: 'Change from Previous',
      icon: Icons.compare_arrows_rounded,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 14),
        decoration: BoxDecoration(
          color: const Color(0xFFF9FAFB),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: const Color(0xFFE2E8F0)),
        ),
        child: DropdownButtonHideUnderline(
          child: DropdownButton<String>(
            value: _core4ChangeFromPrevious,
            isExpanded: true,
            icon: const Icon(Icons.keyboard_arrow_down_rounded,
                color: ScorecardPage._mutedColor),
            style:
                const TextStyle(color: ScorecardPage._titleColor, fontSize: 15),
            items: const [
              DropdownMenuItem(
                  value: 'Select...',
                  child: Text('Select...',
                      style: TextStyle(color: ScorecardPage._mutedColor))),
              DropdownMenuItem(
                  value: 'Improved',
                  child: Text('Improved',
                      style: TextStyle(color: Color(0xFF22C55E)))),
              DropdownMenuItem(
                  value: 'Same',
                  child:
                      Text('Same', style: TextStyle(color: Color(0xFFF59E0B)))),
              DropdownMenuItem(
                  value: 'Declined',
                  child: Text('Declined',
                      style: TextStyle(color: Color(0xFFEF4444)))),
              DropdownMenuItem(
                  value: 'First Assessment',
                  child: Text('First Assessment',
                      style: TextStyle(color: Color(0xFF3B82F6)))),
            ],
            onChanged: (v) =>
                setState(() => _core4ChangeFromPrevious = v ?? 'Select...'),
          ),
        ),
      ),
    );
  }

  Widget _core4InsightsFieldMobile() {
    return _core4MobileFieldWrapper(
      label: 'Key Insights',
      icon: Icons.lightbulb_outline_rounded,
      child: Container(
        decoration: BoxDecoration(
          color: const Color(0xFFF9FAFB),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: const Color(0xFFE2E8F0)),
        ),
        child: TextFormField(
          initialValue: _core4KeyInsights,
          decoration: const InputDecoration(
            hintText: 'none',
            border: InputBorder.none,
            contentPadding: EdgeInsets.symmetric(horizontal: 14, vertical: 14),
            hintStyle: TextStyle(color: ScorecardPage._mutedColor),
          ),
          style:
              const TextStyle(color: ScorecardPage._titleColor, fontSize: 15),
          onChanged: (v) => _core4KeyInsights = v,
        ),
      ),
    );
  }

  Widget _core4WeeklyGoalFieldMobile() {
    return _core4MobileFieldWrapper(
      label: 'Weekly Goal',
      icon: Icons.flag_rounded,
      child: Container(
        decoration: BoxDecoration(
          color: const Color(0xFFF9FAFB),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: const Color(0xFFE2E8F0)),
        ),
        child: TextFormField(
          initialValue: _core4WeeklyGoal,
          decoration: const InputDecoration(
            hintText: 'Weekly Goal',
            border: InputBorder.none,
            contentPadding: EdgeInsets.symmetric(horizontal: 14, vertical: 14),
            hintStyle: TextStyle(color: ScorecardPage._mutedColor),
          ),
          style:
              const TextStyle(color: ScorecardPage._titleColor, fontSize: 15),
          onChanged: (v) => _core4WeeklyGoal = v,
        ),
      ),
    );
  }

  Widget _core4MobileFieldWrapper(
      {required String label, required IconData icon, required Widget child}) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(icon, size: 16, color: const Color(0xFF3B82F6)),
            const SizedBox(width: 8),
            Text(
              label,
              style: const TextStyle(
                fontWeight: FontWeight.w600,
                fontSize: 13,
                color: Color(0xFF475569),
              ),
            ),
          ],
        ),
        const SizedBox(height: 10),
        child,
      ],
    );
  }

  // Compact field widgets for Core4 (desktop/tablet)
  Widget _core4DateFieldCompact() {
    return InkWell(
      onTap: () async {
        final picked = await showDatePicker(
          context: context,
          initialDate: _core4AssessmentDate ?? DateTime.now(),
          firstDate: DateTime(2020),
          lastDate: DateTime(2100),
        );
        if (picked != null) setState(() => _core4AssessmentDate = picked);
      },
      borderRadius: BorderRadius.circular(10),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
        decoration: BoxDecoration(
          color: const Color(0xFFF9FAFB),
          borderRadius: BorderRadius.circular(10),
          border: Border.all(color: const Color(0xFFE2E8F0)),
        ),
        child: Row(
          children: [
            Expanded(
              child: Text(
                _core4AssessmentDate != null
                    ? '${_core4AssessmentDate!.month.toString().padLeft(2, '0')}/${_core4AssessmentDate!.day.toString().padLeft(2, '0')}/${_core4AssessmentDate!.year}'
                    : 'mm/dd/yyyy',
                style: TextStyle(
                  color: _core4AssessmentDate != null
                      ? ScorecardPage._titleColor
                      : ScorecardPage._mutedColor,
                  fontSize: 14,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _core4ScoreFieldCompact() {
    return Container(
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: TextFormField(
        initialValue: _core4Score.toString(),
        keyboardType: TextInputType.number,
        decoration: const InputDecoration(
          hintText: '0',
          border: InputBorder.none,
          contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 12),
          hintStyle: TextStyle(color: ScorecardPage._mutedColor),
          isDense: true,
        ),
        style: const TextStyle(color: ScorecardPage._titleColor, fontSize: 14),
        onChanged: (v) => _core4Score = int.tryParse(v) ?? 0,
      ),
    );
  }

  Widget _core4ChangeFieldCompact() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10),
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: _core4ChangeFromPrevious,
          isExpanded: true,
          icon: const Icon(Icons.keyboard_arrow_down_rounded,
              color: ScorecardPage._mutedColor, size: 20),
          style:
              const TextStyle(color: ScorecardPage._titleColor, fontSize: 14),
          isDense: true,
          items: const [
            DropdownMenuItem(
                value: 'Select...',
                child: Text('chan',
                    style: TextStyle(
                        color: ScorecardPage._mutedColor, fontSize: 14))),
            DropdownMenuItem(
                value: 'Improved',
                child: Text('Improved',
                    style: TextStyle(color: Color(0xFF22C55E), fontSize: 14))),
            DropdownMenuItem(
                value: 'Same',
                child: Text('Same',
                    style: TextStyle(color: Color(0xFFF59E0B), fontSize: 14))),
            DropdownMenuItem(
                value: 'Declined',
                child: Text('Declined',
                    style: TextStyle(color: Color(0xFFEF4444), fontSize: 14))),
            DropdownMenuItem(
                value: 'First Assessment',
                child: Text('First',
                    style: TextStyle(color: Color(0xFF3B82F6), fontSize: 14))),
          ],
          onChanged: (v) =>
              setState(() => _core4ChangeFromPrevious = v ?? 'Select...'),
        ),
      ),
    );
  }

  Widget _core4InsightsFieldCompact() {
    return Container(
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: TextFormField(
        initialValue: _core4KeyInsights,
        decoration: const InputDecoration(
          hintText: 'none',
          border: InputBorder.none,
          contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 12),
          hintStyle: TextStyle(color: ScorecardPage._mutedColor),
          isDense: true,
        ),
        style: const TextStyle(color: ScorecardPage._titleColor, fontSize: 14),
        onChanged: (v) => _core4KeyInsights = v,
      ),
    );
  }

  Widget _core4WeeklyGoalFieldCompact() {
    return Container(
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: TextFormField(
        initialValue: _core4WeeklyGoal,
        decoration: const InputDecoration(
          hintText: 'Weekly Goal',
          border: InputBorder.none,
          contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 12),
          hintStyle: TextStyle(color: ScorecardPage._mutedColor),
          isDense: true,
        ),
        style: const TextStyle(color: ScorecardPage._titleColor, fontSize: 14),
        onChanged: (v) => _core4WeeklyGoal = v,
      ),
    );
  }

  Widget _buildCore4TextArea({
    required String label,
    required String hintText,
    required String value,
    required ValueChanged<String> onChanged,
    required IconData icon,
    required Color iconColor,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: iconColor.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(10),
              ),
              child: Icon(icon, size: 18, color: iconColor),
            ),
            const SizedBox(width: 12),
            Text(
              label,
              style: const TextStyle(
                fontWeight: FontWeight.w700,
                fontSize: 15,
                color: Color(0xFF1E293B),
              ),
            ),
          ],
        ),
        const SizedBox(height: 14),
        Container(
          decoration: BoxDecoration(
            color: const Color(0xFFF9FAFB),
            borderRadius: BorderRadius.circular(16),
            border: Border.all(color: const Color(0xFFE2E8F0)),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withValues(alpha: 0.02),
                blurRadius: 8,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: TextFormField(
            minLines: 4,
            maxLines: 8,
            initialValue: value,
            decoration: InputDecoration(
              hintText: hintText,
              border: InputBorder.none,
              contentPadding:
                  const EdgeInsets.symmetric(horizontal: 18, vertical: 16),
              hintStyle: const TextStyle(
                  color: ScorecardPage._mutedColor, fontSize: 15),
            ),
            style: const TextStyle(
                color: ScorecardPage._titleColor, fontSize: 15, height: 1.5),
            onChanged: onChanged,
          ),
        ),
      ],
    );
  }

  Widget _buildDelegationTableHeader() {
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 8),
      decoration: BoxDecoration(
        color: const Color(0xFFF8FAFC),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: Row(
        children: const [
          Expanded(
              flex: 15,
              child: Text('Date',
                  style: TextStyle(
                      fontWeight: FontWeight.w700,
                      fontSize: 13,
                      color: Color(0xFF64748B)))),
          Expanded(
              flex: 22,
              child: Text('Task/Project',
                  style: TextStyle(
                      fontWeight: FontWeight.w700,
                      fontSize: 13,
                      color: Color(0xFF64748B)))),
          Expanded(
              flex: 18,
              child: Text('Time Saved (minutes)',
                  style: TextStyle(
                      fontWeight: FontWeight.w700,
                      fontSize: 13,
                      color: Color(0xFF64748B)))),
          Expanded(
              flex: 20,
              child: Text('Delegation Level',
                  style: TextStyle(
                      fontWeight: FontWeight.w700,
                      fontSize: 13,
                      color: Color(0xFF64748B)))),
          Expanded(
              flex: 20,
              child: Text('Outcome',
                  style: TextStyle(
                      fontWeight: FontWeight.w700,
                      fontSize: 13,
                      color: Color(0xFF64748B)))),
          SizedBox(width: 40),
        ],
      ),
    );
  }

  Widget _buildDelegationEntryRow(
      int index, _DelegationEntry entry, bool isMobile) {
    if (isMobile) {
      return Container(
        margin: const EdgeInsets.only(bottom: 16),
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: const Color(0xFFE2E8F0)),
          boxShadow: [
            BoxShadow(
                color: Colors.black.withValues(alpha: 0.03),
                blurRadius: 8,
                offset: const Offset(0, 2)),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text('Entry ${index + 1}',
                    style: const TextStyle(
                        fontWeight: FontWeight.w700,
                        fontSize: 14,
                        color: Color(0xFF2563EB))),
                if (_delegationEntries.length > 1)
                  IconButton(
                    icon: const Icon(Icons.remove_circle_outline,
                        color: Color(0xFFDC2626), size: 22),
                    onPressed: () =>
                        setState(() => _delegationEntries.removeAt(index)),
                    padding: EdgeInsets.zero,
                    constraints: const BoxConstraints(),
                  ),
              ],
            ),
            const SizedBox(height: 12),
            _delegationDateField(entry),
            const SizedBox(height: 12),
            _delegationTaskField(entry),
            const SizedBox(height: 12),
            _delegationTimeSavedField(entry),
            const SizedBox(height: 12),
            _delegationLevelField(entry),
            const SizedBox(height: 12),
            _delegationOutcomeField(entry),
            if (index == _delegationEntries.length - 1) ...[
              const SizedBox(height: 16),
              SizedBox(
                width: double.infinity,
                child: OutlinedButton.icon(
                  onPressed: () => setState(
                      () => _delegationEntries.add(_DelegationEntry())),
                  icon: const Icon(Icons.add, size: 18),
                  label: const Text('Add Entry'),
                  style: OutlinedButton.styleFrom(
                    foregroundColor: const Color(0xFF2563EB),
                    side: const BorderSide(color: Color(0xFF2563EB)),
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(10)),
                  ),
                ),
              ),
            ],
          ],
        ),
      );
    }

    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 8),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Expanded(flex: 15, child: _delegationDateFieldCompact(entry)),
          const SizedBox(width: 8),
          Expanded(flex: 22, child: _delegationTaskFieldCompact(entry)),
          const SizedBox(width: 8),
          Expanded(flex: 18, child: _delegationTimeSavedFieldCompact(entry)),
          const SizedBox(width: 8),
          Expanded(flex: 20, child: _delegationLevelFieldCompact(entry)),
          const SizedBox(width: 8),
          Expanded(flex: 20, child: _delegationOutcomeFieldCompact(entry)),
          SizedBox(
            width: 40,
            child: index == _delegationEntries.length - 1
                ? IconButton(
                    icon: const Icon(Icons.add_circle_outline,
                        color: Color(0xFF2563EB), size: 22),
                    onPressed: () => setState(
                        () => _delegationEntries.add(_DelegationEntry())),
                    padding: EdgeInsets.zero,
                    constraints: const BoxConstraints(),
                    tooltip: 'Add entry',
                  )
                : _delegationEntries.length > 1
                    ? IconButton(
                        icon: const Icon(Icons.remove_circle_outline,
                            color: Color(0xFFDC2626), size: 22),
                        onPressed: () =>
                            setState(() => _delegationEntries.removeAt(index)),
                        padding: EdgeInsets.zero,
                        constraints: const BoxConstraints(),
                        tooltip: 'Remove entry',
                      )
                    : const SizedBox(),
          ),
        ],
      ),
    );
  }

  // Mobile delegation fields
  Widget _delegationDateField(_DelegationEntry entry) {
    return _smallLabeled(
      label: 'Date',
      child: _boxed(
        child: InkWell(
          onTap: () async {
            final now = DateTime.now();
            final picked = await showDatePicker(
              context: context,
              initialDate: entry.date ?? now,
              firstDate: DateTime(now.year - 5),
              lastDate: DateTime(now.year + 5),
            );
            if (picked != null) setState(() => entry.date = picked);
          },
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 14),
            child: Row(
              children: [
                Expanded(
                  child: Text(
                    entry.date == null
                        ? 'mm/dd/yyyy'
                        : '${entry.date!.month.toString().padLeft(2, '0')}/${entry.date!.day.toString().padLeft(2, '0')}/${entry.date!.year}',
                    style: TextStyle(
                      color: entry.date == null
                          ? ScorecardPage._mutedColor
                          : ScorecardPage._titleColor,
                      fontWeight: entry.date == null
                          ? FontWeight.w500
                          : FontWeight.w600,
                    ),
                  ),
                ),
                const Icon(Icons.calendar_today_outlined,
                    color: ScorecardPage._mutedColor, size: 18),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _delegationTaskField(_DelegationEntry entry) {
    return _smallLabeled(
      label: 'Task/Project',
      child: _boxed(
        child: TextFormField(
          initialValue: entry.taskProject,
          decoration: const InputDecoration(
            border: InputBorder.none,
            contentPadding: EdgeInsets.symmetric(horizontal: 14, vertical: 14),
            hintText: 'Enter task or project name',
            hintStyle: TextStyle(color: ScorecardPage._mutedColor),
          ),
          style: const TextStyle(color: ScorecardPage._titleColor),
          onChanged: (v) => entry.taskProject = v,
        ),
      ),
    );
  }

  Widget _delegationTimeSavedField(_DelegationEntry entry) {
    return _smallLabeled(
      label: 'Time Saved (minutes)',
      child: _boxed(
        child: TextFormField(
          initialValue: entry.timeSavedMinutes > 0
              ? entry.timeSavedMinutes.toString()
              : '',
          keyboardType: TextInputType.number,
          decoration: const InputDecoration(
            border: InputBorder.none,
            contentPadding: EdgeInsets.symmetric(horizontal: 14, vertical: 14),
            hintText: '0',
            hintStyle: TextStyle(color: ScorecardPage._mutedColor),
          ),
          style: const TextStyle(color: ScorecardPage._titleColor),
          onChanged: (v) => entry.timeSavedMinutes = int.tryParse(v) ?? 0,
        ),
      ),
    );
  }

  Widget _delegationLevelField(_DelegationEntry entry) {
    return _smallLabeled(
      label: 'Delegation Level',
      child: _boxed(
        child: DropdownButtonFormField<String>(
          value: entry.delegationLevel,
          items: const [
            DropdownMenuItem(value: 'Select...', child: Text('Select...')),
            DropdownMenuItem(value: 'Full', child: Text('Full')),
            DropdownMenuItem(value: 'Partial', child: Text('Partial')),
            DropdownMenuItem(value: 'Supervised', child: Text('Supervised')),
            DropdownMenuItem(value: 'Assisted', child: Text('Assisted')),
          ],
          decoration: const InputDecoration(
            border: InputBorder.none,
            contentPadding: EdgeInsets.symmetric(horizontal: 14, vertical: 6),
          ),
          style: const TextStyle(color: ScorecardPage._titleColor),
          icon: const Icon(Icons.expand_more, color: ScorecardPage._mutedColor),
          dropdownColor: Colors.white,
          onChanged: (v) =>
              setState(() => entry.delegationLevel = v ?? 'Select...'),
        ),
      ),
    );
  }

  Widget _delegationOutcomeField(_DelegationEntry entry) {
    return _smallLabeled(
      label: 'Outcome',
      child: _boxed(
        child: DropdownButtonFormField<String>(
          value: entry.outcome,
          items: const [
            DropdownMenuItem(
                value: 'Select outcome', child: Text('Select outcome')),
            DropdownMenuItem(value: 'Successful', child: Text('Successful')),
            DropdownMenuItem(
                value: 'Partially Successful',
                child: Text('Partially Successful')),
            DropdownMenuItem(
                value: 'Needs Improvement', child: Text('Needs Improvement')),
            DropdownMenuItem(value: 'Failed', child: Text('Failed')),
          ],
          decoration: const InputDecoration(
            border: InputBorder.none,
            contentPadding: EdgeInsets.symmetric(horizontal: 14, vertical: 6),
          ),
          style: const TextStyle(color: ScorecardPage._titleColor),
          icon: const Icon(Icons.expand_more, color: ScorecardPage._mutedColor),
          dropdownColor: Colors.white,
          onChanged: (v) =>
              setState(() => entry.outcome = v ?? 'Select outcome'),
        ),
      ),
    );
  }

  // Compact desktop delegation fields
  Widget _delegationDateFieldCompact(_DelegationEntry entry) {
    return InkWell(
      onTap: () async {
        final now = DateTime.now();
        final picked = await showDatePicker(
          context: context,
          initialDate: entry.date ?? now,
          firstDate: DateTime(now.year - 5),
          lastDate: DateTime(now.year + 5),
        );
        if (picked != null) setState(() => entry.date = picked);
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
        decoration: BoxDecoration(
          color: const Color(0xFFF9FAFB),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: const Color(0xFFE2E8F0)),
        ),
        child: Text(
          entry.date == null
              ? 'mm/dd/yyyy'
              : '${entry.date!.month.toString().padLeft(2, '0')}/${entry.date!.day.toString().padLeft(2, '0')}/${entry.date!.year}',
          style: TextStyle(
            color: entry.date == null
                ? ScorecardPage._mutedColor
                : ScorecardPage._titleColor,
            fontSize: 13,
          ),
        ),
      ),
    );
  }

  Widget _delegationTaskFieldCompact(_DelegationEntry entry) {
    return TextFormField(
      initialValue: entry.taskProject,
      decoration: InputDecoration(
        filled: true,
        fillColor: const Color(0xFFF9FAFB),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: Color(0xFFE2E8F0)),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: Color(0xFFE2E8F0)),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: Color(0xFF2563EB)),
        ),
        contentPadding:
            const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
        hintText: 'none',
        hintStyle:
            const TextStyle(color: ScorecardPage._mutedColor, fontSize: 13),
      ),
      style: const TextStyle(color: ScorecardPage._titleColor, fontSize: 13),
      onChanged: (v) => entry.taskProject = v,
    );
  }

  Widget _delegationTimeSavedFieldCompact(_DelegationEntry entry) {
    return TextFormField(
      initialValue:
          entry.timeSavedMinutes > 0 ? entry.timeSavedMinutes.toString() : '',
      keyboardType: TextInputType.number,
      decoration: InputDecoration(
        filled: true,
        fillColor: const Color(0xFFF9FAFB),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: Color(0xFFE2E8F0)),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: Color(0xFFE2E8F0)),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: Color(0xFF2563EB)),
        ),
        contentPadding:
            const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
        hintText: '0',
        hintStyle:
            const TextStyle(color: ScorecardPage._mutedColor, fontSize: 13),
      ),
      style: const TextStyle(color: ScorecardPage._titleColor, fontSize: 13),
      onChanged: (v) => entry.timeSavedMinutes = int.tryParse(v) ?? 0,
    );
  }

  Widget _delegationLevelFieldCompact(_DelegationEntry entry) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: entry.delegationLevel,
          isExpanded: true,
          isDense: true,
          icon: const Icon(Icons.expand_more,
              color: ScorecardPage._mutedColor, size: 18),
          style:
              const TextStyle(color: ScorecardPage._titleColor, fontSize: 13),
          dropdownColor: Colors.white,
          items: const [
            DropdownMenuItem(value: 'Select...', child: Text('Select...')),
            DropdownMenuItem(value: 'Full', child: Text('Full')),
            DropdownMenuItem(value: 'Partial', child: Text('Partial')),
            DropdownMenuItem(value: 'Supervised', child: Text('Supervised')),
            DropdownMenuItem(value: 'Assisted', child: Text('Assisted')),
          ],
          onChanged: (v) =>
              setState(() => entry.delegationLevel = v ?? 'Select...'),
        ),
      ),
    );
  }

  Widget _delegationOutcomeFieldCompact(_DelegationEntry entry) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: entry.outcome,
          isExpanded: true,
          isDense: true,
          icon: const Icon(Icons.expand_more,
              color: ScorecardPage._mutedColor, size: 18),
          style:
              const TextStyle(color: ScorecardPage._titleColor, fontSize: 13),
          dropdownColor: Colors.white,
          items: const [
            DropdownMenuItem(
                value: 'Select outcome', child: Text('Select outcome')),
            DropdownMenuItem(value: 'Successful', child: Text('Successful')),
            DropdownMenuItem(
                value: 'Partially Successful',
                child: Text('Partially Successful')),
            DropdownMenuItem(
                value: 'Needs Improvement', child: Text('Needs Improvement')),
            DropdownMenuItem(value: 'Failed', child: Text('Failed')),
          ],
          onChanged: (v) =>
              setState(() => entry.outcome = v ?? 'Select outcome'),
        ),
      ),
    );
  }

  Widget _buildDelegationGoalAndAchievement(double width) {
    final bool isStacked = width < 640;
    final goalWidget = _smallLabeled(
      label: 'Weekly Goal:',
      child: Row(
        children: [
          _boxed(
            child: SizedBox(
              width: 72,
              child: DropdownButtonHideUnderline(
                child: DropdownButton<int>(
                  value: _delegationWeeklyGoal,
                  isExpanded: true,
                  icon: const Icon(Icons.expand_more,
                      color: ScorecardPage._mutedColor, size: 18),
                  style: const TextStyle(
                      color: ScorecardPage._titleColor,
                      fontWeight: FontWeight.w600),
                  dropdownColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 12),
                  items: List.generate(11, (i) => i * 10)
                      .map((e) => DropdownMenuItem(value: e, child: Text('$e')))
                      .toList(),
                  onChanged: (v) =>
                      setState(() => _delegationWeeklyGoal = v ?? 0),
                ),
              ),
            ),
          ),
          const SizedBox(width: 10),
          const Flexible(
            child: Text(
              '% of delegations successful',
              style: TextStyle(
                  color: ScorecardPage._titleColor,
                  fontWeight: FontWeight.w600,
                  fontSize: 14),
            ),
          ),
        ],
      ),
    );

    final achievementWidget = _smallLabeled(
      label: 'Achievement:',
      child: Row(
        children: [
          _boxed(
            child: SizedBox(
              width: 72,
              child: DropdownButtonHideUnderline(
                child: DropdownButton<int>(
                  value: _delegationAchievement,
                  isExpanded: true,
                  icon: const Icon(Icons.expand_more,
                      color: ScorecardPage._mutedColor, size: 18),
                  style: const TextStyle(
                      color: ScorecardPage._titleColor,
                      fontWeight: FontWeight.w600),
                  dropdownColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 12),
                  items: [0, 1, 2, 3, 4, 5]
                      .map((e) => DropdownMenuItem(value: e, child: Text('$e')))
                      .toList(),
                  onChanged: (v) =>
                      setState(() => _delegationAchievement = v ?? 0),
                ),
              ),
            ),
          ),
          const SizedBox(width: 10),
          const Text(
            '(1-5 scale)',
            style: TextStyle(
                color: ScorecardPage._titleColor,
                fontWeight: FontWeight.w600,
                fontSize: 14),
          ),
        ],
      ),
    );

    if (isStacked) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          goalWidget,
          const SizedBox(height: 16),
          achievementWidget,
        ],
      );
    }

    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Expanded(child: goalWidget),
        const SizedBox(width: 24),
        Expanded(child: achievementWidget),
      ],
    );
  }

  Widget _buildFieldsForWidth(double width) {
    if (width >= 1040) {
      return Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _dateInputField(fixedWidth: 168),
          const SizedBox(width: 12),
          Expanded(flex: 20, child: _focusAreaField()),
          const SizedBox(width: 12),
          Expanded(flex: 14, child: _durationField()),
          const SizedBox(width: 12),
          Expanded(flex: 18, child: _valueGeneratedField()),
        ],
      );
    }

    if (width >= 720) {
      return Column(
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(child: _dateInputField()),
              const SizedBox(width: 12),
              Expanded(child: _focusAreaField()),
            ],
          ),
          const SizedBox(height: 12),
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(child: _durationField()),
              const SizedBox(width: 12),
              Expanded(child: _valueGeneratedField()),
            ],
          ),
        ],
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _dateInputField(),
        const SizedBox(height: 12),
        _focusAreaField(),
        const SizedBox(height: 12),
        _durationField(),
        const SizedBox(height: 12),
        _valueGeneratedField(),
      ],
    );
  }

  Widget _dateInputField({double? fixedWidth}) {
    final field = _smallLabeled(
      label: 'Date',
      child: _boxed(
        child: InkWell(
          onTap: () async {
            final now = DateTime.now();
            final picked = await showDatePicker(
              context: context,
              initialDate: _date ?? now,
              firstDate: DateTime(now.year - 5),
              lastDate: DateTime(now.year + 5),
            );
            if (picked != null) setState(() => _date = picked);
          },
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 14),
            child: Text(
              _date == null
                  ? 'MM/DD/YYYY'
                  : '${_date!.month.toString().padLeft(2, '0')}/${_date!.day.toString().padLeft(2, '0')}/${_date!.year}',
              style: TextStyle(
                color: _date == null
                    ? ScorecardPage._mutedColor
                    : ScorecardPage._titleColor,
                fontWeight: _date == null ? FontWeight.w500 : FontWeight.w600,
              ),
            ),
          ),
        ),
      ),
    );

    if (fixedWidth != null) {
      return SizedBox(width: fixedWidth, child: field);
    }

    return field;
  }

  Widget _focusAreaField() {
    return _smallLabeled(
      label: 'Focus Area',
      child: _boxed(
        child: DropdownButtonFormField<String>(
          value: _focusArea,
          items: const [
            DropdownMenuItem(value: 'none', child: Text('none')),
            DropdownMenuItem(value: 'Strategy', child: Text('Strategy')),
            DropdownMenuItem(value: 'Execution', child: Text('Execution')),
            DropdownMenuItem(value: 'Learning', child: Text('Learning')),
          ],
          decoration: const InputDecoration(
            border: InputBorder.none,
            contentPadding: EdgeInsets.symmetric(horizontal: 14, vertical: 6),
          ),
          style: const TextStyle(color: ScorecardPage._titleColor),
          icon: const Icon(Icons.expand_more, color: ScorecardPage._mutedColor),
          dropdownColor: Colors.white,
          onChanged: (v) => setState(() => _focusArea = v ?? 'none'),
        ),
      ),
    );
  }

  Widget _durationField() {
    return _smallLabeled(
      label: 'Duration (hrs)',
      child: _boxed(
        child: TextFormField(
          keyboardType: TextInputType.number,
          decoration: const InputDecoration(
            border: InputBorder.none,
            contentPadding: EdgeInsets.symmetric(horizontal: 14, vertical: 14),
            hintText: 'Select...',
            hintStyle: TextStyle(color: ScorecardPage._mutedColor),
          ),
          style: const TextStyle(color: ScorecardPage._titleColor),
          onSaved: (v) => _durationHours = double.tryParse(v ?? '') ?? 0.0,
        ),
      ),
    );
  }

  Widget _valueGeneratedField() {
    return _smallLabeled(
      label: 'Value Generated',
      child: _boxed(
        child: DropdownButtonFormField<String>(
          value: _valueGenerated,
          items: const [
            DropdownMenuItem(value: 'Select...', child: Text('Select...')),
            DropdownMenuItem(value: 'Low', child: Text('Low')),
            DropdownMenuItem(value: 'Medium', child: Text('Medium')),
            DropdownMenuItem(value: 'High', child: Text('High')),
          ],
          decoration: const InputDecoration(
            border: InputBorder.none,
            contentPadding: EdgeInsets.symmetric(horizontal: 14, vertical: 6),
          ),
          style: const TextStyle(color: ScorecardPage._titleColor),
          icon: const Icon(Icons.expand_more, color: ScorecardPage._mutedColor),
          dropdownColor: Colors.white,
          onChanged: (v) => setState(() => _valueGenerated = v ?? 'Select...'),
        ),
      ),
    );
  }

  // Supplemental guidance/tips panel displayed under the form
  Widget _buildGuidancePanel() {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.fromLTRB(24, 24, 24, 24),
      decoration: BoxDecoration(
        color: _insightCardBackground,
        borderRadius: BorderRadius.circular(20),
        border: const Border.fromBorderSide(
            BorderSide(color: ScorecardPage._borderColor)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: const [
          Text(
            'Guidance',
            style: TextStyle(
              color: _sectionTitleColor,
              fontSize: 16,
              fontWeight: FontWeight.w800,
            ),
          ),
          SizedBox(height: 10),
          _GuidanceRow(
            icon: Icons.tips_and_updates_outlined,
            text:
                'Focus on high-leverage actions that compound towards your quarterly goals.',
          ),
          SizedBox(height: 8),
          _GuidanceRow(
            icon: Icons.psychology_outlined,
            text:
                'Track learning consistency; short reflections improve week-over-week outcomes.',
          ),
          SizedBox(height: 8),
          _GuidanceRow(
            icon: Icons.task_alt_outlined,
            text:
                'Keep entries concise; clarity ensures better coaching feedback.',
          ),
        ],
      ),
    );
  }

  Widget _weeklyGoalAndAchievement(double width) {
    final bool isStacked = width < 640;
    final goalField = _goalField();
    final achievementField = _achievementField();

    if (isStacked) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          goalField,
          const SizedBox(height: 12),
          achievementField,
        ],
      );
    }

    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Expanded(child: goalField),
        const SizedBox(width: 24),
        Expanded(child: achievementField),
      ],
    );
  }

  Widget _goalField() {
    return _smallLabeled(
      label: 'Weekly Goal:',
      child: Row(
        children: [
          _boxed(
            child: SizedBox(
              width: 72,
              child: TextFormField(
                initialValue: '$_weeklyGoalHours',
                onSaved: (v) => _weeklyGoalHours = int.tryParse(v ?? '') ?? 0,
                keyboardType: TextInputType.number,
                decoration: const InputDecoration(
                  border: InputBorder.none,
                  contentPadding:
                      EdgeInsets.symmetric(horizontal: 14, vertical: 14),
                  hintStyle: TextStyle(color: ScorecardPage._mutedColor),
                ),
                style: const TextStyle(
                  color: ScorecardPage._titleColor,
                  fontWeight: FontWeight.w600,
                ),
                textAlign: TextAlign.center,
              ),
            ),
          ),
          const SizedBox(width: 8),
          const Text(
            'Hours',
            style: TextStyle(
              color: ScorecardPage._titleColor,
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      ),
    );
  }

  Widget _achievementField() {
    return _smallLabeled(
      label: 'Achievement:',
      child: Row(
        children: [
          _boxed(
            child: SizedBox(
              width: 84,
              child: DropdownButtonFormField<int>(
                value: _achievementPct,
                items: List.generate(11, (i) => i * 10)
                    .map((e) => DropdownMenuItem(value: e, child: Text('$e')))
                    .toList(),
                decoration: const InputDecoration(
                  border: InputBorder.none,
                  contentPadding:
                      EdgeInsets.symmetric(horizontal: 14, vertical: 6),
                ),
                style: const TextStyle(
                  color: ScorecardPage._titleColor,
                  fontWeight: FontWeight.w600,
                ),
                icon: const Icon(Icons.expand_more,
                    color: ScorecardPage._mutedColor),
                dropdownColor: Colors.white,
                onChanged: (v) => setState(() => _achievementPct = v ?? 0),
              ),
            ),
          ),
          const SizedBox(width: 8),
          const Text(
            '% of Goal',
            style: TextStyle(
              color: ScorecardPage._titleColor,
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      ),
    );
  }

  Widget _largeField(
      String label, String hint, FormFieldSetter<String?> onSaved) {
    return _smallLabeled(
      label: label,
      child: Container(
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(16),
          border: const Border.fromBorderSide(
              BorderSide(color: ScorecardPage._borderColor)),
        ),
        child: TextFormField(
          minLines: 3,
          maxLines: 6,
          decoration: InputDecoration(
            hintText: hint,
            border: InputBorder.none,
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
            hintStyle: const TextStyle(color: ScorecardPage._mutedColor),
          ),
          style: const TextStyle(color: ScorecardPage._titleColor),
          onSaved: onSaved,
        ),
      ),
    );
  }

  Widget _smallLabeled({required String label, required Widget child}) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: const TextStyle(
              color: ScorecardPage._titleColor,
              fontWeight: FontWeight.w700,
              fontSize: 14),
        ),
        const SizedBox(height: 8),
        child,
      ],
    );
  }

  Widget _boxed({required Widget child}) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        border: const Border.fromBorderSide(
            BorderSide(color: ScorecardPage._borderColor)),
      ),
      child: child,
    );
  }
}

class PreviousScorecardsDialog extends StatefulWidget {
  const PreviousScorecardsDialog(
      {super.key,
      required this.metricTitle,
      required this.uid,
      this.userEmail});

  final String metricTitle;
  final String uid;
  final String? userEmail;

  @override
  State<PreviousScorecardsDialog> createState() =>
      _PreviousScorecardsDialogState();
}

class _PreviousScorecardsDialogState extends State<PreviousScorecardsDialog> {
  static const List<String> _monthNames = <String>[
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
  ];

  late final Future<List<_ScorecardSubmission>> _future;

  @override
  void initState() {
    super.initState();
    _future = _fetchSubmissions();
  }

  @override
  Widget build(BuildContext context) {
    final size = MediaQuery.of(context).size;
    final bool isCompact = size.width < 720;
    final double horizontalInset = isCompact ? 12 : 24;
    final double verticalInset = 24;
    final double maxWidth =
        math.min(860, math.max(320, size.width - (horizontalInset * 2)));
    final double availableHeight =
        math.max(240, size.height - (verticalInset * 2));
    final double maxHeight = math.min(660, availableHeight);

    return Dialog(
      backgroundColor: Colors.transparent,
      insetPadding: EdgeInsets.symmetric(
          horizontal: horizontalInset, vertical: verticalInset),
      child: ConstrainedBox(
        constraints: BoxConstraints(maxWidth: maxWidth, maxHeight: maxHeight),
        child: Material(
          color: Colors.white,
          borderRadius: BorderRadius.circular(26),
          clipBehavior: Clip.antiAlias,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              _buildDialogHeader(context, isCompact: isCompact),
              Expanded(
                child: FutureBuilder<List<_ScorecardSubmission>>(
                  future: _future,
                  builder: (context, snapshot) {
                    if (snapshot.connectionState == ConnectionState.waiting) {
                      return const Center(
                          child: CircularProgressIndicator(strokeWidth: 2.6));
                    }

                    if (snapshot.hasError) {
                      return _buildErrorState(snapshot.error);
                    }

                    final submissions =
                        snapshot.data ?? <_ScorecardSubmission>[];
                    if (submissions.isEmpty) {
                      return _buildEmptyState();
                    }

                    final grouped = _groupByMonth(submissions);
                    int ordinal = 1;

                    return ScrollConfiguration(
                      behavior: const MaterialScrollBehavior()
                          .copyWith(overscroll: false),
                      child: ListView.builder(
                        padding: EdgeInsets.fromLTRB(
                            isCompact ? 20 : 32, 28, isCompact ? 20 : 32, 32),
                        itemCount: grouped.length,
                        itemBuilder: (context, index) {
                          final entry = grouped[index];
                          final widgets = <Widget>[
                            Text(
                              entry.label,
                              style: const TextStyle(
                                color: ScorecardPage._titleColor,
                                fontSize: 18,
                                fontWeight: FontWeight.w800,
                              ),
                            ),
                            const SizedBox(height: 12),
                          ];

                          for (final submission in entry.submissions) {
                            widgets
                              ..add(_buildSubmissionCard(submission, ordinal))
                              ..add(const SizedBox(height: 18));
                            ordinal += 1;
                          }

                          widgets.removeLast();

                          return Padding(
                            padding: EdgeInsets.only(top: index == 0 ? 0 : 28),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: widgets,
                            ),
                          );
                        },
                      ),
                    );
                  },
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildDialogHeader(BuildContext context, {required bool isCompact}) {
    final metricName = widget.metricTitle.toUpperCase();
    final double titleSize = isCompact ? 20 : 22;
    final double subtitleSize = isCompact ? 13 : 14;
    return Container(
      width: double.infinity,
      padding:
          EdgeInsets.fromLTRB(isCompact ? 20 : 32, 28, isCompact ? 20 : 32, 28),
      decoration: const BoxDecoration(
        gradient: LinearGradient(
          colors: <Color>[
            Color(0xFF2F55EE),
            Color(0xFF8B5CF6),
          ],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        boxShadow: <BoxShadow>[
          BoxShadow(
              color: _ScoreMetricDetailsPageState._glowShadow,
              blurRadius: 20,
              offset: Offset(0, 8)),
        ],
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Previous Score Cards',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: titleSize,
                    fontWeight: FontWeight.w800,
                  ),
                ),
                const SizedBox(height: 6),
                Text(
                  'A retrospective of your submitted score cards organised by month for $metricName.',
                  style: TextStyle(
                    color: Colors.white.withValues(alpha: 0.85),
                    fontSize: subtitleSize,
                    fontWeight: FontWeight.w600,
                    height: 1.35,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(width: 16),
          IconButton(
            onPressed: () => Navigator.of(context).pop(),
            style: IconButton.styleFrom(
              foregroundColor: Colors.white,
              backgroundColor: Colors.white.withValues(alpha: 0.12),
              padding: EdgeInsets.all(isCompact ? 8 : 10),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(14)),
            ),
            icon: const Icon(Icons.close_rounded),
          ),
        ],
      ),
    );
  }

  Widget _buildSubmissionCard(_ScorecardSubmission submission, int ordinal) {
    final metricName = _stringForKeys(submission.data,
            const ['metricTitle', 'metric', 'metric_name', 'title']) ??
        widget.metricTitle;
    final dateLabel = _formatFullDate(submission.submittedAt);
    final focusArea = _stringForKeys(
        submission.data, const ['focusArea', 'focus_area', 'focus']);
    final valueGenerated = _stringForKeys(
        submission.data, const ['valueGenerated', 'value_generated', 'value']);
    final note = _stringForKeys(
        submission.data, const ['note', 'notes', 'noteInput', 'reflection']);
    final mostValuable = _stringForKeys(
        submission.data, const ['mostValuable', 'most_valuable', 'highlight']);
    final envImprovements = _stringForKeys(
      submission.data,
      const [
        'envImprovements',
        'environmentImprovements',
        'environment_improvements'
      ],
    );

    final weeklyGoal = _numberForKeys(
        submission.data, const ['weeklyGoalHours', 'weekly_goal_hours']);
    final achievement = _numberForKeys(
        submission.data, const ['achievementPct', 'achievement_pct', 'score']);
    final duration = _stringForKeys(
        submission.data, const ['durationInput', 'duration', 'hours']);

    final highlightChips = <Widget>[];
    if (achievement != null) {
      highlightChips.add(_buildHighlightPill(
        icon: Icons.rocket_launch_outlined,
        label: 'Achievement',
        value: _formatPercentage(achievement),
        background: const Color(0xFFEFF2FF),
      ));
    }
    if (weeklyGoal != null) {
      highlightChips.add(_buildHighlightPill(
        icon: Icons.schedule_outlined,
        label: 'Weekly Goal',
        value: '${weeklyGoal.toStringAsFixed(weeklyGoal % 1 == 0 ? 0 : 1)} hrs',
        background: const Color(0xFFE8FBF4),
      ));
    }
    if (duration != null && duration.trim().isNotEmpty) {
      highlightChips.add(_buildHighlightPill(
        icon: Icons.timelapse_outlined,
        label: 'Duration',
        value: duration,
        background: const Color(0xFFFFF5EC),
      ));
    }

    final detailBlocks = <Widget>[];
    if (focusArea != null && focusArea.isNotEmpty) {
      detailBlocks.add(_buildDetailBlock(
        icon: Icons.explore_outlined,
        title: 'Focus Area',
        body: focusArea,
      ));
    }
    if (valueGenerated != null && valueGenerated.isNotEmpty) {
      detailBlocks.add(_buildDetailBlock(
        icon: Icons.auto_graph_outlined,
        title: 'Value Generated',
        body: valueGenerated,
      ));
    }
    if (mostValuable != null && mostValuable.isNotEmpty) {
      detailBlocks.add(_buildDetailBlock(
        icon: Icons.workspace_premium_outlined,
        title: 'Most Valuable Activity',
        body: mostValuable,
      ));
    }
    if (envImprovements != null && envImprovements.isNotEmpty) {
      detailBlocks.add(_buildDetailBlock(
        icon: Icons.eco_outlined,
        title: 'Environment Improvements',
        body: envImprovements,
      ));
    }

    final noteBlock = note == null || note.isEmpty
        ? null
        : Container(
            width: double.infinity,
            padding: const EdgeInsets.all(18),
            decoration: BoxDecoration(
              color: const Color(0xFFF8FAFF),
              borderRadius: BorderRadius.circular(18),
              border: Border.all(color: ScorecardPage._borderColor),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: const [
                    Icon(Icons.sticky_note_2_outlined,
                        size: 18, color: ScorecardPage._buttonBlue),
                    SizedBox(width: 8),
                    Text(
                      'Notes & Reflections',
                      style: TextStyle(
                        color: ScorecardPage._titleColor,
                        fontWeight: FontWeight.w700,
                        fontSize: 14,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 10),
                Text(
                  note,
                  style: const TextStyle(
                    color: ScorecardPage._mutedColor,
                    fontSize: 14,
                    height: 1.5,
                  ),
                ),
              ],
            ),
          );

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.fromLTRB(24, 22, 24, 24),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(22),
        border: Border.all(color: ScorecardPage._borderColor),
        boxShadow: const [
          BoxShadow(
              color: _ScoreMetricDetailsPageState._cardShadowColor,
              blurRadius: 16,
              offset: Offset(0, 8)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                decoration: BoxDecoration(
                  color: const Color(0xFF1D4ED8),
                  borderRadius: BorderRadius.circular(14),
                  boxShadow: const [
                    BoxShadow(
                        color: Color(0x332563EB),
                        blurRadius: 12,
                        offset: Offset(0, 6)),
                  ],
                ),
                child: Text(
                  '#$ordinal',
                  style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.w800,
                      fontSize: 16),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      metricName,
                      style: const TextStyle(
                        color: ScorecardPage._titleColor,
                        fontSize: 16,
                        fontWeight: FontWeight.w800,
                      ),
                    ),
                    const SizedBox(height: 6),
                    Wrap(
                      spacing: 10,
                      runSpacing: 10,
                      children: [
                        _buildMetaChip(Icons.event_outlined, dateLabel),
                        if (submission.data['status'] != null)
                          _buildMetaChip(
                            Icons.verified_outlined,
                            submission.data['status'].toString(),
                          ),
                        _buildMetaChip(
                            Icons.person_outline, _presenterLabel(submission)),
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 18),
          if (highlightChips.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(bottom: 18),
              child: Wrap(
                spacing: 12,
                runSpacing: 12,
                children: highlightChips,
              ),
            ),
          if (detailBlocks.isNotEmpty)
            Wrap(
              spacing: 16,
              runSpacing: 16,
              children: detailBlocks,
            ),
          if (noteBlock != null) ...[
            if (detailBlocks.isNotEmpty) const SizedBox(height: 18),
            noteBlock,
          ],
        ],
      ),
    );
  }

  Widget _buildMetaChip(IconData icon, String label) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: const Color(0xFFF1F5F9),
        borderRadius: BorderRadius.circular(999),
        border: Border.all(color: const Color(0xFFE2E8F0)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 16, color: ScorecardPage._mutedColor),
          const SizedBox(width: 6),
          Text(
            label,
            style: const TextStyle(
              color: ScorecardPage._titleColor,
              fontWeight: FontWeight.w600,
              fontSize: 12,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildHighlightPill({
    required IconData icon,
    required String label,
    required String value,
    required Color background,
  }) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: background,
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: background.withOpacity(0.45)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(icon, size: 18, color: const Color(0xFF1D4ED8)),
              const SizedBox(width: 8),
              Text(
                label,
                style: const TextStyle(
                  color: ScorecardPage._mutedColor,
                  fontWeight: FontWeight.w600,
                  fontSize: 12,
                ),
              ),
            ],
          ),
          const SizedBox(height: 6),
          Text(
            value,
            style: const TextStyle(
              color: ScorecardPage._titleColor,
              fontWeight: FontWeight.w700,
              fontSize: 15,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDetailBlock(
      {required IconData icon, required String title, required String body}) {
    return Container(
      constraints: const BoxConstraints(minWidth: 240, maxWidth: 340),
      padding: const EdgeInsets.all(18),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: ScorecardPage._borderColor),
        boxShadow: const [
          BoxShadow(
              color: Color(0x080F172A), blurRadius: 10, offset: Offset(0, 6)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(icon, size: 20, color: ScorecardPage._buttonBlue),
              const SizedBox(width: 10),
              Expanded(
                child: Text(
                  title,
                  style: const TextStyle(
                    color: ScorecardPage._titleColor,
                    fontWeight: FontWeight.w700,
                    fontSize: 14,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 10),
          Text(
            body,
            style: const TextStyle(
              color: ScorecardPage._mutedColor,
              fontSize: 13,
              height: 1.5,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 36),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(18),
              decoration: BoxDecoration(
                color: const Color(0xFFEFF6FF),
                borderRadius: BorderRadius.circular(20),
              ),
              child: const Icon(Icons.auto_stories_outlined,
                  color: Color(0xFF2563EB), size: 42),
            ),
            const SizedBox(height: 24),
            const Text(
              'No score cards yet',
              style: TextStyle(
                color: ScorecardPage._titleColor,
                fontSize: 18,
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Once you submit score cards for this account, they will appear here arranged by the month of submission.',
              textAlign: TextAlign.center,
              style: TextStyle(
                  color: ScorecardPage._mutedColor, fontSize: 14, height: 1.5),
            ),
            const SizedBox(height: 24),
            FilledButton(
              style: FilledButton.styleFrom(
                backgroundColor: ScorecardPage._buttonBlue,
                foregroundColor: Colors.white,
                padding:
                    const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
                textStyle: const TextStyle(fontWeight: FontWeight.w600),
              ),
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('Back to Scorecard'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildErrorState(Object? error) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 36),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(18),
              decoration: BoxDecoration(
                color: const Color(0xFFFFE4E6),
                borderRadius: BorderRadius.circular(20),
              ),
              child: const Icon(Icons.error_outline,
                  color: Color(0xFFDC2626), size: 40),
            ),
            const SizedBox(height: 24),
            const Text(
              'We couldn\'t load your score cards',
              style: TextStyle(
                color: ScorecardPage._titleColor,
                fontSize: 18,
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Please try again in a moment. If the issue persists, contact support with the error details below.',
              textAlign: TextAlign.center,
              style: TextStyle(
                  color: ScorecardPage._mutedColor, fontSize: 14, height: 1.5),
            ),
            const SizedBox(height: 12),
            if (error != null)
              Text(
                error.toString(),
                textAlign: TextAlign.center,
                style: const TextStyle(
                    color: ScorecardPage._mutedColor, fontSize: 12),
              ),
            const SizedBox(height: 20),
            OutlinedButton(
              style: OutlinedButton.styleFrom(
                padding:
                    const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
                foregroundColor: ScorecardPage._buttonBlue,
                side: const BorderSide(color: ScorecardPage._buttonBlue),
                textStyle: const TextStyle(fontWeight: FontWeight.w600),
              ),
              onPressed: () => setState(() => _future = _fetchSubmissions()),
              child: const Text('Retry'),
            ),
          ],
        ),
      ),
    );
  }

  List<_ScorecardMonthGroup> _groupByMonth(
      List<_ScorecardSubmission> submissions) {
    final groups = <String, List<_ScorecardSubmission>>{};
    for (final submission in submissions) {
      final monthLabel =
          '${_monthNames[submission.submittedAt.month - 1]} ${submission.submittedAt.year}';
      groups
          .putIfAbsent(monthLabel, () => <_ScorecardSubmission>[])
          .add(submission);
    }

    final sortedKeys = groups.keys.toList()
      ..sort((a, b) {
        final aParts = a.split(' ');
        final bParts = b.split(' ');
        final aMonth = _monthNames.indexOf(aParts.first) + 1;
        final bMonth = _monthNames.indexOf(bParts.first) + 1;
        final aYear = int.tryParse(aParts.last) ?? 0;
        final bYear = int.tryParse(bParts.last) ?? 0;
        final cmpYear = bYear.compareTo(aYear);
        if (cmpYear != 0) return cmpYear;
        return bMonth.compareTo(aMonth);
      });

    return [
      for (final key in sortedKeys)
        _ScorecardMonthGroup(
          label: key,
          submissions: groups[key]!
            ..sort((a, b) => b.submittedAt.compareTo(a.submittedAt)),
        ),
    ];
  }

  Future<List<_ScorecardSubmission>> _fetchSubmissions() async {
    final firestore = FirebaseFirestore.instance;
    final seen = <String>{};
    final submissions = <_ScorecardSubmission>[];

    Future<void> consume(Query<Map<String, dynamic>> query,
        {bool assumeOwnership = false}) async {
      try {
        final snapshot = await query.limit(50).get();
        for (final doc in snapshot.docs) {
          if (seen.contains(doc.reference.path)) continue;
          final data = doc.data();
          if (data.isEmpty) continue;

          final submittedAt = _coerceDateTime(
                data['submittedAt'] ??
                    data['submitted_at'] ??
                    data['createdAt'] ??
                    data['created_at'] ??
                    data['timestamp'] ??
                    data['submittedOn'] ??
                    data['submitted_on'],
              ) ??
              DateTime.now();

          final ownerMatches = assumeOwnership || _matchesOwner(data);
          if (!ownerMatches) continue;

          submissions.add(_ScorecardSubmission(
            id: doc.id,
            referencePath: doc.reference.path,
            submittedAt: submittedAt,
            data: Map<String, dynamic>.from(data),
          ));
          seen.add(doc.reference.path);
        }
      } on FirebaseException catch (e) {
        debugPrint('Scorecard query failed: ${e.message}');
      }
    }

    final userDoc = firestore.collection('users').doc(widget.uid);
    final userSubCollections = <Query<Map<String, dynamic>>>[
      userDoc.collection('scorecards'),
      userDoc.collection('scoreCardEntries'),
      userDoc.collection('scorecardEntries'),
      userDoc.collection('scorecard_submissions'),
    ];

    final rootCollections = <Query<Map<String, dynamic>>>[
      firestore.collection('scorecards').where('uid', isEqualTo: widget.uid),
      firestore.collection('scorecards').where('userId', isEqualTo: widget.uid),
      firestore
          .collection('scorecards')
          .where('user_id', isEqualTo: widget.uid),
      firestore
          .collection('scorecard_submissions')
          .where('uid', isEqualTo: widget.uid),
      firestore
          .collection('scorecard_entries')
          .where('uid', isEqualTo: widget.uid),
    ];

    if (widget.userEmail != null && widget.userEmail!.isNotEmpty) {
      final email = widget.userEmail!.toLowerCase();
      rootCollections.addAll([
        firestore.collection('scorecards').where('userEmail', isEqualTo: email),
        firestore
            .collection('scorecards')
            .where('user_email', isEqualTo: email),
        firestore
            .collection('scorecard_submissions')
            .where('userEmail', isEqualTo: email),
      ]);
    }

    for (final query in userSubCollections) {
      await consume(query, assumeOwnership: true);
    }

    for (final query in rootCollections) {
      await consume(query);
    }

    submissions.sort((a, b) => b.submittedAt.compareTo(a.submittedAt));
    return submissions;
  }

  bool _matchesOwner(Map<String, dynamic> data) {
    final candidates = <dynamic>[
      data['uid'],
      data['userId'],
      data['user_id'],
      data['owner'],
      data['ownerId'],
    ];
    if (candidates.any(
        (value) => value != null && value.toString().trim() == widget.uid)) {
      return true;
    }

    if (widget.userEmail != null && widget.userEmail!.isNotEmpty) {
      final email = widget.userEmail!.toLowerCase();
      final emailCandidates = <dynamic>[
        data['userEmail'],
        data['user_email'],
        data['email'],
      ];
      if (emailCandidates.any((value) =>
          value != null && value.toString().toLowerCase().trim() == email)) {
        return true;
      }
    }

    return data['uid'] == null &&
        data['userId'] == null &&
        data['user_id'] == null &&
        data['owner'] == null;
  }

  String _presenterLabel(_ScorecardSubmission submission) {
    final owner = _stringForKeys(
        submission.data, const ['coachName', 'ownerName', 'submittedBy']);
    if (owner != null && owner.isNotEmpty) {
      return owner;
    }
    if (widget.userEmail != null && widget.userEmail!.isNotEmpty) {
      return widget.userEmail!;
    }
    return 'You';
  }

  String _formatFullDate(DateTime date) {
    final month = _monthNames[date.month - 1];
    final day = date.day.toString().padLeft(2, '0');
    return '$month $day, ${date.year}';
  }

  String _formatPercentage(double value) {
    final normalized = value > 0 && value <= 1 ? value * 100 : value;
    return normalized % 1 == 0
        ? '${normalized.toStringAsFixed(0)}%'
        : '${normalized.toStringAsFixed(1)}%';
  }

  String? _stringForKeys(Map<String, dynamic> data, List<String> keys) {
    for (final key in keys) {
      final value = data[key];
      if (value is String && value.trim().isNotEmpty) {
        return value.trim();
      }
    }
    return null;
  }

  double? _numberForKeys(Map<String, dynamic> data, List<String> keys) {
    for (final key in keys) {
      final value = data[key];
      if (value is num) return value.toDouble();
      if (value is String) {
        final parsed = double.tryParse(value);
        if (parsed != null) return parsed;
      }
    }
    return null;
  }

  DateTime? _coerceDateTime(dynamic value) {
    if (value is Timestamp) return value.toDate();
    if (value is DateTime) return value;
    if (value is num) {
      if (value > 1000000000000) {
        return DateTime.fromMillisecondsSinceEpoch(value.toInt(), isUtc: true)
            .toLocal();
      }
      if (value > 0) {
        return DateTime.fromMillisecondsSinceEpoch((value * 1000).toInt(),
                isUtc: true)
            .toLocal();
      }
    }
    if (value is String) {
      final parsed = DateTime.tryParse(value);
      if (parsed != null) return parsed;
    }
    return null;
  }
}

class _ScorecardSubmission {
  _ScorecardSubmission({
    required this.id,
    required this.referencePath,
    required this.submittedAt,
    required this.data,
  });

  final String id;
  final String referencePath;
  final DateTime submittedAt;
  final Map<String, dynamic> data;
}

class _ScorecardMonthGroup {
  _ScorecardMonthGroup({required this.label, required this.submissions});

  final String label;
  final List<_ScorecardSubmission> submissions;
}

class _ScoreMetricData {
  const _ScoreMetricData({
    required this.title,
    required this.icon,
    required this.lastUpdated,
    required this.description,
    this.progress = 0,
  });

  final String title;
  final IconData icon;
  final String lastUpdated;
  final String description;
  final double progress;
}

// Data class for Delegation Success entries
class _DelegationEntry {
  DateTime? date;
  String taskProject = '';
  int timeSavedMinutes = 0;
  String delegationLevel = 'Select...';
  String outcome = 'Select outcome';

  Map<String, dynamic> toMap() => {
        'date': date != null ? Timestamp.fromDate(date!) : null,
        'taskProject': taskProject,
        'timeSavedMinutes': timeSavedMinutes,
        'delegationLevel': delegationLevel,
        'outcome': outcome,
      };
}

class _RightPeopleRightSeatsEntry {
  String teamMember = '';
  String currentRole = '';
  bool rightPerson = false;
  bool rightSeat = false;
  String actionNeeded = '';

  Map<String, dynamic> toMap() => {
        'teamMember': teamMember,
        'currentRole': currentRole,
        'rightPerson': rightPerson,
        'rightSeat': rightSeat,
        'actionNeeded': actionNeeded,
      };
}

class _GeniusTimeEntry {
  int week = 1;
  double goalHours = 0;
  double actualHours = 0;
  double percentOfWorkTime = 0;
  int energyLevel = 0;

  Map<String, dynamic> toMap() => {
        'week': week,
        'goalHours': goalHours,
        'actualHours': actualHours,
        'percentOfWorkTime': percentOfWorkTime,
        'energyLevel': energyLevel,
      };
}

// Small pill used in the hero to show quick context chips
class _MetricPill extends StatelessWidget {
  const _MetricPill({required this.label, required this.icon});

  final String label;
  final IconData icon;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.white.withValues(alpha: 0.12),
        borderRadius: BorderRadius.circular(999),
        border: Border.all(color: Colors.white.withValues(alpha: 0.28)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 16, color: Colors.white.withValues(alpha: 0.9)),
          const SizedBox(width: 8),
          Text(
            label,
            style: TextStyle(
              color: Colors.white.withValues(alpha: 0.95),
              fontWeight: FontWeight.w700,
              fontSize: 12,
            ),
          ),
        ],
      ),
    );
  }
}

// A single guidance row with an icon and supporting text
class _GuidanceRow extends StatelessWidget {
  const _GuidanceRow({required this.icon, required this.text});

  final IconData icon;
  final String text;

  @override
  Widget build(BuildContext context) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(icon, color: ScorecardPage._mutedColor, size: 18),
        const SizedBox(width: 10),
        Expanded(
          child: Text(
            text,
            style: const TextStyle(
                color: ScorecardPage._mutedColor,
                fontSize: 14,
                fontWeight: FontWeight.w600),
          ),
        ),
      ],
    );
  }
}

class ContentLibraryPage extends StatefulWidget {
  const ContentLibraryPage({super.key, this.isAdmin = false});

  final bool isAdmin;

  static const Color _titleColor = Color(0xFF111827);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE5E7EB);
  static const Color _buttonBlue = Color(0xFF2563EB);
  static const List<_LibraryFilterChipData> _filters = [
    _LibraryFilterChipData(
      label: 'All Content',
      backgroundColor: Colors.white,
      textColor: _titleColor,
      borderColor: _borderColor,
      filterKey: null,
    ),
    _LibraryFilterChipData(
        label: 'THINK', backgroundColor: Color(0xFF3CC7C9), filterKey: 'think'),
    _LibraryFilterChipData(
        label: 'KEEP', backgroundColor: Color(0xFF34D399), filterKey: 'keep'),
    _LibraryFilterChipData(
        label: 'ACCELERATE',
        backgroundColor: Color(0xFFF97316),
        filterKey: 'accelerate'),
    _LibraryFilterChipData(
        label: 'TRANSFORM',
        backgroundColor: Color(0xFFEC4899),
        filterKey: 'transform'),
    _LibraryFilterChipData(
        label: 'ABUNDANCE',
        backgroundColor: Color(0xFFDB2777),
        filterKey: 'abundance'),
    _LibraryFilterChipData(
        label: 'BREAKAWAY365 TOOLS',
        backgroundColor: Color(0xFF1F2937),
        textColor: Colors.white,
        filterKey: 'breakaway365 tools'),
    _LibraryFilterChipData(
        label: 'Expert Series',
        backgroundColor: Color(0xFF1F2937),
        textColor: Colors.white,
        filterKey: 'expert series'),
    // "Immersive Footage" should map to Firestore items that may be tagged
    // either as "Immersive Footage" or the older alias "implementation".
    _LibraryFilterChipData(
      label: 'Immersive Footage',
      backgroundColor: Color(0xFF3B82F6),
      textColor: Colors.white,
      filterKey: 'immersive footage',
    ),
  ];

  @override
  State<ContentLibraryPage> createState() => _ContentLibraryPageState();
}

class _ContentLibraryPageState extends State<ContentLibraryPage> {
  String? _activeFilterKey;
  bool _showAllContent = false;
  bool _showBreakawayTools = false;
  bool _showImmersiveFootage = false;
  bool _showFavorites = false;
  final TextEditingController _searchController = TextEditingController();
  String _searchQuery = '';
  bool _sortDescending = true; // Default to newest first

  @override
  void initState() {
    super.initState();
    _activeFilterKey = null;
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  void _handleFilterTap(String? filterKey) {
    final String? normalized = filterKey?.toLowerCase();
    debugPrint('üéØ Filter tapped: "$filterKey" ‚Üí normalized: "$normalized"');

    setState(() {
      if (normalized == 'breakaway365 tools') {
        final bool isTogglingOff =
            _showBreakawayTools && _activeFilterKey == normalized;
        _showBreakawayTools = !isTogglingOff;
        _showImmersiveFootage = false;
        _activeFilterKey = _showBreakawayTools ? normalized : null;
        debugPrint(
            '  ‚Üí Breakaway Tools view: $_showBreakawayTools, Active filter: $_activeFilterKey');
        return;
      }

      if (normalized == 'immersive footage') {
        final bool isTogglingOff =
            _showImmersiveFootage && _activeFilterKey == normalized;
        _showImmersiveFootage = !isTogglingOff;
        _showBreakawayTools = false;
        _activeFilterKey = _showImmersiveFootage ? normalized : null;
        debugPrint(
            '  ‚Üí Immersive Footage view: $_showImmersiveFootage, Active filter: $_activeFilterKey');
        return;
      }

      _showBreakawayTools = false;
      _showImmersiveFootage = false;

      if (normalized == null) {
        _activeFilterKey = null;
      } else if (_activeFilterKey == normalized) {
        _activeFilterKey = null;
      } else {
        _activeFilterKey = normalized;
      }

      if (normalized != null) {
        _showAllContent = false;
      }

      debugPrint('  ‚Üí Active filter key set to: "$_activeFilterKey"');
    });
  }

  void _toggleViewAllContent() {
    setState(() {
      _showAllContent = !_showAllContent;
    });
  }

  String _getDisplayLabelForFilter(String? filterKey) {
    if (filterKey == null) return 'Featured Content';
    final filter = ContentLibraryPage._filters.firstWhere(
      (f) => f.filterKey?.toLowerCase() == filterKey,
      orElse: () => ContentLibraryPage._filters[0],
    );
    return filter.label;
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final double horizontalPadding =
            constraints.maxWidth > 1240 ? 56.0 : 32.0;
        final double contentWidth =
            constraints.maxWidth - (horizontalPadding * 2);

        int columnsForWidth(double width) {
          if (width >= 1500) return 4;
          if (width >= 1100) return 3;
          if (width >= 780) return 2;
          return 1;
        }

        final int featuredColumns = columnsForWidth(contentWidth);
        final int continueColumns = columnsForWidth(contentWidth);
        final int allContentColumns = columnsForWidth(contentWidth);
        final bool stackSearchRow = contentWidth < 760;

        if (_showBreakawayTools) {
          return _BreakawayToolsView(
            maxWidth: constraints.maxWidth,
            horizontalPadding: horizontalPadding,
            activeFilterKey: _activeFilterKey,
            onFilterTap: _handleFilterTap,
            searchController: _searchController,
            searchQuery: _searchQuery,
            onSearchChanged: (value) =>
                setState(() => _searchQuery = value.trim()),
            isAdmin: widget.isAdmin,
          );
        }

        if (_showFavorites) {
          return _FavoritesView(
            horizontalPadding: horizontalPadding,
            columns: featuredColumns,
            isAdmin: widget.isAdmin,
            onBack: () => setState(() => _showFavorites = false),
          );
        }

        if (_showImmersiveFootage) {
          return _ImmersiveFootageView(
            maxWidth: constraints.maxWidth,
            horizontalPadding: horizontalPadding,
            activeFilterKey: _activeFilterKey,
            onFilterTap: _handleFilterTap,
            searchController: _searchController,
            searchQuery: _searchQuery,
            onSearchChanged: (value) =>
                setState(() => _searchQuery = value.trim()),
            isAdmin: widget.isAdmin,
          );
        }

        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                '365 Library',
                style: TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.w700,
                  color: ContentLibraryPage._titleColor,
                ),
              ),
              const SizedBox(height: 6),
              const Text(
                'Browse curated learning paths and expert sessions tailored to your growth goals',
                style: TextStyle(
                    color: ContentLibraryPage._mutedColor, fontSize: 16),
              ),
              const SizedBox(height: 28),
              SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child: Row(
                  children: ContentLibraryPage._filters.map(
                    (filter) {
                      final String? normalized =
                          filter.filterKey?.toLowerCase();
                      final bool isActive = normalized == 'breakaway365 tools'
                          ? _showBreakawayTools
                          : normalized == 'immersive footage'
                              ? _showImmersiveFootage
                              : normalized == null
                                  ? !_showBreakawayTools &&
                                      !_showImmersiveFootage &&
                                      _activeFilterKey == null
                                  : normalized == _activeFilterKey;
                      return Padding(
                        padding: const EdgeInsets.only(right: 12),
                        child: _FilterChip(
                          label: filter.label,
                          backgroundColor: filter.backgroundColor,
                          textColor: filter.textColor,
                          borderColor: filter.borderColor,
                          isActive: isActive,
                          onPressed: () => _handleFilterTap(filter.filterKey),
                        ),
                      );
                    },
                  ).toList(),
                ),
              ),
              const SizedBox(height: 24),
              if (stackSearchRow)
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Align(
                      alignment: Alignment.centerLeft,
                      child: _FavoritesButton(
                          onTap: () => setState(() => _showFavorites = true)),
                    ),
                    const SizedBox(height: 12),
                    SizedBox(
                      height: 52,
                      width: double.infinity,
                      child: TextField(
                        controller: _searchController,
                        onChanged: (value) =>
                            setState(() => _searchQuery = value.trim()),
                        decoration: InputDecoration(
                          hintText: 'Search for content...',
                          prefixIcon: const Icon(Icons.search,
                              color: ContentLibraryPage._mutedColor),
                          suffixIcon: _searchQuery.isNotEmpty
                              ? IconButton(
                                  tooltip: 'Clear search',
                                  onPressed: () {
                                    _searchController.clear();
                                    setState(() => _searchQuery = '');
                                  },
                                  icon: const Icon(Icons.close_rounded,
                                      color: ContentLibraryPage._mutedColor),
                                )
                              : null,
                          filled: true,
                          fillColor: Colors.white,
                          contentPadding: const EdgeInsets.symmetric(
                              horizontal: 18, vertical: 16),
                          enabledBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(16),
                            borderSide: const BorderSide(
                                color: ContentLibraryPage._borderColor),
                          ),
                          focusedBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(16),
                            borderSide: const BorderSide(
                                color: ContentLibraryPage._buttonBlue,
                                width: 1.4),
                          ),
                        ),
                      ),
                    ),
                  ],
                )
              else
                Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    _FavoritesButton(
                        onTap: () => setState(() => _showFavorites = true)),
                    const SizedBox(width: 16),
                    Expanded(
                      child: SizedBox(
                        height: 52,
                        child: TextField(
                          controller: _searchController,
                          onChanged: (value) =>
                              setState(() => _searchQuery = value.trim()),
                          decoration: InputDecoration(
                            hintText: 'Search for content...',
                            prefixIcon: const Icon(Icons.search,
                                color: ContentLibraryPage._mutedColor),
                            suffixIcon: _searchQuery.isNotEmpty
                                ? IconButton(
                                    tooltip: 'Clear search',
                                    onPressed: () {
                                      _searchController.clear();
                                      setState(() => _searchQuery = '');
                                    },
                                    icon: const Icon(Icons.close_rounded,
                                        color: ContentLibraryPage._mutedColor),
                                  )
                                : null,
                            filled: true,
                            fillColor: Colors.white,
                            contentPadding: const EdgeInsets.symmetric(
                                horizontal: 18, vertical: 16),
                            enabledBorder: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(16),
                              borderSide: const BorderSide(
                                  color: ContentLibraryPage._borderColor),
                            ),
                            focusedBorder: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(16),
                              borderSide: const BorderSide(
                                  color: ContentLibraryPage._buttonBlue,
                                  width: 1.4),
                            ),
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              const SizedBox(height: 32),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  _SectionTitle(
                      label: _getDisplayLabelForFilter(_activeFilterKey)),
                  if (_activeFilterKey == 'expert series')
                    TextButton.icon(
                      onPressed: () =>
                          setState(() => _sortDescending = !_sortDescending),
                      icon: Icon(
                        _sortDescending
                            ? Icons.arrow_downward
                            : Icons.arrow_upward,
                        size: 16,
                        color: ContentLibraryPage._buttonBlue,
                      ),
                      label: Text(
                        _sortDescending ? 'Newest First' : 'Oldest First',
                        style: const TextStyle(
                          color: ContentLibraryPage._buttonBlue,
                          fontSize: 14,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      style: TextButton.styleFrom(
                        padding: const EdgeInsets.symmetric(
                            horizontal: 12, vertical: 8),
                      ),
                    ),
                ],
              ),
              const SizedBox(height: 20),
              _FirestoreCourseGrid(
                columns: featuredColumns,
                limit: 10,
                filterKey: _activeFilterKey,
                searchQuery: _searchQuery,
                sortDescending: _sortDescending,
                isAdmin: widget.isAdmin,
                emptyMessage: 'No featured content available yet.',
                errorMessage: 'We couldn\'t load featured content right now.',
                onCardTap: (course, siblings) =>
                    _openCourseDetail(context, course, siblings),
                onDownloadTap: (course) =>
                    _attemptLibraryCourseDownload(context, course),
                onDeleteTap: widget.isAdmin
                    ? (course) => _confirmDeleteContent(context, course)
                    : null,
                onEditTap: widget.isAdmin
                    ? (course) => _showEditContentDialog(context, course)
                    : null,
              ),
              const SizedBox(height: 36),
              const _SectionTitle(label: 'Continue Learning'),
              const SizedBox(height: 20),
              _FirestoreCourseGrid(
                columns: continueColumns,
                limit: 3,
                filterKey: _activeFilterKey,
                searchQuery: _searchQuery,
                sortDescending: _sortDescending,
                isAdmin: widget.isAdmin,
                showContinueButton: true,
                emptyMessage: 'No courses to continue right now.',
                errorMessage:
                    'We couldn\'t load your learning queue right now.',
                onCardTap: (course, siblings) =>
                    _openCourseDetail(context, course, siblings),
                onDownloadTap: (course) =>
                    _attemptLibraryCourseDownload(context, course),
                onDeleteTap: widget.isAdmin
                    ? (course) => _confirmDeleteContent(context, course)
                    : null,
                onEditTap: widget.isAdmin
                    ? (course) => _showEditContentDialog(context, course)
                    : null,
              ),
              const SizedBox(height: 36),
              Row(
                children: [
                  const _SectionTitle(label: 'All Content'),
                  const SizedBox(width: 12),
                  TextButton(
                    onPressed: _toggleViewAllContent,
                    style: TextButton.styleFrom(
                      foregroundColor: ContentLibraryPage._buttonBlue,
                      textStyle: const TextStyle(fontWeight: FontWeight.w600),
                    ),
                    child: Text(_showAllContent ? 'Show Less' : 'View All'),
                  ),
                ],
              ),
              const SizedBox(height: 20),
              _FirestoreCourseGrid(
                columns: allContentColumns,
                limit: _showAllContent ? null : 20,
                filterKey: _activeFilterKey,
                searchQuery: _searchQuery,
                isAdmin: widget.isAdmin,
                emptyMessage: 'No content available yet.',
                errorMessage:
                    'We couldn\'t load the content catalog right now.',
                onCardTap: (course, siblings) =>
                    _openCourseDetail(context, course, siblings),
                onDownloadTap: (course) =>
                    _attemptLibraryCourseDownload(context, course),
                onDeleteTap: widget.isAdmin
                    ? (course) => _confirmDeleteContent(context, course)
                    : null,
                onEditTap: widget.isAdmin
                    ? (course) => _showEditContentDialog(context, course)
                    : null,
              ),
            ],
          ),
        );
      },
    );
  }

  void _openCourseDetail(BuildContext context, _LibraryCardData course,
      List<_LibraryCardData> siblings) {
    Navigator.of(context).push(
      MaterialPageRoute<void>(
        builder: (detailContext) => ContentDetailPage(
          course: course,
          relatedCourses:
              siblings.where((item) => item.id != course.id).toList(),
          onDownloadRequested: (selected) =>
              _attemptLibraryCourseDownload(detailContext, selected),
          isAdmin: widget.isAdmin,
        ),
      ),
    );
  }

  Future<void> _confirmDeleteContent(
      BuildContext context, _LibraryCardData course) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (dialogContext) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: const Text(
          'Delete Content',
          style: TextStyle(fontWeight: FontWeight.w700, fontSize: 20),
        ),
        content: Text(
          'Are you sure you want to delete "${course.title}"? This action cannot be undone.',
          style: const TextStyle(fontSize: 15, height: 1.5),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(dialogContext).pop(false),
            style: TextButton.styleFrom(
              foregroundColor: const Color(0xFF6B7280),
              textStyle:
                  const TextStyle(fontSize: 15, fontWeight: FontWeight.w600),
            ),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(dialogContext).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFFEF4444),
              foregroundColor: Colors.white,
              elevation: 0,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
            ),
            child: const Text('Delete',
                style: TextStyle(fontWeight: FontWeight.w700)),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await _deleteContent(context, course);
    }
  }

  Future<void> _deleteContent(
      BuildContext context, _LibraryCardData course) async {
    final messenger = ScaffoldMessenger.maybeOf(context);
    try {
      await FirebaseFirestore.instance
          .collection('video')
          .doc(course.id)
          .delete();
      messenger?.showSnackBar(
        SnackBar(
          content: Text('Successfully deleted "${course.title}"'),
          backgroundColor: const Color(0xFF10B981),
        ),
      );
    } catch (error) {
      debugPrint('Failed to delete content: $error');
      messenger?.showSnackBar(
        const SnackBar(
          content: Text('Failed to delete content. Please try again.'),
          backgroundColor: Color(0xFFEF4444),
        ),
      );
    }
  }

  void _showEditContentDialog(
      BuildContext context, _LibraryCardData course) {
    showDialog(
      context: context,
      barrierColor: Colors.black.withOpacity(0.5),
      builder: (context) {
        return Dialog(
          backgroundColor: Colors.transparent,
          insetPadding: const EdgeInsets.all(16),
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 800, maxHeight: 900),
            child: _AdminEditContentDialog(
              course: course,
              onCancel: () => Navigator.of(context).pop(),
              onSubmit: () {
                Navigator.of(context).pop();
                setState(() {}); // Trigger rebuild to refresh list
              },
            ),
          ),
        );
      },
    );
  }

  Future<void> _attemptCourseDownload(
      BuildContext context, _LibraryCardData course) async {
    await _attemptLibraryCourseDownload(context, course);
  }
}

class _BreakawayToolsView extends StatelessWidget {
  const _BreakawayToolsView({
    required this.maxWidth,
    required this.horizontalPadding,
    required this.activeFilterKey,
    required this.onFilterTap,
    required this.searchController,
    required this.searchQuery,
    required this.onSearchChanged,
    this.isAdmin = false,
  });

  final double maxWidth;
  final double horizontalPadding;
  final String? activeFilterKey;
  final ValueChanged<String?> onFilterTap;
  final TextEditingController searchController;
  final String searchQuery;
  final ValueChanged<String> onSearchChanged;
  final bool isAdmin;

  int _columnsForWidth(double width) {
    if (width >= 1400) return 4;
    if (width >= 1020) return 3;
    if (width >= 680) return 2;
    return 1;
  }

  @override
  Widget build(BuildContext context) {
    final double contentWidth = maxWidth - (horizontalPadding * 2);
    final int columns = _columnsForWidth(contentWidth);

    return SingleChildScrollView(
      padding:
          EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            '365 Library',
            style: TextStyle(
              fontSize: 24,
              fontWeight: FontWeight.w700,
              color: ContentLibraryPage._titleColor,
            ),
          ),
          const SizedBox(height: 6),
          const Text(
            'Browse curated learning paths and expert sessions tailored to your growth goals',
            style:
                TextStyle(color: ContentLibraryPage._mutedColor, fontSize: 16),
          ),
          const SizedBox(height: 28),
          Wrap(
            spacing: 12,
            runSpacing: 12,
            children: ContentLibraryPage._filters.map((filter) {
              final String? normalized = filter.filterKey?.toLowerCase();
              final bool isBreakawayChip = normalized == 'breakaway365 tools';
              final bool isActive = isBreakawayChip
                  ? true
                  : normalized == null
                      ? false
                      : normalized == activeFilterKey;
              return _FilterChip(
                label: filter.label,
                backgroundColor: filter.backgroundColor,
                textColor: filter.textColor,
                borderColor: filter.borderColor,
                isActive: isActive,
                onPressed: () => onFilterTap(filter.filterKey),
              );
            }).toList(),
          ),
          const SizedBox(height: 24),
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const _FavoritesButton(),
              const SizedBox(width: 16),
              Expanded(
                child: SizedBox(
                  height: 52,
                  child: TextField(
                    controller: searchController,
                    onChanged: onSearchChanged,
                    decoration: InputDecoration(
                      hintText: 'Search for content...',
                      prefixIcon: const Icon(Icons.search,
                          color: ContentLibraryPage._mutedColor),
                      suffixIcon: searchQuery.isNotEmpty
                          ? IconButton(
                              tooltip: 'Clear search',
                              onPressed: () {
                                searchController.clear();
                                onSearchChanged('');
                              },
                              icon: const Icon(Icons.close_rounded,
                                  color: ContentLibraryPage._mutedColor),
                            )
                          : null,
                      filled: true,
                      fillColor: Colors.white,
                      contentPadding: const EdgeInsets.symmetric(
                          horizontal: 18, vertical: 16),
                      enabledBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(16),
                        borderSide: const BorderSide(
                            color: ContentLibraryPage._borderColor),
                      ),
                      focusedBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(16),
                        borderSide: const BorderSide(
                            color: ContentLibraryPage._buttonBlue, width: 1.4),
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 32),
          const Text(
            'BREAKAWAY365 TOOLS',
            style: TextStyle(
              color: ContentLibraryPage._titleColor,
              fontSize: 18,
              fontWeight: FontWeight.w700,
              letterSpacing: 0.5,
            ),
          ),
          const SizedBox(height: 24),
          FutureBuilder<List<_LibraryCardData>>(
            future: _fetchBreakawayCourses(),
            builder: (context, snapshot) {
              if (snapshot.connectionState == ConnectionState.waiting) {
                return const Center(child: CircularProgressIndicator());
              }

              if (snapshot.hasError) {
                return const Text('Error loading courses');
              }

              final courses = snapshot.data ?? [];
              if (courses.isEmpty) {
                return const Text('No courses available');
              }

              return GridView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                itemCount: courses.length,
                gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: columns,
                  mainAxisSpacing: 24,
                  crossAxisSpacing: 24,
                  childAspectRatio: columns == 1 ? 1.2 : 1.05,
                ),
                itemBuilder: (context, index) {
                  final course = courses[index];
                  return _BreakawayCourseCard(
                    course: course,
                    onTap: () => _openCourse(context, course),
                  );
                },
              );
            },
          ),
        ],
      ),
    );
  }

  Future<List<_LibraryCardData>> _fetchBreakawayCourses() async {
    final firestore = FirebaseFirestore.instance;
    final List<_LibraryCardData> courses = [];

    try {
      final coursesSnapshot = await firestore
          .collection('courses')
          .where('topic', isEqualTo: 'BREAKAWAY365')
          .get();

      for (var doc in coursesSnapshot.docs) {
        final courseData = doc.data();
        final courseCard = _FirestoreCourseGrid._mapSnapshot(doc,
            paletteIndex: courses.length, showContinueButton: false);
        if (courseCard != null) {
          courses.add(courseCard);
        }
      }
    } catch (e) {
      debugPrint('Error fetching BreakAway courses: $e');
    }

    return courses;
  }

  void _openCourse(BuildContext context, _LibraryCardData course) {
    Navigator.of(context).push(
      MaterialPageRoute<void>(
        builder: (_) => _BreakawayCourseDetailPage(
          course: course,
          isAdmin: isAdmin,
        ),
      ),
    );
  }
}

class _BreakawayCourseCard extends StatelessWidget {
  const _BreakawayCourseCard({required this.course, required this.onTap});

  final _LibraryCardData course;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(20),
          border: Border.all(color: ContentLibraryPage._borderColor),
          boxShadow: const [
            BoxShadow(
              color: Color(0x0D0F172A),
              blurRadius: 18,
              offset: Offset(0, 10),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Thumbnail - Always use documentation.png asset
            ClipRRect(
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(20),
                topRight: Radius.circular(20),
              ),
              child: Container(
                height: 120,
                width: double.infinity,
                decoration: BoxDecoration(
                  color: course.thumbnailColor,
                ),
                child: Image.asset(
                  'assets/images/documentation.png',
                  fit: BoxFit.contain,
                  width: double.infinity,
                  height: 120,
                ),
              ),
            ),
            // Content
            Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    course.title,
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w700,
                      color: ContentLibraryPage._titleColor,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    course.subtitle,
                    style: const TextStyle(
                      fontSize: 14,
                      color: ContentLibraryPage._mutedColor,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 12),
                  Row(
                    children: course.meta
                        .map((meta) => Container(
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 8, vertical: 4),
                              margin: const EdgeInsets.only(right: 8),
                              decoration: BoxDecoration(
                                color: ContentLibraryPage._borderColor
                                    .withOpacity(0.1),
                                borderRadius: BorderRadius.circular(12),
                              ),
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Icon(meta.icon,
                                      size: 14,
                                      color: ContentLibraryPage._mutedColor),
                                  const SizedBox(width: 4),
                                  Text(
                                    meta.label,
                                    style: const TextStyle(
                                      fontSize: 12,
                                      color: ContentLibraryPage._mutedColor,
                                      fontWeight: FontWeight.w600,
                                    ),
                                  ),
                                ],
                              ),
                            ))
                        .toList(),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Immersive Footage view - similar to Breakaway Tools but shows content in a Files/Videos side-by-side layout
class _ImmersiveFootageView extends StatefulWidget {
  const _ImmersiveFootageView({
    required this.maxWidth,
    required this.horizontalPadding,
    required this.activeFilterKey,
    required this.onFilterTap,
    required this.searchController,
    required this.searchQuery,
    required this.onSearchChanged,
    this.isAdmin = false,
  });

  final double maxWidth;
  final double horizontalPadding;
  final String? activeFilterKey;
  final ValueChanged<String?> onFilterTap;
  final TextEditingController searchController;
  final String searchQuery;
  final ValueChanged<String> onSearchChanged;
  final bool isAdmin;

  @override
  State<_ImmersiveFootageView> createState() => _ImmersiveFootageViewState();
}

class _ImmersiveFootageViewState extends State<_ImmersiveFootageView> {
  late Future<_BreakawayFolderData> _dataFuture;

  @override
  void initState() {
    super.initState();
    _dataFuture = _fetchImmersiveContent();
  }

  void _refreshData() {
    setState(() {
      _dataFuture = _fetchImmersiveContent();
    });
  }

  Future<_BreakawayFolderData> _fetchImmersiveContent() async {
    final firestore = FirebaseFirestore.instance;
    final List<_LibraryCardData> courses = [];

    try {
      // Query from Courses collection for Immersive Footage content
      final coursesSnapshot = await firestore.collection('courses').get();
      debugPrint(
          'üì¶ Fetched ${coursesSnapshot.docs.length} courses for Immersive Footage');

      for (var i = 0; i < coursesSnapshot.docs.length; i++) {
        final courseDoc = coursesSnapshot.docs[i];
        final courseData = courseDoc.data();

        // Check if course matches "Immersive Footage" or "implementation" keywords
        final title =
            _FirestoreCourseGrid._readString(courseData['title']) ?? '';
        final topic =
            _FirestoreCourseGrid._readString(courseData['topic']) ?? '';
        final tag = _FirestoreCourseGrid._readString(courseData['tag']) ?? '';
        final badge =
            _FirestoreCourseGrid._readString(courseData['badge']) ?? '';
        final description =
            _FirestoreCourseGrid._readString(courseData['description']) ?? '';

        // Build search corpus for matching
        final searchCorpus =
            '$title $topic $tag $badge $description'.toLowerCase();

        // Check if matches Immersive Footage keywords
        final immersiveKeywords = [
          'immersive',
          'footage',
          'immersive footage',
          'implementation'
        ];
        bool matchesImmersive = false;
        for (final keyword in immersiveKeywords) {
          if (searchCorpus.contains(keyword)) {
            matchesImmersive = true;
            break;
          }
        }

        if (!matchesImmersive) continue;

        debugPrint('‚úÖ Course "$title" matches Immersive Footage filter');

        // Map the course document to _LibraryCardData (like THINK tab)
        final courseCard = _FirestoreCourseGrid._mapSnapshot(
          courseDoc,
          paletteIndex: courses.length,
          showContinueButton: false,
        );

        if (courseCard != null) {
          courses.add(courseCard);
        }
      }

      debugPrint('üìä Immersive Footage results: ${courses.length} courses');

      // Return courses instead of aggregated videos/files
      // The courses will be displayed as cards, and clicking them will show their videos/docs
      return _BreakawayFolderData(videos: courses, files: []);
    } catch (e) {
      debugPrint('‚ùå Error fetching Immersive Footage content: $e');
      rethrow;
    }
  }

  Future<void> _processDocsField(
      dynamic docsField,
      List<_LibraryCardData> files,
      int index,
      Map<String, dynamic> courseData) async {
    if (docsField is DocumentReference) {
      try {
        final docSnapshot = await docsField.get();
        if (docSnapshot.exists) {
          final docData = docSnapshot.data() as Map<String, dynamic>?;
          if (docData != null) {
            final card =
                _mapDocToCard(docSnapshot.id, docData, index, courseData);
            if (card != null) files.add(card);
          }
        }
      } catch (e) {
        debugPrint('‚ö†Ô∏è Error fetching doc reference: $e');
      }
    } else if (docsField is List) {
      for (final item in docsField) {
        if (item is DocumentReference) {
          try {
            final docSnapshot = await item.get();
            if (docSnapshot.exists) {
              final docData = docSnapshot.data() as Map<String, dynamic>?;
              if (docData != null) {
                final card = _mapDocToCard(
                    docSnapshot.id, docData, files.length, courseData);
                if (card != null) files.add(card);
              }
            }
          } catch (e) {
            debugPrint('‚ö†Ô∏è Error fetching doc from array: $e');
          }
        } else if (item is Map<String, dynamic>) {
          final card = _mapDocToCard(
              'doc_${files.length}', item, files.length, courseData);
          if (card != null) files.add(card);
        }
      }
    } else if (docsField is Map<String, dynamic>) {
      final card = _mapDocToCard('doc_$index', docsField, index, courseData);
      if (card != null) files.add(card);
    }
  }

  _LibraryCardData? _mapDocToCard(String id, Map<String, dynamic> data,
      int index, Map<String, dynamic> courseData) {
    final title = _FirestoreCourseGrid._readString(data['title']) ??
        _FirestoreCourseGrid._readString(data['name']) ??
        _FirestoreCourseGrid._readString(data['fileName']) ??
        _FirestoreCourseGrid._readString(courseData['title']) ??
        'Document';
    final description = _FirestoreCourseGrid._readString(data['description']) ??
        _FirestoreCourseGrid._readString(courseData['description']) ??
        '';
    final fileUrl = _FirestoreCourseGrid._readString(data['docUrl']) ??
        _FirestoreCourseGrid._readString(data['file_url']) ??
        _FirestoreCourseGrid._readString(data['fileUrl']) ??
        _FirestoreCourseGrid._readString(data['url']) ??
        _FirestoreCourseGrid._readString(data['downloadUrl']);
    final topic = _FirestoreCourseGrid._readString(courseData['topic']);

    return _LibraryCardData(
      id: id,
      title: title,
      subtitle: description,
      thumbnailColor: const Color(0xFF3B82F6),
      meta: const [
        _LibraryMetaData(icon: Icons.description_outlined, label: 'Document')
      ],
      tags: topic != null ? [topic] : ['Immersive Footage'],
      normalizedTags:
          topic != null ? [topic.toLowerCase()] : ['immersive footage'],
      showButton: false,
      downloadUrl: fileUrl,
      originalData: {...data, ...courseData},
    );
  }

  Future<void> _confirmDeleteItem(BuildContext context, _LibraryCardData item,
      {required bool isVideo}) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (dialogContext) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: Text(
          isVideo ? 'Delete Video' : 'Delete File',
          style: const TextStyle(fontWeight: FontWeight.w700, fontSize: 20),
        ),
        content: Text(
          'Are you sure you want to delete "${item.title}"? This action cannot be undone.',
          style: const TextStyle(fontSize: 15, height: 1.5),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(dialogContext).pop(false),
            style: TextButton.styleFrom(
              foregroundColor: const Color(0xFF6B7280),
              textStyle:
                  const TextStyle(fontSize: 15, fontWeight: FontWeight.w600),
            ),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(dialogContext).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFFEF4444),
              foregroundColor: Colors.white,
              elevation: 0,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
            ),
            child: const Text('Delete',
                style: TextStyle(fontWeight: FontWeight.w700)),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await _deleteItem(context, item, isVideo: isVideo);
    }
  }

  Future<void> _deleteItem(BuildContext context, _LibraryCardData item,
      {required bool isVideo}) async {
    final messenger = ScaffoldMessenger.maybeOf(context);
    try {
      // Determine collection based on item type
      final collection = isVideo ? 'video' : 'documents';
      await FirebaseFirestore.instance
          .collection(collection)
          .doc(item.id)
          .delete();
      messenger?.showSnackBar(
        SnackBar(
          content: Text('Successfully deleted "${item.title}"'),
          backgroundColor: const Color(0xFF10B981),
        ),
      );
      _refreshData();
    } catch (error) {
      debugPrint('Failed to delete ${isVideo ? 'video' : 'file'}: $error');
      messenger?.showSnackBar(
        SnackBar(
          content: Text(
              'Failed to delete ${isVideo ? 'video' : 'file'}. Please try again.'),
          backgroundColor: const Color(0xFFEF4444),
        ),
      );
    }
  }

  Future<void> _confirmDeleteContent(
      BuildContext context, _LibraryCardData course) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (dialogContext) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: const Text(
          'Delete Content',
          style: TextStyle(fontWeight: FontWeight.w700, fontSize: 20),
        ),
        content: Text(
          'Are you sure you want to delete "${course.title}"? This action cannot be undone.',
          style: const TextStyle(fontSize: 15, height: 1.5),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(dialogContext).pop(false),
            style: TextButton.styleFrom(
              foregroundColor: const Color(0xFF6B7280),
              textStyle:
                  const TextStyle(fontSize: 15, fontWeight: FontWeight.w600),
            ),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(dialogContext).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFFEF4444),
              foregroundColor: Colors.white,
              elevation: 0,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
            ),
            child: const Text('Delete',
                style: TextStyle(fontWeight: FontWeight.w700)),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await _deleteContent(context, course);
    }
  }

  Future<void> _deleteContent(
      BuildContext context, _LibraryCardData course) async {
    final messenger = ScaffoldMessenger.maybeOf(context);
    try {
      await FirebaseFirestore.instance
          .collection('courses')
          .doc(course.id)
          .delete();
      messenger?.showSnackBar(
        SnackBar(
          content: Text('Successfully deleted "${course.title}"'),
          backgroundColor: const Color(0xFF10B981),
        ),
      );
      _refreshData();
    } catch (error) {
      debugPrint('Failed to delete content: $error');
      messenger?.showSnackBar(
        const SnackBar(
          content: Text('Failed to delete content. Please try again.'),
          backgroundColor: Color(0xFFEF4444),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: EdgeInsets.fromLTRB(
          widget.horizontalPadding, 32, widget.horizontalPadding, 48),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            '365 Library',
            style: TextStyle(
              fontSize: 24,
              fontWeight: FontWeight.w700,
              color: ContentLibraryPage._titleColor,
            ),
          ),
          const SizedBox(height: 6),
          const Text(
            'Browse curated learning paths and expert sessions tailored to your growth goals',
            style:
                TextStyle(color: ContentLibraryPage._mutedColor, fontSize: 16),
          ),
          const SizedBox(height: 28),
          Wrap(
            spacing: 12,
            runSpacing: 12,
            children: ContentLibraryPage._filters.map((filter) {
              final String? normalized = filter.filterKey?.toLowerCase();
              final bool isImmersiveChip = normalized == 'immersive footage';
              final bool isActive =
                  isImmersiveChip ? true : normalized == widget.activeFilterKey;
              return _FilterChip(
                label: filter.label,
                backgroundColor: filter.backgroundColor,
                textColor: filter.textColor,
                borderColor: filter.borderColor,
                isActive: isActive,
                onPressed: () => widget.onFilterTap(filter.filterKey),
              );
            }).toList(),
          ),
          const SizedBox(height: 24),
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const _FavoritesButton(),
              const SizedBox(width: 16),
              Expanded(
                child: SizedBox(
                  height: 52,
                  child: TextField(
                    controller: widget.searchController,
                    onChanged: widget.onSearchChanged,
                    decoration: InputDecoration(
                      hintText: 'Search for content...',
                      prefixIcon: const Icon(Icons.search,
                          color: ContentLibraryPage._mutedColor),
                      suffixIcon: widget.searchQuery.isNotEmpty
                          ? IconButton(
                              tooltip: 'Clear search',
                              onPressed: () {
                                widget.searchController.clear();
                                widget.onSearchChanged('');
                              },
                              icon: const Icon(Icons.close_rounded,
                                  color: ContentLibraryPage._mutedColor),
                            )
                          : null,
                      filled: true,
                      fillColor: Colors.white,
                      contentPadding: const EdgeInsets.symmetric(
                          horizontal: 18, vertical: 16),
                      enabledBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(16),
                        borderSide: const BorderSide(
                            color: ContentLibraryPage._borderColor),
                      ),
                      focusedBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(16),
                        borderSide: const BorderSide(
                            color: ContentLibraryPage._buttonBlue, width: 1.4),
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 32),
          const Text(
            'Immersive Footage',
            style: TextStyle(
              color: ContentLibraryPage._titleColor,
              fontSize: 18,
              fontWeight: FontWeight.w700,
              letterSpacing: 0.5,
            ),
          ),
          const SizedBox(height: 8),
          const Text(
            'Browse the resources curated for immersive experiences.',
            style: TextStyle(
              color: ContentLibraryPage._mutedColor,
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 24),
          FutureBuilder<_BreakawayFolderData>(
            future: _dataFuture,
            builder: (context, snapshot) {
              if (snapshot.hasError) {
                return const _FirestoreStatusMessage(
                  icon: Icons.error_outline,
                  message:
                      'We couldn\'t load Immersive Footage content right now.',
                );
              }

              if (snapshot.connectionState == ConnectionState.waiting) {
                return const Center(child: CircularProgressIndicator());
              }

              final data = snapshot.data;
              final courses = data?.videos ?? [];

              if (data == null || courses.isEmpty) {
                return const _FirestoreStatusMessage(
                  icon: Icons.folder_off_outlined,
                  message: 'No Immersive Footage courses found yet.',
                );
              }

              void openCourse(BuildContext context, _LibraryCardData course,
                  List<_LibraryCardData> siblings) {
                // Open the course detail page with Documents and Videos tabs
                // instead of the video player (ContentDetailPage)
                Navigator.of(context).push(
                  MaterialPageRoute<void>(
                    builder: (detailContext) => _BreakawayCourseDetailPage(
                      course: course,
                      isAdmin: widget.isAdmin,
                    ),
                  ),
                );
              }

              return LayoutBuilder(
                builder: (context, constraints) {
                  final double contentWidth = constraints.maxWidth;

                  int columnsForWidth(double width) {
                    if (width >= 1500) return 4;
                    if (width >= 1100) return 3;
                    if (width >= 780) return 2;
                    return 1;
                  }

                  final int columns = columnsForWidth(contentWidth);

                  return Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        '${courses.length} course${courses.length == 1 ? '' : 's'} available',
                        style: const TextStyle(
                          color: ContentLibraryPage._mutedColor,
                          fontSize: 14,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 20),
                      _LibraryGrid(
                        items: courses,
                        columns: columns,
                        isAdmin: widget.isAdmin,
                        onCardTap: (course, siblings) =>
                            openCourse(context, course, siblings),
                        onDownloadTap: (course) =>
                            _attemptLibraryCourseDownload(context, course),
                        onDeleteTap: widget.isAdmin
                            ? (course) => _confirmDeleteContent(context, course)
                            : null,
                      ),
                    ],
                  );
                },
              );
            },
          ),
        ],
      ),
    );
  }
}

class _BreakawayToolFolderData {
  const _BreakawayToolFolderData(
      {required this.label, this.keywords = const []});

  final String label;
  final List<String> keywords;

  Set<String> get normalizedKeywords => {
        for (final keyword in keywords) keyword.toLowerCase(),
      };
}

class _BreakawayToolCard extends StatelessWidget {
  const _BreakawayToolCard({required this.data, required this.onTap});

  final _BreakawayToolFolderData data;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final borderRadius = BorderRadius.circular(20);

    return Material(
      color: Colors.transparent,
      borderRadius: borderRadius,
      child: InkWell(
        onTap: onTap,
        borderRadius: borderRadius,
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: borderRadius,
            border: Border.all(color: ContentLibraryPage._borderColor),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.03),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          child: Padding(
            padding: const EdgeInsets.fromLTRB(24, 32, 24, 24),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Image.asset(
                  'assets/images/documentation.png',
                  height: 88,
                  width: 88,
                  fit: BoxFit.contain,
                ),
                const SizedBox(height: 24),
                Text(
                  data.label,
                  textAlign: TextAlign.center,
                  style: const TextStyle(
                    color: ContentLibraryPage._titleColor,
                    fontSize: 16,
                    fontWeight: FontWeight.w700,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class BreakawayToolDetailPage extends StatelessWidget {
  const BreakawayToolDetailPage(
      {super.key, required this.folder, this.isAdmin = false});

  final _BreakawayToolFolderData folder;
  final bool isAdmin;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF7F8FB),
      body: SafeArea(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.fromLTRB(24, 24, 24, 0),
              child: Row(
                children: [
                  IconButton(
                    onPressed: () => Navigator.of(context).maybePop(),
                    icon: const Icon(Icons.arrow_back_ios_new_rounded),
                    style: IconButton.styleFrom(
                      foregroundColor: ContentLibraryPage._buttonBlue,
                      backgroundColor: Colors.white,
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(14)),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          folder.label,
                          style: const TextStyle(
                            fontSize: 24,
                            fontWeight: FontWeight.w700,
                            color: ContentLibraryPage._titleColor,
                          ),
                        ),
                        const SizedBox(height: 6),
                        const Text(
                          'Browse the resources curated for this toolkit.',
                          style: TextStyle(
                            color: ContentLibraryPage._mutedColor,
                            fontSize: 14,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 20),
            Expanded(
              child: Padding(
                padding: const EdgeInsets.fromLTRB(24, 0, 24, 24),
                child:
                    _BreakawayFolderContent(folder: folder, isAdmin: isAdmin),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _BreakawayCourseDetailPage extends StatefulWidget {
  const _BreakawayCourseDetailPage(
      {required this.course, this.isAdmin = false});

  final _LibraryCardData course;
  final bool isAdmin;

  @override
  State<_BreakawayCourseDetailPage> createState() =>
      _BreakawayCourseDetailPageState();
}

class _BreakawayCourseDetailPageState extends State<_BreakawayCourseDetailPage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  late Future<Map<String, List<_LibraryCardData>>> _contentFuture;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _contentFuture = _fetchCourseContent();
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  void _refreshContent() {
    setState(() {
      _contentFuture = _fetchCourseContent();
    });
  }

  Future<void> _confirmDeleteVideo(
      BuildContext context, _LibraryCardData video) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (dialogContext) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: const Text(
          'Delete Video',
          style: TextStyle(fontWeight: FontWeight.w700, fontSize: 20),
        ),
        content: Text(
          'Are you sure you want to delete "${video.title}"? This action cannot be undone.',
          style: const TextStyle(fontSize: 15, height: 1.5),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(dialogContext).pop(false),
            style: TextButton.styleFrom(
              foregroundColor: const Color(0xFF6B7280),
              textStyle:
                  const TextStyle(fontSize: 15, fontWeight: FontWeight.w600),
            ),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(dialogContext).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFFEF4444),
              foregroundColor: Colors.white,
              elevation: 0,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
            ),
            child: const Text('Delete',
                style: TextStyle(fontWeight: FontWeight.w700)),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await _deleteVideo(context, video);
    }
  }

  Future<void> _deleteVideo(
      BuildContext context, _LibraryCardData video) async {
    final messenger = ScaffoldMessenger.maybeOf(context);
    try {
      final firestore = FirebaseFirestore.instance;

      // Delete from video collection (try both 'video' and 'videos')
      try {
        await firestore.collection('video').doc(video.id).delete();
      } catch (_) {
        await firestore.collection('videos').doc(video.id).delete();
      }

      // Remove reference from course's videos array
      final courseRef = firestore.collection('courses').doc(widget.course.id);
      final videoRef = firestore.collection('video').doc(video.id);
      final videosRef = firestore.collection('videos').doc(video.id);

      await courseRef.update({
        'videos': FieldValue.arrayRemove([videoRef, videosRef, video.id]),
      });

      messenger?.showSnackBar(
        SnackBar(
          content: Text('Successfully deleted "${video.title}"'),
          backgroundColor: const Color(0xFF10B981),
        ),
      );
      _refreshContent();
    } catch (error) {
      debugPrint('Failed to delete video: $error');
      messenger?.showSnackBar(
        const SnackBar(
          content: Text('Failed to delete video. Please try again.'),
          backgroundColor: Color(0xFFEF4444),
        ),
      );
    }
  }

  Future<void> _confirmDeleteDocument(
      BuildContext context, _LibraryCardData doc) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (dialogContext) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: const Text(
          'Delete Document',
          style: TextStyle(fontWeight: FontWeight.w700, fontSize: 20),
        ),
        content: Text(
          'Are you sure you want to delete "${doc.title}"? This action cannot be undone.',
          style: const TextStyle(fontSize: 15, height: 1.5),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(dialogContext).pop(false),
            style: TextButton.styleFrom(
              foregroundColor: const Color(0xFF6B7280),
              textStyle:
                  const TextStyle(fontSize: 15, fontWeight: FontWeight.w600),
            ),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(dialogContext).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFFEF4444),
              foregroundColor: Colors.white,
              elevation: 0,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
            ),
            child: const Text('Delete',
                style: TextStyle(fontWeight: FontWeight.w700)),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await _deleteDocument(context, doc);
    }
  }

  Future<void> _deleteDocument(
      BuildContext context, _LibraryCardData doc) async {
    final messenger = ScaffoldMessenger.maybeOf(context);
    try {
      final firestore = FirebaseFirestore.instance;

      // Delete from documents collection
      await firestore.collection('documents').doc(doc.id).delete();

      // Remove reference from course's docs array
      final courseRef = firestore.collection('courses').doc(widget.course.id);
      final docRef = firestore.collection('documents').doc(doc.id);

      await courseRef.update({
        'docs': FieldValue.arrayRemove([docRef, doc.id]),
      });

      messenger?.showSnackBar(
        SnackBar(
          content: Text('Successfully deleted "${doc.title}"'),
          backgroundColor: const Color(0xFF10B981),
        ),
      );
      _refreshContent();
    } catch (error) {
      debugPrint('Failed to delete document: $error');
      messenger?.showSnackBar(
        const SnackBar(
          content: Text('Failed to delete document. Please try again.'),
          backgroundColor: Color(0xFFEF4444),
        ),
      );
    }
  }

  Future<Map<String, List<_LibraryCardData>>> _fetchCourseContent() async {
    final firestore = FirebaseFirestore.instance;
    final videos = <_LibraryCardData>[];
    final documents = <_LibraryCardData>[];

    try {
      // Get course document
      final courseDoc =
          await firestore.collection('courses').doc(widget.course.id).get();
      if (!courseDoc.exists) return {'videos': videos, 'documents': documents};

      final courseData = courseDoc.data() ?? {};

      // Query videos from 'videos' field
      final videosField = courseData['videos'];
      if (videosField is List) {
        for (final item in videosField) {
          if (item is DocumentReference) {
            try {
              final videoDoc = await item.get();
              if (videoDoc.exists) {
                final videoData = videoDoc.data() as Map<String, dynamic>?;
                if (videoData != null) {
                  final card = _mapVideoToCard(
                      videoDoc.id, videoData, videos.length, courseData);
                  if (card != null) videos.add(card);
                }
              }
            } catch (e) {
              debugPrint('Error fetching video: $e');
            }
          }
        }
      }

      // Query documents from 'docs' field
      final docsField = courseData['docs'];
      if (docsField is List) {
        for (final item in docsField) {
          if (item is DocumentReference) {
            try {
              final docSnapshot = await item.get();
              if (docSnapshot.exists) {
                final docData = docSnapshot.data() as Map<String, dynamic>?;
                if (docData != null) {
                  final card = _mapDocumentToCard(
                      docSnapshot.id, docData, documents.length, courseData);
                  if (card != null) documents.add(card);
                }
              }
            } catch (e) {
              debugPrint('Error fetching document: $e');
            }
          }
        }
      }
    } catch (e) {
      debugPrint('Error fetching course content: $e');
    }

    return {'videos': videos, 'documents': documents};
  }

  _LibraryCardData? _mapVideoToCard(String id, Map<String, dynamic> data,
      int index, Map<String, dynamic> courseData) {
    final title =
        data['title'] as String? ?? data['video_title'] as String? ?? 'Video';
    final description = data['description'] as String? ?? '';
    final videoUrl =
        data['video_url'] as String? ?? data['videoUrl'] as String?;
    final thumbnailUrl =
        data['thumbnailUrl'] as String? ?? data['thumbnail'] as String?;
    final topic = courseData['topic'] as String?;

    return _LibraryCardData(
      id: id,
      title: title,
      subtitle: description,
      thumbnailColor: _resolveColor(topic, index),
      meta: const [
        _LibraryMetaData(icon: Icons.play_circle_outline, label: 'Video')
      ],
      tags: topic != null ? [topic] : [],
      normalizedTags: topic != null ? [topic.toLowerCase()] : [],
      thumbnailUrl: thumbnailUrl,
      showButton: false,
      videoUrl: videoUrl,
      originalData: {...data, ...courseData},
    );
  }

  _LibraryCardData? _mapDocumentToCard(String id, Map<String, dynamic> data,
      int index, Map<String, dynamic> courseData) {
    final title =
        data['doc_name'] as String? ?? data['title'] as String? ?? 'Document';
    final description = data['description'] as String? ?? '';
    final docUrl = data['docUrl'] as String?;
    final topic = courseData['topic'] as String?;

    return _LibraryCardData(
      id: id,
      title: title,
      subtitle: description,
      thumbnailColor: _resolveColor(topic, index),
      meta: const [
        _LibraryMetaData(icon: Icons.description_outlined, label: 'Document')
      ],
      tags: topic != null ? [topic] : [],
      normalizedTags: topic != null ? [topic.toLowerCase()] : [],
      showButton: false,
      downloadUrl: docUrl,
      originalData: {...data, ...courseData},
    );
  }

  Color _resolveColor(String? topic, int index) {
    // Simple color resolution based on index
    final colors = [
      Colors.blue,
      Colors.green,
      Colors.orange,
      Colors.purple,
      Colors.red
    ];
    return colors[index % colors.length];
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF7F8FB),
      body: SafeArea(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.fromLTRB(24, 24, 24, 0),
              child: Row(
                children: [
                  IconButton(
                    onPressed: () => Navigator.of(context).maybePop(),
                    icon: const Icon(Icons.arrow_back_ios_new_rounded),
                    style: IconButton.styleFrom(
                      foregroundColor: ContentLibraryPage._buttonBlue,
                      backgroundColor: Colors.white,
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(14)),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          widget.course.title,
                          style: const TextStyle(
                            fontSize: 24,
                            fontWeight: FontWeight.w700,
                            color: ContentLibraryPage._titleColor,
                          ),
                        ),
                        const SizedBox(height: 6),
                        const Text(
                          'Browse videos and documents for this course.',
                          style: TextStyle(
                            color: ContentLibraryPage._mutedColor,
                            fontSize: 14,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 20),
            TabBar(
              controller: _tabController,
              tabs: const [
                Tab(text: 'Videos'),
                Tab(text: 'Documents'),
              ],
              labelColor: ContentLibraryPage._buttonBlue,
              unselectedLabelColor: ContentLibraryPage._mutedColor,
              indicatorColor: ContentLibraryPage._buttonBlue,
            ),
            Expanded(
              child: FutureBuilder<Map<String, List<_LibraryCardData>>>(
                future: _contentFuture,
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const Center(child: CircularProgressIndicator());
                  }

                  if (snapshot.hasError) {
                    return const Center(child: Text('Error loading content'));
                  }

                  final videos = snapshot.data?['videos'] ?? [];
                  final documents = snapshot.data?['documents'] ?? [];

                  return TabBarView(
                    controller: _tabController,
                    children: [
                      _buildContentList(videos, isVideo: true),
                      _buildContentList(documents, isVideo: false),
                    ],
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildContentList(List<_LibraryCardData> items,
      {required bool isVideo}) {
    if (items.isEmpty) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              isVideo ? Icons.videocam_off_outlined : Icons.folder_off_outlined,
              size: 48,
              color: ContentLibraryPage._mutedColor.withValues(alpha: 0.5),
            ),
            const SizedBox(height: 12),
            Text(
              'No ${isVideo ? 'videos' : 'documents'} available.',
              style: const TextStyle(
                  color: ContentLibraryPage._mutedColor, fontSize: 15),
            ),
          ],
        ),
      );
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        // Responsive: 1 column on narrow, 2 on medium, 3 on wide
        final crossAxisCount = constraints.maxWidth < 500
            ? 1
            : (constraints.maxWidth < 900 ? 2 : 3);
        return GridView.builder(
          padding: const EdgeInsets.all(24),
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: crossAxisCount,
            mainAxisSpacing: 16,
            crossAxisSpacing: 16,
            childAspectRatio: isVideo ? 1.4 : 2.2,
          ),
          itemCount: items.length,
          itemBuilder: (context, index) {
            final item = items[index];
            return isVideo
                ? _buildVideoCard(context, item)
                : _buildDocumentCard(context, item);
          },
        );
      },
    );
  }

  Widget _buildVideoCard(BuildContext context, _LibraryCardData item) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        borderRadius: BorderRadius.circular(14),
        onTap: () {
          Navigator.of(context).push(
            MaterialPageRoute<void>(
              builder: (_) => ContentDetailPage(
                course: widget.course,
                currentVideoId: item.id,
                isAdmin: widget.isAdmin,
              ),
            ),
          );
        },
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(14),
            border: Border.all(color: const Color(0xFFE5E7EB)),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withValues(alpha: 0.04),
                blurRadius: 8,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Thumbnail with play overlay
              Expanded(
                flex: 3,
                child: Stack(
                  fit: StackFit.expand,
                  children: [
                    ClipRRect(
                      borderRadius:
                          const BorderRadius.vertical(top: Radius.circular(13)),
                      child: item.thumbnailUrl != null
                          ? Image.network(
                              item.thumbnailUrl!,
                              fit: BoxFit.cover,
                              errorBuilder: (_, __, ___) =>
                                  _videoPlaceholder(item.thumbnailColor),
                            )
                          : _videoPlaceholder(item.thumbnailColor),
                    ),
                    // Play button overlay
                    Positioned.fill(
                      child: Container(
                        decoration: BoxDecoration(
                          borderRadius: const BorderRadius.vertical(
                              top: Radius.circular(13)),
                          gradient: LinearGradient(
                            begin: Alignment.topCenter,
                            end: Alignment.bottomCenter,
                            colors: [
                              Colors.transparent,
                              Colors.black.withValues(alpha: 0.3),
                            ],
                          ),
                        ),
                        child: Center(
                          child: Container(
                            width: 44,
                            height: 44,
                            decoration: BoxDecoration(
                              color: Colors.white.withValues(alpha: 0.95),
                              shape: BoxShape.circle,
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.black.withValues(alpha: 0.15),
                                  blurRadius: 8,
                                  offset: const Offset(0, 2),
                                ),
                              ],
                            ),
                            child: const Icon(
                              Icons.play_arrow_rounded,
                              color: ContentLibraryPage._buttonBlue,
                              size: 28,
                            ),
                          ),
                        ),
                      ),
                    ),
                    // Admin delete button
                    if (widget.isAdmin)
                      Positioned(
                        top: 8,
                        right: 8,
                        child: Material(
                          color: Colors.transparent,
                          child: InkWell(
                            onTap: () => _confirmDeleteVideo(context, item),
                            borderRadius: BorderRadius.circular(8),
                            child: Container(
                              padding: const EdgeInsets.all(6),
                              decoration: BoxDecoration(
                                color: Colors.white.withValues(alpha: 0.95),
                                borderRadius: BorderRadius.circular(8),
                                boxShadow: [
                                  BoxShadow(
                                    color: Colors.black.withValues(alpha: 0.1),
                                    blurRadius: 4,
                                    offset: const Offset(0, 2),
                                  ),
                                ],
                              ),
                              child: const Icon(
                                Icons.delete_outline_rounded,
                                color: Color(0xFFEF4444),
                                size: 18,
                              ),
                            ),
                          ),
                        ),
                      ),
                  ],
                ),
              ),
              // Title section
              Expanded(
                flex: 2,
                child: Padding(
                  padding: const EdgeInsets.fromLTRB(12, 10, 12, 10),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        item.title,
                        style: const TextStyle(
                          fontSize: 13,
                          fontWeight: FontWeight.w600,
                          color: ContentLibraryPage._titleColor,
                          height: 1.3,
                        ),
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                      const Spacer(),
                      Row(
                        children: [
                          Icon(
                            Icons.play_circle_outline_rounded,
                            size: 14,
                            color: ContentLibraryPage._mutedColor
                                .withValues(alpha: 0.7),
                          ),
                          const SizedBox(width: 4),
                          Expanded(
                            child: Text(
                              item.subtitle.isNotEmpty
                                  ? item.subtitle
                                  : 'Watch video',
                              style: TextStyle(
                                fontSize: 11,
                                color: ContentLibraryPage._mutedColor
                                    .withValues(alpha: 0.8),
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _videoPlaceholder(Color? color) {
    return Container(
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            color ?? const Color(0xFF3B82F6),
            (color ?? const Color(0xFF3B82F6)).withValues(alpha: 0.7),
          ],
        ),
      ),
      child: Center(
        child: Icon(
          Icons.videocam_rounded,
          size: 36,
          color: Colors.white.withValues(alpha: 0.8),
        ),
      ),
    );
  }

  Widget _buildDocumentCard(BuildContext context, _LibraryCardData item) {
    // Determine file type and icon/color
    final fileExt = _getFileExtension(item.downloadUrl ?? item.title);
    final (IconData icon, Color iconBgColor, Color iconColor) =
        _getDocIconStyle(fileExt);

    return Material(
      color: Colors.transparent,
      child: InkWell(
        borderRadius: BorderRadius.circular(12),
        onTap: () {
          if (item.downloadUrl != null) {
            _launchUrl(item.downloadUrl!);
          }
        },
        child: Container(
          padding: const EdgeInsets.all(14),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: const Color(0xFFE5E7EB)),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withValues(alpha: 0.03),
                blurRadius: 6,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Row(
            children: [
              // File type icon
              Container(
                width: 44,
                height: 44,
                decoration: BoxDecoration(
                  color: iconBgColor,
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Icon(icon, color: iconColor, size: 22),
              ),
              const SizedBox(width: 14),
              // Title and meta
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(
                      item.title,
                      style: const TextStyle(
                        fontSize: 13,
                        fontWeight: FontWeight.w600,
                        color: ContentLibraryPage._titleColor,
                        height: 1.3,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 6, vertical: 2),
                          decoration: BoxDecoration(
                            color: iconBgColor,
                            borderRadius: BorderRadius.circular(4),
                          ),
                          child: Text(
                            fileExt.toUpperCase(),
                            style: TextStyle(
                              fontSize: 9,
                              fontWeight: FontWeight.w700,
                              color: iconColor,
                              letterSpacing: 0.5,
                            ),
                          ),
                        ),
                        const Spacer(),
                        if (item.downloadUrl != null)
                          Icon(
                            Icons.download_rounded,
                            size: 16,
                            color: ContentLibraryPage._buttonBlue
                                .withValues(alpha: 0.8),
                          ),
                        if (widget.isAdmin) ...[
                          const SizedBox(width: 8),
                          InkWell(
                            onTap: () => _confirmDeleteDocument(context, item),
                            borderRadius: BorderRadius.circular(6),
                            child: Container(
                              padding: const EdgeInsets.all(4),
                              decoration: BoxDecoration(
                                color: const Color(0xFFFEE2E2),
                                borderRadius: BorderRadius.circular(6),
                              ),
                              child: const Icon(
                                Icons.delete_outline_rounded,
                                size: 16,
                                color: Color(0xFFEF4444),
                              ),
                            ),
                          ),
                        ],
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _getFileExtension(String path) {
    final lastDot = path.lastIndexOf('.');
    if (lastDot != -1 && lastDot < path.length - 1) {
      final ext = path.substring(lastDot + 1).toLowerCase();
      // Clean query params
      final queryIndex = ext.indexOf('?');
      return queryIndex != -1 ? ext.substring(0, queryIndex) : ext;
    }
    return 'doc';
  }

  (IconData, Color, Color) _getDocIconStyle(String ext) {
    switch (ext) {
      case 'pdf':
        return (
          Icons.picture_as_pdf_rounded,
          const Color(0xFFFEE2E2),
          const Color(0xFFDC2626)
        );
      case 'doc':
      case 'docx':
        return (
          Icons.description_rounded,
          const Color(0xFFDBEAFE),
          const Color(0xFF2563EB)
        );
      case 'xls':
      case 'xlsx':
        return (
          Icons.table_chart_rounded,
          const Color(0xFFDCFCE7),
          const Color(0xFF16A34A)
        );
      case 'ppt':
      case 'pptx':
        return (
          Icons.slideshow_rounded,
          const Color(0xFFFEF3C7),
          const Color(0xFFD97706)
        );
      case 'jpg':
      case 'jpeg':
      case 'png':
      case 'gif':
        return (
          Icons.image_rounded,
          const Color(0xFFF3E8FF),
          const Color(0xFF9333EA)
        );
      case 'mp4':
      case 'mov':
      case 'avi':
        return (
          Icons.video_file_rounded,
          const Color(0xFFE0E7FF),
          const Color(0xFF4F46E5)
        );
      default:
        return (
          Icons.insert_drive_file_rounded,
          const Color(0xFFF3F4F6),
          const Color(0xFF6B7280)
        );
    }
  }

  void _launchUrl(String url) async {
    try {
      await launchUrl(Uri.parse(url));
    } catch (e) {
      debugPrint('Error launching URL: $e');
    }
  }
}

class _BreakawayFolderContent extends StatefulWidget {
  const _BreakawayFolderContent({required this.folder, this.isAdmin = false});

  final _BreakawayToolFolderData folder;
  final bool isAdmin;

  @override
  State<_BreakawayFolderContent> createState() =>
      _BreakawayFolderContentState();
}

class _BreakawayFolderContentState extends State<_BreakawayFolderContent> {
  late Future<_BreakawayFolderData> _dataFuture;

  @override
  void initState() {
    super.initState();
    _dataFuture = _fetchFolderContent();
  }

  void _refreshData() {
    setState(() {
      _dataFuture = _fetchFolderContent();
    });
  }

  Future<void> _confirmDeleteContent(
      BuildContext context, _LibraryCardData course) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (dialogContext) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: const Text(
          'Delete Content',
          style: TextStyle(fontWeight: FontWeight.w700, fontSize: 20),
        ),
        content: Text(
          'Are you sure you want to delete "${course.title}"? This action cannot be undone.',
          style: const TextStyle(fontSize: 15, height: 1.5),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(dialogContext).pop(false),
            style: TextButton.styleFrom(
              foregroundColor: const Color(0xFF6B7280),
              textStyle:
                  const TextStyle(fontSize: 15, fontWeight: FontWeight.w600),
            ),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(dialogContext).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFFEF4444),
              foregroundColor: Colors.white,
              elevation: 0,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
            ),
            child: const Text('Delete',
                style: TextStyle(fontWeight: FontWeight.w700)),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await _deleteContent(context, course);
    }
  }

  Future<void> _deleteContent(
      BuildContext context, _LibraryCardData course) async {
    final messenger = ScaffoldMessenger.maybeOf(context);
    try {
      await FirebaseFirestore.instance
          .collection('courses')
          .doc(course.id)
          .delete();
      messenger?.showSnackBar(
        SnackBar(
          content: Text('Successfully deleted "${course.title}"'),
          backgroundColor: const Color(0xFF10B981),
        ),
      );
      _refreshData();
    } catch (error) {
      debugPrint('Failed to delete content: $error');
      messenger?.showSnackBar(
        const SnackBar(
          content: Text('Failed to delete content. Please try again.'),
          backgroundColor: Color(0xFFEF4444),
        ),
      );
    }
  }

  Future<void> _confirmDeleteItem(BuildContext context, _LibraryCardData item,
      {required bool isVideo}) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (dialogContext) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
        title: Text(
          isVideo ? 'Delete Video' : 'Delete File',
          style: const TextStyle(fontWeight: FontWeight.w700, fontSize: 20),
        ),
        content: Text(
          'Are you sure you want to delete "${item.title}"? This action cannot be undone.',
          style: const TextStyle(fontSize: 15, height: 1.5),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(dialogContext).pop(false),
            style: TextButton.styleFrom(
              foregroundColor: const Color(0xFF6B7280),
              textStyle:
                  const TextStyle(fontSize: 15, fontWeight: FontWeight.w600),
            ),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(dialogContext).pop(true),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFFEF4444),
              foregroundColor: Colors.white,
              elevation: 0,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
            ),
            child: const Text('Delete',
                style: TextStyle(fontWeight: FontWeight.w700)),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await _deleteItem(context, item, isVideo: isVideo);
    }
  }

  Future<void> _deleteItem(BuildContext context, _LibraryCardData item,
      {required bool isVideo}) async {
    final messenger = ScaffoldMessenger.maybeOf(context);
    try {
      // Determine collection based on item type
      final collection = isVideo ? 'video' : 'documents';
      await FirebaseFirestore.instance
          .collection(collection)
          .doc(item.id)
          .delete();
      messenger?.showSnackBar(
        SnackBar(
          content: Text('Successfully deleted "${item.title}"'),
          backgroundColor: const Color(0xFF10B981),
        ),
      );
      _refreshData();
    } catch (error) {
      debugPrint('Failed to delete ${isVideo ? 'video' : 'file'}: $error');
      messenger?.showSnackBar(
        SnackBar(
          content: Text(
              'Failed to delete ${isVideo ? 'video' : 'file'}. Please try again.'),
          backgroundColor: const Color(0xFFEF4444),
        ),
      );
    }
  }

  Future<_BreakawayFolderData> _fetchFolderContent() async {
    final firestore = FirebaseFirestore.instance;
    final List<_LibraryCardData> courses = [];

    try {
      // Query from Courses collection
      final coursesSnapshot = await firestore.collection('courses').get();
      debugPrint(
          'üì¶ Fetched ${coursesSnapshot.docs.length} courses from Courses collection');

      for (var i = 0; i < coursesSnapshot.docs.length; i++) {
        final courseDoc = coursesSnapshot.docs[i];
        final courseData = courseDoc.data();

        // Check if course matches the folder keywords
        final title = _FirestoreCourseGrid._readString(courseData['title']) ??
            _FirestoreCourseGrid._readString(courseData['course_name']) ??
            '';
        final topic =
            _FirestoreCourseGrid._readString(courseData['topic']) ?? '';
        final tag = _FirestoreCourseGrid._readString(courseData['tag']) ?? '';
        final description =
            _FirestoreCourseGrid._readString(courseData['description']) ?? '';

        // Build search corpus for matching
        final searchCorpus = '$title $topic $tag $description'.toLowerCase();

        // Check if matches folder keywords
        bool matchesFolder = false;
        for (final keyword in widget.folder.normalizedKeywords) {
          if (searchCorpus.contains(keyword)) {
            matchesFolder = true;
            break;
          }
        }

        if (!matchesFolder) continue;

        debugPrint('‚úÖ Course "$title" matches folder "${widget.folder.label}"');

        // Map the course document to _LibraryCardData
        final courseCard = _FirestoreCourseGrid._mapSnapshot(
          courseDoc,
          paletteIndex: courses.length,
          showContinueButton: false,
        );

        if (courseCard != null) {
          courses.add(courseCard);
        }
      }

      debugPrint('üìä Final results: ${courses.length} courses');

      // Return courses instead of aggregated videos/files
      // The courses will be displayed as cards, and clicking them will show their videos/docs
      return _BreakawayFolderData(videos: courses, files: []);
    } catch (e) {
      debugPrint('‚ùå Error fetching folder content: $e');
      rethrow;
    }
  }

  Future<void> _processVideoField(
      dynamic videoField,
      List<_LibraryCardData> videos,
      int index,
      Map<String, dynamic> courseData) async {
    if (videoField is DocumentReference) {
      try {
        final videoDoc = await videoField.get();
        if (videoDoc.exists) {
          final videoData = videoDoc.data() as Map<String, dynamic>?;
          if (videoData != null) {
            final card = _mapVideoToLibraryCard(
                videoDoc.id, videoData, index, courseData);
            if (card != null) videos.add(card);
          }
        }
      } catch (e) {
        debugPrint('‚ö†Ô∏è Error fetching video reference: $e');
      }
    } else if (videoField is List) {
      for (final item in videoField) {
        if (item is DocumentReference) {
          try {
            final videoDoc = await item.get();
            if (videoDoc.exists) {
              final videoData = videoDoc.data() as Map<String, dynamic>?;
              if (videoData != null) {
                final card = _mapVideoToLibraryCard(
                    videoDoc.id, videoData, videos.length, courseData);
                if (card != null) videos.add(card);
              }
            }
          } catch (e) {
            debugPrint('‚ö†Ô∏è Error fetching video from array: $e');
          }
        } else if (item is Map<String, dynamic>) {
          final card = _mapVideoToLibraryCard(
              'video_${videos.length}', item, videos.length, courseData);
          if (card != null) videos.add(card);
        }
      }
    } else if (videoField is Map<String, dynamic>) {
      final card =
          _mapVideoToLibraryCard('video_$index', videoField, index, courseData);
      if (card != null) videos.add(card);
    }
  }

  Future<void> _processDocsField(
      dynamic docsField,
      List<_LibraryCardData> files,
      int index,
      Map<String, dynamic> courseData) async {
    if (docsField is DocumentReference) {
      try {
        final docSnapshot = await docsField.get();
        if (docSnapshot.exists) {
          final docData = docSnapshot.data() as Map<String, dynamic>?;
          if (docData != null) {
            final card = _mapDocToLibraryCard(
                docSnapshot.id, docData, index, courseData);
            if (card != null) files.add(card);
          }
        }
      } catch (e) {
        debugPrint('‚ö†Ô∏è Error fetching doc reference: $e');
      }
    } else if (docsField is List) {
      for (final item in docsField) {
        if (item is DocumentReference) {
          try {
            final docSnapshot = await item.get();
            if (docSnapshot.exists) {
              final docData = docSnapshot.data() as Map<String, dynamic>?;
              if (docData != null) {
                final card = _mapDocToLibraryCard(
                    docSnapshot.id, docData, files.length, courseData);
                if (card != null) files.add(card);
              }
            }
          } catch (e) {
            debugPrint('‚ö†Ô∏è Error fetching doc from array: $e');
          }
        } else if (item is Map<String, dynamic>) {
          final card = _mapDocToLibraryCard(
              'doc_${files.length}', item, files.length, courseData);
          if (card != null) files.add(card);
        }
      }
    } else if (docsField is Map<String, dynamic>) {
      final card =
          _mapDocToLibraryCard('doc_$index', docsField, index, courseData);
      if (card != null) files.add(card);
    }
  }

  _LibraryCardData? _mapVideoToLibraryCard(String id, Map<String, dynamic> data,
      int index, Map<String, dynamic> courseData) {
    final title = _FirestoreCourseGrid._readString(data['title']) ??
        _FirestoreCourseGrid._readString(data['video_title']) ??
        _FirestoreCourseGrid._readString(data['name']) ??
        _FirestoreCourseGrid._readString(courseData['title']) ??
        'Video';
    final description = _FirestoreCourseGrid._readString(data['description']) ??
        _FirestoreCourseGrid._readString(data['video_description']) ??
        _FirestoreCourseGrid._readString(courseData['description']) ??
        '';
    final videoUrl = _FirestoreCourseGrid._readString(data['video_url']) ??
        _FirestoreCourseGrid._readString(data['videoUrl']) ??
        _FirestoreCourseGrid._readString(data['url']);
    final thumbnailUrl =
        _FirestoreCourseGrid._readString(data['thumbnailUrl']) ??
            _FirestoreCourseGrid._readString(data['thumbnail']);
    final topic = _FirestoreCourseGrid._readString(courseData['topic']);

    return _LibraryCardData(
      id: id,
      title: title,
      subtitle: description,
      thumbnailColor: _FirestoreCourseGrid._resolveColor(topic, index),
      meta: const [
        _LibraryMetaData(icon: Icons.play_circle_outline, label: 'Video')
      ],
      tags: topic != null ? [topic] : [],
      normalizedTags: topic != null ? [topic.toLowerCase()] : [],
      thumbnailUrl: thumbnailUrl,
      showButton: false,
      videoUrl: videoUrl,
      originalData: {...data, ...courseData},
    );
  }

  _LibraryCardData? _mapDocToLibraryCard(String id, Map<String, dynamic> data,
      int index, Map<String, dynamic> courseData) {
    final title = _FirestoreCourseGrid._readString(data['title']) ??
        _FirestoreCourseGrid._readString(data['name']) ??
        _FirestoreCourseGrid._readString(data['fileName']) ??
        _FirestoreCourseGrid._readString(courseData['title']) ??
        'Document';
    final description = _FirestoreCourseGrid._readString(data['description']) ??
        _FirestoreCourseGrid._readString(courseData['description']) ??
        '';
    final fileUrl = _FirestoreCourseGrid._readString(data['docUrl']) ??
        _FirestoreCourseGrid._readString(data['file_url']) ??
        _FirestoreCourseGrid._readString(data['fileUrl']) ??
        _FirestoreCourseGrid._readString(data['url']) ??
        _FirestoreCourseGrid._readString(data['downloadUrl']);
    final thumbnailUrl = _FirestoreCourseGrid._readString(data['thumbnailUrl']);
    final topic = _FirestoreCourseGrid._readString(courseData['topic']);

    return _LibraryCardData(
      id: id,
      title: title,
      subtitle: description,
      thumbnailColor: _FirestoreCourseGrid._resolveColor(topic, index),
      meta: const [
        _LibraryMetaData(icon: Icons.description_outlined, label: 'Document')
      ],
      tags: topic != null ? [topic] : [],
      normalizedTags: topic != null ? [topic.toLowerCase()] : [],
      thumbnailUrl: thumbnailUrl,
      showButton: false,
      downloadUrl: fileUrl,
      originalData: {...data, ...courseData},
    );
  }

  _LibraryCardData? _mapDirectUrlToLibraryCard(
      String id, String title, String description, String url,
      {required bool isVideo,
      required int index,
      required Map<String, dynamic> courseData}) {
    final topic = _FirestoreCourseGrid._readString(courseData['topic']);

    return _LibraryCardData(
      id: id,
      title: title,
      subtitle: description,
      thumbnailColor: _FirestoreCourseGrid._resolveColor(topic, index),
      meta: [
        _LibraryMetaData(
            icon: isVideo
                ? Icons.play_circle_outline
                : Icons.description_outlined,
            label: isVideo ? 'Video' : 'Document')
      ],
      tags: topic != null ? [topic] : [],
      normalizedTags: topic != null ? [topic.toLowerCase()] : [],
      showButton: false,
      videoUrl: isVideo ? url : null,
      downloadUrl: isVideo ? null : url,
      originalData: courseData,
    );
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<_BreakawayFolderData>(
      future: _dataFuture,
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          debugPrint('‚ùå Error in FutureBuilder: ${snapshot.error}');
          return const _FirestoreStatusMessage(
            icon: Icons.error_outline,
            message: 'We couldn\'t load the folder right now.',
          );
        }

        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }

        final data = snapshot.data;
        final courses = data?.videos ?? [];

        if (data == null || courses.isEmpty) {
          return _FirestoreStatusMessage(
            icon: Icons.folder_off_outlined,
            message: 'No courses found for ${widget.folder.label} yet.',
          );
        }

        void openCourse(BuildContext context, _LibraryCardData course,
            List<_LibraryCardData> siblings) {
          Navigator.of(context).push(
            MaterialPageRoute<void>(
              builder: (detailContext) => _BreakawayCourseDetailPage(
                course: course,
                isAdmin: widget.isAdmin,
              ),
            ),
          );
        }

        return LayoutBuilder(
          builder: (context, constraints) {
            final double contentWidth = constraints.maxWidth;

            int columnsForWidth(double width) {
              if (width >= 1500) return 4;
              if (width >= 1100) return 3;
              if (width >= 780) return 2;
              return 1;
            }

            final int columns = columnsForWidth(contentWidth);

            return SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    '${courses.length} course${courses.length == 1 ? '' : 's'} available',
                    style: const TextStyle(
                      color: ContentLibraryPage._mutedColor,
                      fontSize: 14,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: 20),
                  _LibraryGrid(
                    items: courses,
                    columns: columns,
                    isAdmin: widget.isAdmin,
                    onCardTap: (course, siblings) =>
                        openCourse(context, course, siblings),
                    onDownloadTap: (course) =>
                        _attemptLibraryCourseDownload(context, course),
                    onDeleteTap: widget.isAdmin
                        ? (course) => _confirmDeleteContent(context, course)
                        : null,
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }
}

class _BreakawayFolderData {
  const _BreakawayFolderData({required this.videos, required this.files});
  final List<_LibraryCardData> videos;
  final List<_LibraryCardData> files;
}

class _FolderListColumn extends StatelessWidget {
  const _FolderListColumn({
    required this.title,
    required this.items,
    required this.isVideo,
    required this.onItemTap,
    this.isAdmin = false,
    this.onDeleteTap,
  });

  final String title;
  final List<_LibraryCardData> items;
  final bool isVideo;
  final ValueChanged<_LibraryCardData> onItemTap;
  final bool isAdmin;
  final ValueChanged<_LibraryCardData>? onDeleteTap;

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: ContentLibraryPage._borderColor),
        boxShadow: const [
          BoxShadow(
              color: Color(0x0D0F172A), blurRadius: 18, offset: Offset(0, 10)),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 18),
            decoration: const BoxDecoration(
              border: Border(
                  bottom: BorderSide(color: ContentLibraryPage._borderColor)),
            ),
            child: Text(
              title,
              style: const TextStyle(
                color: ContentLibraryPage._titleColor,
                fontSize: 16,
                fontWeight: FontWeight.w700,
                letterSpacing: 0.4,
              ),
            ),
          ),
          if (items.isEmpty)
            const Padding(
              padding: EdgeInsets.symmetric(horizontal: 24, vertical: 28),
              child: Text(
                'No items yet. Check back soon!',
                style: TextStyle(
                  color: ContentLibraryPage._mutedColor,
                  fontSize: 14,
                ),
              ),
            )
          else if (!isVideo)
            // Files (notebook-style cards without separators)
            ListView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: items.length,
              padding: const EdgeInsets.symmetric(vertical: 8),
              itemBuilder: (context, index) => _FolderListItem(
                data: items[index],
                isVideo: isVideo,
                onTap: () => onItemTap(items[index]),
                isAdmin: isAdmin,
                onDeleteTap: onDeleteTap != null
                    ? () => onDeleteTap!(items[index])
                    : null,
              ),
            )
          else
            // Videos (list with separators)
            ListView.separated(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: items.length,
              separatorBuilder: (context, index) => const Divider(
                height: 1,
                color: ContentLibraryPage._borderColor,
              ),
              itemBuilder: (context, index) => _FolderListItem(
                data: items[index],
                isVideo: isVideo,
                onTap: () => onItemTap(items[index]),
                isAdmin: isAdmin,
                onDeleteTap: onDeleteTap != null
                    ? () => onDeleteTap!(items[index])
                    : null,
              ),
            ),
        ],
      ),
    );
  }
}

class _FolderListItem extends StatelessWidget {
  const _FolderListItem({
    required this.data,
    required this.onTap,
    required this.isVideo,
    this.isAdmin = false,
    this.onDeleteTap,
  });

  final _LibraryCardData data;
  final VoidCallback onTap;
  final bool isVideo;
  final bool isAdmin;
  final VoidCallback? onDeleteTap;

  Future<void> _downloadFile(BuildContext context) async {
    if (data.downloadUrl == null || data.downloadUrl!.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('No download URL available')),
      );
      return;
    }

    try {
      final url = Uri.parse(data.downloadUrl!);
      if (await canLaunchUrl(url)) {
        await launchUrl(url, mode: LaunchMode.externalApplication);
        debugPrint('üì• Downloading file: ${data.downloadUrl}');
      } else {
        throw 'Could not launch download URL';
      }
    } catch (e) {
      debugPrint('‚ùå Error downloading file: $e');
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to download file: $e')),
        );
      }
    }
  }

  Future<void> _previewFile(BuildContext context) async {
    if (data.downloadUrl == null || data.downloadUrl!.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('No preview URL available')),
      );
      return;
    }

    try {
      final url = Uri.parse(data.downloadUrl!);
      // Open in a new tab/window for preview
      final launched = await launchUrl(
        url,
        mode: LaunchMode.platformDefault,
        webOnlyWindowName: '_blank',
      );
      if (!launched) {
        throw 'Could not launch preview URL';
      }
      debugPrint('üëÅÔ∏è Opening file preview: ${data.downloadUrl}');
    } catch (e) {
      debugPrint('‚ùå Error opening file preview: $e');
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to open file preview: $e')),
        );
      }
    }
  }

  Future<void> _openVideo(BuildContext context) async {
    final videoUrl = data.videoUrl;
    if (videoUrl == null || videoUrl.isEmpty) {
      // Fallback to onTap which navigates to ContentDetailPage
      onTap();
      return;
    }

    try {
      final url = Uri.parse(videoUrl);
      // Open video in a new tab/window
      final launched = await launchUrl(
        url,
        mode: LaunchMode.platformDefault,
        webOnlyWindowName: '_blank',
      );
      if (!launched) {
        // Fallback to detail page
        onTap();
      }
      debugPrint('üé¨ Opening video: $videoUrl');
    } catch (e) {
      debugPrint('‚ùå Error opening video: $e');
      // Fallback to detail page
      onTap();
    }
  }

  @override
  Widget build(BuildContext context) {
    if (!isVideo) {
      // Notebook-style file item with download button
      return Container(
        margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        decoration: BoxDecoration(
          color: const Color(0xFFFFFBF0),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: const Color(0xFFE5E7EB)),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withValues(alpha: 0.05),
              blurRadius: 4,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: () => _previewFile(context),
            borderRadius: BorderRadius.circular(8),
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Row(
                children: [
                  Container(
                    width: 48,
                    height: 48,
                    decoration: BoxDecoration(
                      color: const Color(0xFFFEF3C7),
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(
                          color: const Color(0xFFFBBF24), width: 1.5),
                    ),
                    child: const Icon(Icons.description,
                        color: Color(0xFFD97706), size: 24),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          data.title,
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                          style: const TextStyle(
                            color: Color(0xFF1F2937),
                            fontSize: 15,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        if (data.subtitle.isNotEmpty)
                          Padding(
                            padding: const EdgeInsets.only(top: 4),
                            child: Text(
                              data.subtitle,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                              style: const TextStyle(
                                color: Color(0xFF6B7280),
                                fontSize: 12,
                              ),
                            ),
                          ),
                      ],
                    ),
                  ),
                  const SizedBox(width: 8),
                  IconButton(
                    onPressed: () => _downloadFile(context),
                    icon: const Icon(Icons.download_rounded),
                    color: ContentLibraryPage._buttonBlue,
                    tooltip: 'Download',
                    constraints:
                        const BoxConstraints(minWidth: 36, minHeight: 36),
                    padding: const EdgeInsets.all(6),
                  ),
                  if (isAdmin && onDeleteTap != null) ...[
                    const SizedBox(width: 4),
                    IconButton(
                      onPressed: onDeleteTap,
                      icon: const Icon(Icons.delete_outline, size: 20),
                      style: IconButton.styleFrom(
                        foregroundColor: const Color(0xFFEF4444),
                        backgroundColor: const Color(0xFFFEE2E2),
                        padding: const EdgeInsets.all(6),
                        minimumSize: const Size(36, 36),
                        shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8)),
                      ),
                      tooltip: 'Delete file',
                    ),
                  ],
                ],
              ),
            ),
          ),
        ),
      );
    }

    // Video item (original design)
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: () => _openVideo(context),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 18),
          child: Row(
            children: [
              Container(
                width: 48,
                height: 48,
                decoration: BoxDecoration(
                  color: ContentLibraryPage._buttonBlue.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: const Icon(Icons.play_circle_fill,
                    color: ContentLibraryPage._buttonBlue, size: 28),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      data.title,
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                      style: const TextStyle(
                        color: ContentLibraryPage._titleColor,
                        fontSize: 15,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    if (data.subtitle.isNotEmpty)
                      Padding(
                        padding: const EdgeInsets.only(top: 4),
                        child: Text(
                          data.subtitle,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: const TextStyle(
                            color: ContentLibraryPage._mutedColor,
                            fontSize: 12,
                          ),
                        ),
                      ),
                  ],
                ),
              ),
              // Play button to open video directly
              IconButton(
                onPressed: () => _openVideo(context),
                icon: const Icon(Icons.open_in_new_rounded),
                color: ContentLibraryPage._buttonBlue,
                tooltip: 'Open video',
                constraints: const BoxConstraints(minWidth: 36, minHeight: 36),
                padding: const EdgeInsets.all(6),
              ),
              if (isAdmin && onDeleteTap != null)
                IconButton(
                  onPressed: onDeleteTap,
                  icon: const Icon(Icons.delete_outline, size: 20),
                  style: IconButton.styleFrom(
                    foregroundColor: const Color(0xFFEF4444),
                    backgroundColor: const Color(0xFFFEE2E2),
                    padding: const EdgeInsets.all(8),
                    minimumSize: const Size(36, 36),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(8)),
                  ),
                  tooltip: 'Delete video',
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class _FavoritesButton extends StatelessWidget {
  const _FavoritesButton({this.onTap});

  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(16),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 14),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(16),
            border: Border.all(color: const Color(0xFFE5E7EB)),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withValues(alpha: 0.04),
                blurRadius: 8,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: const [
              Icon(Icons.favorite_border, color: Color(0xFFEF4444)),
              SizedBox(width: 8),
              Text(
                'Favorites',
                style: TextStyle(
                  color: ContentLibraryPage._titleColor,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _SectionTitle extends StatelessWidget {
  const _SectionTitle({required this.label});

  final String label;

  @override
  Widget build(BuildContext context) {
    return Text(
      label,
      style: const TextStyle(
        color: ContentLibraryPage._titleColor,
        fontSize: 20,
        fontWeight: FontWeight.w700,
      ),
    );
  }
}

class _FavoritesView extends StatelessWidget {
  const _FavoritesView({
    required this.horizontalPadding,
    required this.columns,
    required this.isAdmin,
    required this.onBack,
  });

  final double horizontalPadding;
  final int columns;
  final bool isAdmin;
  final VoidCallback onBack;

  @override
  Widget build(BuildContext context) {
    final uid = FirebaseAuth.instance.currentUser?.uid;

    return SingleChildScrollView(
      padding:
          EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              IconButton(
                onPressed: onBack,
                icon: const Icon(Icons.arrow_back_rounded),
                tooltip: 'Back to Library',
                style: IconButton.styleFrom(
                  backgroundColor: const Color(0xFFF3F4F6),
                  foregroundColor: ContentLibraryPage._titleColor,
                ),
              ),
              const SizedBox(width: 16),
              const Expanded(
                child: Text(
                  'My Favorites',
                  style: TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.w700,
                    color: ContentLibraryPage._titleColor,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          const Text(
            'Courses you\'ve saved for later',
            style:
                TextStyle(color: ContentLibraryPage._mutedColor, fontSize: 16),
          ),
          const SizedBox(height: 32),
          if (uid == null)
            Container(
              padding: const EdgeInsets.all(32),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(20),
                border: Border.all(color: ContentLibraryPage._borderColor),
              ),
              child: const Center(
                child: Text(
                  'Please sign in to view your favorites',
                  style: TextStyle(
                      color: ContentLibraryPage._mutedColor, fontSize: 15),
                ),
              ),
            )
          else
            StreamBuilder<DocumentSnapshot>(
              stream: FirebaseFirestore.instance
                  .collection('users')
                  .doc(uid)
                  .snapshots(),
              builder: (context, userSnapshot) {
                if (userSnapshot.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator());
                }

                final userData =
                    userSnapshot.data?.data() as Map<String, dynamic>?;
                final List<dynamic> favouriteCourseIds =
                    userData?['favouriteCourses'] as List<dynamic>? ?? [];

                if (favouriteCourseIds.isEmpty) {
                  return Container(
                    padding: const EdgeInsets.all(48),
                    decoration: BoxDecoration(
                      color: Colors.white,
                      borderRadius: BorderRadius.circular(20),
                      border:
                          Border.all(color: ContentLibraryPage._borderColor),
                    ),
                    child: Center(
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(Icons.favorite_border,
                              size: 64, color: Colors.grey.shade300),
                          const SizedBox(height: 16),
                          const Text(
                            'No favorites yet',
                            style: TextStyle(
                              color: ContentLibraryPage._titleColor,
                              fontSize: 18,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          const SizedBox(height: 8),
                          const Text(
                            'Save courses to access them quickly later',
                            style: TextStyle(
                                color: ContentLibraryPage._mutedColor,
                                fontSize: 14),
                          ),
                        ],
                      ),
                    ),
                  );
                }

                return StreamBuilder<QuerySnapshot>(
                  stream: FirebaseFirestore.instance
                      .collection('courses')
                      .where(FieldPath.documentId,
                          whereIn: favouriteCourseIds.take(10).toList())
                      .snapshots(),
                  builder: (context, coursesSnapshot) {
                    if (coursesSnapshot.connectionState ==
                        ConnectionState.waiting) {
                      return const Center(child: CircularProgressIndicator());
                    }

                    if (!coursesSnapshot.hasData ||
                        coursesSnapshot.data!.docs.isEmpty) {
                      return Container(
                        padding: const EdgeInsets.all(32),
                        decoration: BoxDecoration(
                          color: Colors.white,
                          borderRadius: BorderRadius.circular(20),
                          border: Border.all(
                              color: ContentLibraryPage._borderColor),
                        ),
                        child: const Center(
                          child: Text(
                            'Could not load favorite courses',
                            style: TextStyle(
                                color: ContentLibraryPage._mutedColor,
                                fontSize: 15),
                          ),
                        ),
                      );
                    }

                    final courses = coursesSnapshot.data!.docs.map((doc) {
                      final data = doc.data() as Map<String, dynamic>;
                      final topic = data['topic'] as String? ?? '';
                      final normalizedTopic = topic.toLowerCase().trim();
                      return _LibraryCardData(
                        id: doc.id,
                        title: data['title'] as String? ?? 'Untitled',
                        subtitle: data['subtitle'] as String? ?? '',
                        thumbnailColor: const Color(0xFF3B82F6),
                        thumbnailUrl: data['imageUrl'] as String? ??
                            data['thumbnail'] as String?,
                        meta: const [],
                        tags: topic.isNotEmpty ? [topic] : [],
                        normalizedTags:
                            normalizedTopic.isNotEmpty ? [normalizedTopic] : [],
                        originalData: data,
                        videoUrl: data['videoUrl'] as String?,
                        primaryTopicNormalized:
                            normalizedTopic.isNotEmpty ? normalizedTopic : null,
                      );
                    }).toList();

                    return _LibraryGrid(
                      items: courses,
                      columns: columns,
                      isAdmin: isAdmin,
                      onCardTap: (course, siblings) {
                        Navigator.of(context).push(
                          MaterialPageRoute(
                            builder: (ctx) => ContentDetailPage(
                              course: course,
                              relatedCourses: siblings,
                              isAdmin: isAdmin,
                            ),
                          ),
                        );
                      },
                    );
                  },
                );
              },
            ),
        ],
      ),
    );
  }
}

typedef _LibraryCardTap = void Function(
    _LibraryCardData data, List<_LibraryCardData> items);

class _LibraryGrid extends StatelessWidget {
  const _LibraryGrid({
    required this.items,
    required this.columns,
    this.isAdmin = false,
    this.onCardTap,
    this.onDownloadTap,
    this.onDeleteTap,
    this.onEditTap,
  });

  final List<_LibraryCardData> items;
  final int columns;
  final bool isAdmin;
  final _LibraryCardTap? onCardTap;
  final ValueChanged<_LibraryCardData>? onDownloadTap;
  final ValueChanged<_LibraryCardData>? onDeleteTap;
  final ValueChanged<_LibraryCardData>? onEditTap;

  @override
  Widget build(BuildContext context) {
    return GridView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: columns,
        mainAxisSpacing: 24,
        crossAxisSpacing: 24,
        childAspectRatio: columns > 1 ? 0.72 : 0.8,
      ),
      itemCount: items.length,
      itemBuilder: (context, index) {
        final item = items[index];
        return _LibraryCard(
          data: item,
          isAdmin: isAdmin,
          onTap: onCardTap == null ? null : () => onCardTap!(item, items),
          onDownloadTap:
              onDownloadTap == null ? null : () => onDownloadTap!(item),
          onDeleteTap: onDeleteTap == null ? null : () => onDeleteTap!(item),
          onEdit: onEditTap == null ? null : () => onEditTap!(item),
        );
      },
    );
  }
}

const Map<String, List<String>> _libraryKeywordSynonyms = {
  'think': ['think', 'thinking framework', 'think framework', 'think tools'],
  'keep': ['keep', 'keeping', 'keep leadership', 'keep culture'],
  'accelerate': ['accelerate', 'accelerator', 'acceleration'],
  'transform': ['transform', 'transformation'],
  'abundance': ['abundance', 'abundant'],
  'expert series': ['expert series'],
  'immersive footage': ['immersive footage', 'immersive', 'implementation'],
};

const Map<String, String> _libraryKeywordDisplayLabels = {
  'think': 'THINK',
  'keep': 'KEEP',
  'accelerate': 'ACCELERATE',
  'transform': 'TRANSFORM',
  'abundance': 'ABUNDANCE',
  'expert series': 'Expert Series',
  'immersive footage': 'Immersive Footage',
};

bool _stringContainsAny(String? source, Iterable<String> needles) {
  if (source == null) {
    return false;
  }
  final normalizedSource = source.toLowerCase();
  for (final needle in needles) {
    final candidate = needle.toLowerCase().trim();
    if (candidate.isEmpty) {
      continue;
    }
    if (normalizedSource.contains(candidate)) {
      return true;
    }
  }
  return false;
}

bool _isVideoLibraryContent(_LibraryCardData data) {
  if (data.videoUrl != null && data.videoUrl!.trim().isNotEmpty) {
    return true;
  }

  for (final meta in data.meta) {
    if (meta.icon == Icons.videocam_outlined ||
        meta.icon == Icons.live_tv_outlined) {
      return true;
    }
  }

  final mediaTypeKeys = ['format', 'mediaType', 'type'];
  for (final key in mediaTypeKeys) {
    final value = _FirestoreCourseGrid._readString(data.originalData[key]);
    if (value != null && value.toLowerCase().contains('video')) {
      return true;
    }
  }

  final streamKeys = [
    'streamUrl',
    'videoUrl',
    'video',
    'mediaUrl',
    'contentUrl',
    'lessonUrl'
  ];
  for (final key in streamKeys) {
    final value = _FirestoreCourseGrid._readString(data.originalData[key]);
    if (value != null && value.toLowerCase().startsWith('http')) {
      return true;
    }
  }

  return false;
}

bool _libraryCardMatchesFolder(
    _LibraryCardData data, _BreakawayToolFolderData folder) {
  final keywords = <String>{
    folder.label.toLowerCase(),
    ...folder.normalizedKeywords,
  };

  _libraryKeywordSynonyms.forEach((key, synonyms) {
    if (keywords.contains(key) || folder.label.toLowerCase().contains(key)) {
      keywords.add(key);
      keywords.addAll(synonyms.map((value) => value.toLowerCase()));
      final display = _libraryKeywordDisplayLabels[key];
      if (display != null) {
        keywords.add(display.toLowerCase());
      }
    }
  });

  if (data.normalizedTags
      .any((tag) => keywords.any((keyword) => tag.contains(keyword)))) {
    return true;
  }

  if (_stringContainsAny(data.title, keywords)) {
    return true;
  }
  if (_stringContainsAny(data.subtitle, keywords)) {
    return true;
  }
  if (_stringContainsAny(data.overlayTitle, keywords)) {
    return true;
  }
  if (_stringContainsAny(data.overlaySubtitle, keywords)) {
    return true;
  }

  if (data.primaryTopicNormalized != null &&
      keywords.contains(data.primaryTopicNormalized)) {
    return true;
  }
  if (data.badgeLabelNormalized != null &&
      keywords.contains(data.badgeLabelNormalized)) {
    return true;
  }

  final additionalFields = <String?>[
    _FirestoreCourseGrid._readString(data.originalData['folder']),
    _FirestoreCourseGrid._readString(data.originalData['collection']),
    _FirestoreCourseGrid._readString(data.originalData['category']),
    _FirestoreCourseGrid._readString(data.originalData['series']),
    _FirestoreCourseGrid._readString(data.originalData['topic']),
  ];
  for (final value in additionalFields) {
    if (_stringContainsAny(value, keywords)) {
      return true;
    }
  }

  return false;
}

class _FirestoreCourseGrid extends StatelessWidget {
  const _FirestoreCourseGrid({
    required this.columns,
    required this.emptyMessage,
    required this.errorMessage,
    this.limit,
    this.filterKey,
    this.searchQuery,
    this.sortDescending = true,
    this.showContinueButton = false,
    this.isAdmin = false,
    this.onCardTap,
    this.onDownloadTap,
    this.onDeleteTap,
    this.onEditTap,
  });

  final int columns;
  final int? limit;
  final String emptyMessage;
  final String errorMessage;
  final bool showContinueButton;
  final bool isAdmin;
  final String? filterKey;
  final String? searchQuery;
  final bool sortDescending;
  final _LibraryCardTap? onCardTap;
  final ValueChanged<_LibraryCardData>? onDownloadTap;
  final ValueChanged<_LibraryCardData>? onDeleteTap;
  final ValueChanged<_LibraryCardData>? onEditTap;

  static const Map<String, Color> _topicColors = {
    'think': Color(0xFF1E3A8A),
    'keep': Color(0xFF34D399),
    'accelerate': Color(0xFFF97316),
    'transform': Color(0xFFEC4899),
    'abundance': Color(0xFFDB2777),
    // Support both legacy "implementation" and the UI label "immersive footage".
    'implementation': Color(0xFF3B82F6),
    'immersive footage': Color(0xFF3B82F6),
    'expert series': Color(0xFF111827),
  };

  static const List<Color> _fallbackPalette = <Color>[
    Color(0xFF1E3A8A),
    Color(0xFFF3F4F6),
    Color(0xFFE0F2FE),
    Color(0xFFFCE7F3),
    Color(0xFFD1FAE5),
    Color(0xFFFEE2E2),
    Color(0xFF1E40AF),
    Color(0xFFE5E7EB),
  ];

  @override
  Widget build(BuildContext context) {
    final String? normalizedFilter = filterKey?.toLowerCase();
    debugPrint(
        'üîç _FirestoreCourseGrid: Building with filter: $normalizedFilter');

    return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
      stream: FirebaseFirestore.instance.collection('courses').snapshots(),
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          debugPrint('‚ùå Firestore Error: ${snapshot.error}');
          return _FirestoreStatusMessage(
            icon: Icons.error_outline,
            message: errorMessage,
          );
        }

        if (snapshot.connectionState == ConnectionState.waiting) {
          final int count = limit ?? (columns * 6);
          final double ar = columns > 1 ? 0.82 : 0.9;
          return ShimmerGrid(
            columns: columns,
            itemCount: count,
            aspectRatio: ar,
          );
        }

        final docs = snapshot.data?.docs ??
            const <QueryDocumentSnapshot<Map<String, dynamic>>>[];
        debugPrint(
            'üì¶ Total documents from courses collection: ${docs.length}');

        final filtered = docs.where((doc) {
          final topic = _readString(doc.data()['topic']);
          if (topic == null) {
            return true;
          }
          return topic.toUpperCase() != 'BREAKAWAY365';
        }).toList();

        debugPrint(
            '‚úÖ After filtering out BREAKAWAY365: ${filtered.length} documents');

        if (filtered.isEmpty) {
          debugPrint('‚ö†Ô∏è No documents found in courses collection');
          return _FirestoreStatusMessage(
            icon: Icons.menu_book_outlined,
            message: emptyMessage,
          );
        }

        final items = <_LibraryCardData>[];
        int totalDocs = filtered.length;
        int passedFilter = 0;
        int passedSearch = 0;

        // Log sample topics from first 5 documents
        debugPrint('üìù Sample topics from first 5 documents:');
        for (var i = 0; i < filtered.length && i < 5; i++) {
          final topic = _readString(filtered[i].data()['topic']);
          final badge = _readString(filtered[i].data()['badge']);
          final title = _readString(filtered[i].data()['title']);
          debugPrint(
              '  [$i] Topic: "$topic", Badge: "$badge", Title: "$title"');
        }

        for (var i = 0; i < filtered.length; i++) {
          final doc = filtered[i];
          final data = doc.data();

          // Check filter by topic field directly from Firestore
          if (normalizedFilter != null && normalizedFilter.isNotEmpty) {
            final topic = _readString(data['topic']);
            final badge =
                _readString(data['badge']) ?? _readString(data['series']);

            // Normalize topic for comparison - treat 'null' string as actual null
            String? topicNormalized = topic?.toLowerCase().trim();
            String? badgeNormalized = badge?.toLowerCase().trim();

            // Filter out items with null, empty, or 'null' string topics when filtering by specific category
            if (topicNormalized == null ||
                topicNormalized.isEmpty ||
                topicNormalized == 'null') {
              // Check if badge matches before excluding
              if (badgeNormalized == null ||
                  badgeNormalized.isEmpty ||
                  badgeNormalized == 'null') {
                continue; // Skip items without valid topic or badge
              }
            }

            bool matchesTopicFilter = false;

            // Check if topic matches the filter exactly
            if (topicNormalized != null &&
                topicNormalized != 'null' &&
                topicNormalized == normalizedFilter) {
              matchesTopicFilter = true;
            } else if (badgeNormalized != null &&
                badgeNormalized != 'null' &&
                badgeNormalized == normalizedFilter) {
              matchesTopicFilter = true;
            } else if (normalizedFilter == 'expert series' &&
                ((badgeNormalized != null &&
                        badgeNormalized != 'null' &&
                        badgeNormalized.contains('expert')) ||
                    (topicNormalized != null &&
                        topicNormalized != 'null' &&
                        topicNormalized.contains('expert')))) {
              matchesTopicFilter = true;
            } else if (normalizedFilter == 'immersive footage' &&
                ((topicNormalized != null &&
                        topicNormalized != 'null' &&
                        topicNormalized.contains('immersive')) ||
                    (badgeNormalized != null &&
                        badgeNormalized != 'null' &&
                        badgeNormalized.contains('immersive')))) {
              matchesTopicFilter = true;
            }

            if (!matchesTopicFilter) {
              continue;
            }
          }
          passedFilter++;

          final mapped = _mapSnapshot(
            doc,
            paletteIndex: i,
            showContinueButton: showContinueButton,
          );
          if (mapped == null) {
            continue;
          }

          if (!_matchesSearch(mapped, searchQuery)) {
            continue;
          }
          passedSearch++;

          items.add(mapped);
        }

        debugPrint(
            'üìä Filter Results: Total docs: $totalDocs, Passed filter: $passedFilter, Passed search: $passedSearch, Final items: ${items.length}');

        // Sort Expert Series by date (newest first by default)
        if (normalizedFilter == 'expert series' && items.isNotEmpty) {
          items.sort((a, b) {
            final aDate = _extractDateFromTitle(a.title) ??
                _extractDateFromData(a.originalData);
            final bDate = _extractDateFromTitle(b.title) ??
                _extractDateFromData(b.originalData);

            if (aDate == null && bDate == null) return 0;
            if (aDate == null) return 1;
            if (bDate == null) return -1;

            return sortDescending
                ? bDate.compareTo(aDate)
                : aDate.compareTo(bDate);
          });
        }

        // Apply limit after sorting
        final limitedItems = limit != null && items.length > limit!
            ? items.sublist(0, limit!)
            : items;

        if (limitedItems.isEmpty) {
          debugPrint('‚ö†Ô∏è No items match the current filter/search criteria');
          return _FirestoreStatusMessage(
            icon: Icons.menu_book_outlined,
            message: emptyMessage,
          );
        }

        return _LibraryGrid(
          items: limitedItems,
          columns: columns,
          isAdmin: isAdmin,
          onCardTap: onCardTap,
          onDownloadTap: onDownloadTap,
          onDeleteTap: onDeleteTap,
          onEditTap: onEditTap,
        );
      },
    );
  }

  static _LibraryCardData? _mapSnapshot(
    QueryDocumentSnapshot<Map<String, dynamic>> snapshot, {
    required int paletteIndex,
    required bool showContinueButton,
  }) {
    final data = snapshot.data();
    final title = _readString(data['title']) ??
        _readString(data['name']) ??
        _readString(data['video_title']);
    if (title == null) {
      return null;
    }
    final subtitle = _readString(data['subtitle']) ??
        _readString(data['description']) ??
        _readString(data['video_description']) ??
        'Description coming soon.';

    // Read topic from video collection (video_category field)
    final topic = _readString(data['topic']) ??
        _readString(data['video_category']) ??
        _readString(data['category']);
    final badge = _readString(data['badge']) ?? _readString(data['series']);
    final badgeLabel = badge ?? topic;

    final overlayTitle = _readString(data['overlayTitle']) ??
        _readString(data['headline']) ??
        title;
    final overlaySubtitle = _readString(data['overlaySubtitle']) ??
        _readString(data['summary']) ??
        title;

    final thumbnailUrl = _firstNonNullString([
      data['thumbnailUrl'],
      data['thumbnail'],
      data['imageUrl'],
      data['image'],
      data['coverImage'],
      data['cover'],
      data['heroImage'],
      data['video_thumbnail'],
    ]);

    // Only display ONE tag: the topic field from the 'courses' collection
    final tags = <String>[];
    final Set<String> normalizedTagSet = <String>{};

    void addTag(String label) {
      final normalized = label.trim().toLowerCase();
      if (normalized.isEmpty) {
        return;
      }
      if (normalizedTagSet.add(normalized)) {
        tags.add(label);
      }
    }

    // Only add the topic field as the single visible tag
    if (topic != null && topic.isNotEmpty) {
      addTag(topic);
    }

    final format = _readString(data['format']) ??
        _readString(data['mediaType']) ??
        _readString(data['type']);
    final durationValue =
        data['duration'] ?? data['durationMinutes'] ?? data['length'];
    final viewsValue = data['views'] ?? data['viewCount'];
    // Fetch likes from 'video' collection 'up_vote' field instead
    final upVote = data['up_vote'];
    final likesValue = upVote is int ? upVote.abs() : null;

    final meta = <_LibraryMetaData>[];
    if (format != null && format.isNotEmpty) {
      meta.add(_LibraryMetaData(icon: _iconForFormat(format), label: format));
    }
    final durationLabel = _formatDuration(durationValue);
    if (durationLabel != null) {
      meta.add(_LibraryMetaData(icon: Icons.access_time, label: durationLabel));
    }
    if (viewsValue != null) {
      meta.add(_LibraryMetaData(
          icon: Icons.remove_red_eye_outlined, label: viewsValue.toString()));
    }
    if (likesValue != null) {
      meta.add(_LibraryMetaData(
          icon: Icons.thumb_up_alt_outlined, label: likesValue.toString()));
    }
    if (meta.isEmpty) {
      meta.add(const _LibraryMetaData(
          icon: Icons.menu_book_outlined, label: 'Course'));
    }

    final corpusParts = <String>[
      title,
      subtitle,
      overlayTitle,
      overlaySubtitle,
      if (topic != null) topic,
      if (badge != null) badge,
      if (badgeLabel != null) badgeLabel,
      if (data['collection'] is String) data['collection'] as String,
      if (data['folder'] is String) data['folder'] as String,
    ];
    corpusParts.addAll(tags);

    final combinedCorpus = corpusParts
        .whereType<String>()
        .map((value) => value.toLowerCase())
        .join(' ');

    // Build normalized tags for filtering purposes (not displayed)
    final normalizedTags = <String>{...normalizedTagSet};

    // Add keyword synonyms for filtering (but not to visible tags)
    _libraryKeywordSynonyms.forEach((key, keywords) {
      final matchesKeyword = keywords.any(
        (keyword) =>
            keyword.isNotEmpty &&
            combinedCorpus.contains(keyword.toLowerCase()),
      );
      if (matchesKeyword) {
        normalizedTags.add(key.toLowerCase());
      }
    });

    if (badgeLabel != null) {
      normalizedTags.add(badgeLabel.toLowerCase());
    }
    if (topic != null) {
      normalizedTags.add(topic.toLowerCase());
    }

    final videoUrl = _firstNonNullString([
      data['videoUrl'],
      data['video'],
      data['streamUrl'],
      data['mediaUrl'],
      data['contentUrl'],
      data['lessonUrl'],
      data['url'],
      data['link'],
    ]);

    final downloadUrl = _firstNonNullString([
      data['downloadUrl'],
      data['downloadLink'],
      data['fileUrl'],
      data['resourceUrl'],
      data['videoDownloadUrl'],
      videoUrl,
    ]);

    return _LibraryCardData(
      id: snapshot.id,
      title: title,
      subtitle: subtitle,
      thumbnailColor: _resolveColor(topic, paletteIndex),
      meta: meta,
      overlayTitle: overlayTitle,
      overlaySubtitle: overlaySubtitle,
      badgeLabel: badgeLabel,
      tags: tags,
      normalizedTags: normalizedTags.toList(),
      thumbnailUrl: thumbnailUrl,
      showButton: showContinueButton,
      videoUrl: videoUrl,
      downloadUrl: downloadUrl,
      originalData: Map<String, dynamic>.from(data),
      primaryTopicNormalized: topic?.toLowerCase(),
      badgeLabelNormalized: badgeLabel?.toLowerCase(),
    );
  }

  static bool _matchesFilter(_LibraryCardData data, String? filterKey) {
    if (filterKey == null || filterKey.isEmpty) {
      return true;
    }

    final normalized = filterKey.toLowerCase();
    final candidates = <String>{normalized};

    // Add variations for common filter names
    if (normalized == 'abundance') {
      candidates.add('adundance');
    }
    if (normalized == 'expert series') {
      candidates.add('expertseries');
      candidates.add('expert');
    }
    // Ensure Immersive Footage filter matches legacy/alternate tags.
    if (normalized == 'immersive footage') {
      candidates.add('implementation');
      candidates.add('immersive');
      candidates.add('immersivefootage');
    }
    if (normalized == 'implementation') {
      candidates.add('immersive footage');
    }

    // Check normalized tags
    for (final tag in data.normalizedTags) {
      if (candidates.contains(tag)) {
        return true;
      }
      for (final candidate in candidates) {
        final tagNormalized = tag.replaceAll(' ', '').toLowerCase();
        final candidateNormalized = candidate.replaceAll(' ', '').toLowerCase();
        if (tagNormalized == candidateNormalized ||
            tagNormalized.contains(candidateNormalized) ||
            candidateNormalized.contains(tagNormalized)) {
          return true;
        }
      }
    }

    // Check primary topic
    if (data.primaryTopicNormalized != null) {
      for (final candidate in candidates) {
        final topicNormalized =
            data.primaryTopicNormalized!.replaceAll(' ', '');
        final candidateNormalized = candidate.replaceAll(' ', '');
        if (topicNormalized == candidateNormalized ||
            topicNormalized.contains(candidateNormalized) ||
            candidateNormalized.contains(topicNormalized)) {
          return true;
        }
      }
    }

    // Check badge label
    if (data.badgeLabelNormalized != null) {
      for (final candidate in candidates) {
        final badgeNormalized = data.badgeLabelNormalized!.replaceAll(' ', '');
        final candidateNormalized = candidate.replaceAll(' ', '');
        if (badgeNormalized == candidateNormalized ||
            badgeNormalized.contains(candidateNormalized) ||
            candidateNormalized.contains(badgeNormalized)) {
          return true;
        }
      }
    }

    return false;
  }

  static bool _matchesSearch(_LibraryCardData data, String? searchQuery) {
    if (searchQuery == null || searchQuery.isEmpty) {
      return true;
    }

    final query = searchQuery.toLowerCase();

    // Search in title
    if (data.title.toLowerCase().contains(query)) {
      return true;
    }

    // Search in subtitle
    if (data.subtitle.toLowerCase().contains(query)) {
      return true;
    }

    // Search in tags
    for (final tag in data.normalizedTags) {
      if (tag.contains(query)) {
        return true;
      }
    }

    // Search in badge label
    if (data.badgeLabel != null &&
        data.badgeLabel!.toLowerCase().contains(query)) {
      return true;
    }

    return false;
  }

  static IconData _iconForFormat(String format) {
    final normalized = format.toLowerCase();
    if (normalized.contains('video')) {
      return Icons.videocam_outlined;
    }
    if (normalized.contains('audio') || normalized.contains('podcast')) {
      return Icons.podcasts_outlined;
    }
    if (normalized.contains('worksheet') || normalized.contains('pdf')) {
      return Icons.insert_drive_file_outlined;
    }
    if (normalized.contains('webinar')) {
      return Icons.live_tv_outlined;
    }
    return Icons.menu_book_outlined;
  }

  static String? _formatDuration(dynamic value) {
    if (value == null) {
      return null;
    }
    if (value is num) {
      if (value <= 0) {
        return null;
      }
      final isWhole = value % 1 == 0;
      final formatted = isWhole
          ? value.toInt().toString()
          : value.toStringAsFixed(1).replaceFirst(RegExp(r'\.0$'), '');
      return '$formatted mins';
    }
    final label = value.toString().trim();
    return label.isEmpty ? null : label;
  }

  static String? _readString(dynamic value) {
    if (value == null) {
      return null;
    }
    if (value is String) {
      final trimmed = value.trim();
      return trimmed.isEmpty ? null : trimmed;
    }
    final fallback = value.toString().trim();
    return fallback.isEmpty ? null : fallback;
  }

  static DateTime? _extractDateFromTitle(String title) {
    // Try to parse dates from titles like "Expert Series - January 2024" or "Jan 2024"
    final monthNames = {
      'january': 1,
      'jan': 1,
      'february': 2,
      'feb': 2,
      'march': 3,
      'mar': 3,
      'april': 4,
      'apr': 4,
      'may': 5,
      'june': 6,
      'jun': 6,
      'july': 7,
      'jul': 7,
      'august': 8,
      'aug': 8,
      'september': 9,
      'sep': 9,
      'sept': 9,
      'october': 10,
      'oct': 10,
      'november': 11,
      'nov': 11,
      'december': 12,
      'dec': 12,
    };

    final normalized = title.toLowerCase();

    // Try to find year (4 digits)
    final yearMatch = RegExp(r'\b(20\d{2})\b').firstMatch(normalized);
    if (yearMatch == null) return null;

    final year = int.parse(yearMatch.group(1)!);

    // Try to find month
    for (final entry in monthNames.entries) {
      if (normalized.contains(entry.key)) {
        return DateTime(year, entry.value, 1);
      }
    }

    return null;
  }

  static DateTime? _extractDateFromData(Map<String, dynamic> data) {
    // Try to extract date from various date fields
    final dateFields = [
      'createdAt',
      'timestamp',
      'uploadDate',
      'date',
      'published'
    ];

    for (final field in dateFields) {
      final value = data[field];
      if (value == null) continue;

      if (value is Timestamp) {
        return value.toDate();
      } else if (value is String) {
        try {
          return DateTime.parse(value);
        } catch (_) {
          // Ignore parse errors
        }
      }
    }

    return null;
  }

  static List<String> _readStringList(dynamic value) {
    if (value is Iterable) {
      final result = <String>[];
      for (final item in value) {
        final resolved = _readString(item);
        if (resolved != null &&
            resolved.isNotEmpty &&
            !result.contains(resolved)) {
          result.add(resolved);
        }
      }
      return result;
    }
    final single = _readString(value);
    if (single != null) {
      return [single];
    }
    return <String>[];
  }

  static Color _resolveColor(String? topic, int index) {
    if (topic != null) {
      final lookup = _topicColors[topic.toLowerCase()];
      if (lookup != null) {
        return lookup;
      }
    }
    if (_fallbackPalette.isEmpty) {
      return const Color(0xFF1E3A8A);
    }
    return _fallbackPalette[index % _fallbackPalette.length];
  }

  static String? _firstNonNullString(Iterable<dynamic> values) {
    for (final value in values) {
      final resolved = _readString(value);
      if (resolved != null) {
        return resolved;
      }
    }
    return null;
  }
}

class ContentDetailPage extends StatefulWidget {
  const ContentDetailPage({
    super.key,
    required this.course,
    this.relatedCourses = const <_LibraryCardData>[],
    this.onDownloadRequested,
    this.onNavigate,
    this.originalCourseId,
    this.currentVideoId,
    this.isAdmin = false,
  });

  final _LibraryCardData course;
  final List<_LibraryCardData> relatedCourses;
  final ValueChanged<_LibraryCardData>? onDownloadRequested;
  final ValueChanged<NavigationItem>? onNavigate;
  final String?
      originalCourseId; // Original course ID when viewing a module video
  final String?
      currentVideoId; // ID of the currently playing video for highlighting
  final bool isAdmin;

  @override
  State<ContentDetailPage> createState() => _ContentDetailPageState();
}

class _ContentDetailPageState extends State<ContentDetailPage> {
  // Track the current playing video - starts with the course passed in
  late _LibraryCardData _currentCourse;
  String? _currentVideoId;

  // Admin user info for sidebar (only used when isAdmin is true)
  String _adminDisplayName = '';
  String _adminRoleLabel = 'Admin';
  String? _adminProfileImageUrl;

  @override
  void initState() {
    super.initState();
    _currentCourse = widget.course;
    _currentVideoId = widget.currentVideoId ?? widget.course.id;
    if (widget.isAdmin) {
      _loadAdminUserInfo();
    }
  }

  Future<void> _loadAdminUserInfo() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return;
    try {
      final doc = await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .get();
      if (!mounted) return;
      final data = doc.data();
      if (data != null) {
        final firstName = data['firstName'] as String? ?? '';
        final lastName = data['lastName'] as String? ?? '';
        final displayName = data['display_name'] as String? ??
            data['displayName'] as String? ??
            data['username'] as String? ??
            '';
        final role = data['role'] as String? ?? 'Admin';
        setState(() {
          _adminDisplayName = displayName.isNotEmpty
              ? displayName
              : '$firstName $lastName'.trim();
          if (_adminDisplayName.isEmpty) {
            _adminDisplayName = user.email ?? 'Admin';
          }
          _adminRoleLabel = role;
          _adminProfileImageUrl =
              data['profileImageUrl'] as String? ?? data['photoURL'] as String?;
        });
      }
    } catch (e) {
      debugPrint('Error loading admin user info: $e');
    }
  }

  // Callback to update the video when a module is clicked
  Future<void> _updateVideoFromModule(_CourseModuleInfo module) async {
    try {
      // Query Firestore collections to find the matching video document
      final videoCollection = FirebaseFirestore.instance.collection('video');
      final videosCollection = FirebaseFirestore.instance.collection('videos');

      QuerySnapshot<Map<String, dynamic>> querySnapshot;

      // Try to find by exact title match first in 'video' collection
      querySnapshot = await videoCollection
          .where('title', isEqualTo: module.title)
          .limit(1)
          .get();

      // If not found, try 'videos' collection
      if (querySnapshot.docs.isEmpty) {
        querySnapshot = await videosCollection
            .where('title', isEqualTo: module.title)
            .limit(1)
            .get();
      }

      // If still not found and we have a videoUrl, try searching by videoUrl
      if (querySnapshot.docs.isEmpty && module.videoUrl != null) {
        querySnapshot = await videoCollection
            .where('videoUrl', isEqualTo: module.videoUrl)
            .limit(1)
            .get();
      }

      if (querySnapshot.docs.isEmpty && module.videoUrl != null) {
        querySnapshot = await videosCollection
            .where('videoUrl', isEqualTo: module.videoUrl)
            .limit(1)
            .get();
      }

      if (querySnapshot.docs.isEmpty) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Content details not available yet.')),
          );
        }
        return;
      }

      // Convert the Firestore document to _LibraryCardData
      final doc = querySnapshot.docs.first;
      final cardData = _FirestoreCourseGrid._mapSnapshot(
        doc,
        paletteIndex: 0,
        showContinueButton: false,
      );

      if (cardData == null) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Unable to load content details.')),
          );
        }
        return;
      }

      // Update the state to show the new video
      if (mounted) {
        setState(() {
          _currentCourse = cardData;
          _currentVideoId = cardData.id;
        });
      }
    } catch (e) {
      debugPrint('Error updating video from module: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
              content: Text('An error occurred while loading content.')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // Always enable the Download button; resolution happens on press via Firestore lookup.
    const bool canDownload = true;
    // Use the original course for modules extraction, not the current playing video
    final originalCourse = widget.originalCourseId != null
        ? widget.course // Keep original course data
        : widget.course;
    final modules = _extractModules(originalCourse);
    final suggestions = widget.relatedCourses
        .where((item) => item.id != _currentCourse.id)
        .take(6)
        .toList();
    final media = MediaQuery.of(context);
    final double minHeight =
        math.max(0, media.size.height - media.padding.vertical - 80);
    // Show sidebar on wide screens: admin sidebar for admins, member sidebar for members
    final bool showSidebar = media.size.width >= 1024;

    return Scaffold(
      backgroundColor: const Color(0xFFF7F8FB),
      body: Row(
        children: [
          if (showSidebar && widget.isAdmin)
            _AdminSidebar(
              displayName: _adminDisplayName,
              roleLabel: _adminRoleLabel,
              profileImageUrl: _adminProfileImageUrl,
              selectedSection: AdminSection.contentLibrary,
              onSectionSelected: (section) {
                // Navigate back to admin dashboard and switch to selected section
                Navigator.of(context).pop();
              },
              onLogout: () async {
                await FirebaseAuth.instance.signOut();
                if (context.mounted) {
                  Navigator.of(context).pushAndRemoveUntil(
                    MaterialPageRoute<void>(
                        builder: (_) => const AuthLandingPage()),
                    (route) => false,
                  );
                }
              },
            )
          else if (showSidebar && !widget.isAdmin)
            SizedBox(
              width: 280,
              child: _SideNavigation(
                selectedItem: NavigationItem.contentLibrary,
                onItemSelected: (item) {
                  if (item != NavigationItem.contentLibrary) {
                    widget.onNavigate?.call(item);
                    Navigator.of(context).pop();
                  } else {
                    // Always navigate back to content library when clicked
                    Navigator.of(context).pop();
                  }
                },
                onLogout: () async {
                  await FirebaseAuth.instance.signOut();
                  if (context.mounted) {
                    Navigator.of(context).pushAndRemoveUntil(
                      MaterialPageRoute<void>(
                          builder: (_) => const AuthLandingPage()),
                      (route) => false,
                    );
                  }
                },
              ),
            ),
          Expanded(
            child: SafeArea(
              child: SingleChildScrollView(
                padding: const EdgeInsets.fromLTRB(32, 32, 0, 48),
                child: Container(
                  width: double.infinity,
                  constraints: BoxConstraints(minHeight: minHeight),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Padding(
                        padding: const EdgeInsets.only(right: 32),
                        child: Row(
                          children: [
                            TextButton.icon(
                              onPressed: () => Navigator.of(context).maybePop(),
                              style: TextButton.styleFrom(
                                foregroundColor: ContentLibraryPage._buttonBlue,
                              ),
                              icon: const Icon(Icons.arrow_back_ios_new_rounded,
                                  size: 16),
                              label: const Text('Back to Library'),
                            ),
                            const SizedBox(width: 24),
                            Expanded(
                              child: SizedBox(
                                height: 48,
                                child: TextField(
                                  decoration: InputDecoration(
                                    hintText: 'Search for videos',
                                    prefixIcon: const Icon(Icons.search,
                                        color: ContentLibraryPage._mutedColor),
                                    filled: true,
                                    fillColor: Colors.white,
                                    enabledBorder: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(16),
                                      borderSide: const BorderSide(
                                          color:
                                              ContentLibraryPage._borderColor),
                                    ),
                                    focusedBorder: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(16),
                                      borderSide: const BorderSide(
                                          color: ContentLibraryPage._buttonBlue,
                                          width: 1.4),
                                    ),
                                    contentPadding: const EdgeInsets.symmetric(
                                        horizontal: 16, vertical: 12),
                                  ),
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(height: 28),
                      LayoutBuilder(
                        builder: (context, constraints) {
                          final isCompact = constraints.maxWidth < 1080;

                          final detailContent = Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              _ContentVideoPlayer(course: _currentCourse),
                              const SizedBox(height: 32),
                              Text(
                                _currentCourse.title,
                                style: const TextStyle(
                                  color: ContentLibraryPage._titleColor,
                                  fontSize: 28,
                                  fontWeight: FontWeight.w700,
                                  height: 1.3,
                                  letterSpacing: -0.5,
                                ),
                              ),
                              const SizedBox(height: 20),
                              _FormattedDescription(
                                  text: _currentCourse.subtitle),
                              if (_currentCourse.tags.isNotEmpty) ...[
                                const SizedBox(height: 16),
                                Wrap(
                                  spacing: 10,
                                  runSpacing: 10,
                                  children: _currentCourse.tags
                                      .map(
                                        (tag) => Container(
                                          padding: const EdgeInsets.symmetric(
                                              horizontal: 14, vertical: 8),
                                          decoration: BoxDecoration(
                                            color: Colors.white,
                                            borderRadius:
                                                BorderRadius.circular(16),
                                            border: Border.all(
                                                color: ContentLibraryPage
                                                    ._borderColor),
                                          ),
                                          child: Text(
                                            tag,
                                            style: const TextStyle(
                                              color: ContentLibraryPage
                                                  ._mutedColor,
                                              fontSize: 12,
                                              fontWeight: FontWeight.w600,
                                            ),
                                          ),
                                        ),
                                      )
                                      .toList(),
                                ),
                              ],
                              const SizedBox(height: 22),
                              _LessonCompletionActions(
                                course: _currentCourse,
                                canDownload: true,
                                onDownload: () => widget.onDownloadRequested
                                    ?.call(_currentCourse),
                              ),
                              const SizedBox(height: 28),
                              _CommunityComposer(course: _currentCourse),
                            ],
                          );

                          final modulePanel = _ModulesPanel(
                              modules: modules,
                              courseId:
                                  widget.originalCourseId ?? widget.course.id,
                              courseData: originalCourse.originalData,
                              currentVideoId: _currentVideoId,
                              onModuleTap: _updateVideoFromModule,
                              isAdmin: widget.isAdmin);

                          if (isCompact) {
                            return Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                detailContent,
                                const SizedBox(height: 32),
                                SizedBox(
                                    width: double.infinity, child: modulePanel),
                              ],
                            );
                          }

                          return Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Expanded(
                                flex: 7,
                                child: Padding(
                                  padding: const EdgeInsets.only(right: 32),
                                  child: detailContent,
                                ),
                              ),
                              Expanded(
                                flex: 3,
                                child: Padding(
                                  padding: const EdgeInsets.only(right: 32),
                                  child: modulePanel,
                                ),
                              ),
                            ],
                          );
                        },
                      ),
                      Padding(
                        padding: const EdgeInsets.only(right: 32),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const SizedBox(height: 40),
                            const Text(
                              'Suggestions',
                              style: TextStyle(
                                color: ContentLibraryPage._titleColor,
                                fontSize: 20,
                                fontWeight: FontWeight.w700,
                              ),
                            ),
                            const SizedBox(height: 20),
                            if (suggestions.isEmpty)
                              Container(
                                width: double.infinity,
                                padding: const EdgeInsets.symmetric(
                                    horizontal: 20, vertical: 28),
                                decoration: BoxDecoration(
                                  color: Colors.white,
                                  borderRadius: BorderRadius.circular(22),
                                  border: Border.all(
                                      color: ContentLibraryPage._borderColor),
                                ),
                                child: const Text(
                                  'No other content to suggest right now. Check back soon!',
                                  style: TextStyle(
                                      color: ContentLibraryPage._mutedColor),
                                ),
                              )
                            else
                              SizedBox(
                                height: 230,
                                child: ListView.separated(
                                  scrollDirection: Axis.horizontal,
                                  itemBuilder: (context, index) {
                                    final item = suggestions[index];
                                    return _SuggestionCard(
                                      data: item,
                                      onTap: () =>
                                          _openSuggestion(context, item),
                                      onDownload: () => widget
                                          .onDownloadRequested
                                          ?.call(item),
                                    );
                                  },
                                  separatorBuilder: (context, index) =>
                                      const SizedBox(width: 20),
                                  itemCount: suggestions.length,
                                ),
                              ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  void _openSuggestion(BuildContext context, _LibraryCardData item) {
    Navigator.of(context).push(
      MaterialPageRoute<void>(
        builder: (_) => ContentDetailPage(
          course: item,
          relatedCourses: widget.relatedCourses
              .where((element) => element.id != item.id)
              .toList()
            ..add(widget.course),
          onDownloadRequested: widget.onDownloadRequested,
          onNavigate: widget.onNavigate,
          isAdmin: widget.isAdmin,
        ),
      ),
    );
  }

  List<_CourseModuleInfo> _extractModules(_LibraryCardData course) {
    final source = course.originalData['modules'] ??
        course.originalData['lessons'] ??
        course.originalData['sections'];
    final modules = <_CourseModuleInfo>[];
    if (source is Iterable) {
      for (final entry in source) {
        if (entry is Map<String, dynamic>) {
          final title = _FirestoreCourseGrid._readString(entry['title']) ??
              _FirestoreCourseGrid._readString(entry['name']);
          if (title == null) {
            continue;
          }
          final duration = _FirestoreCourseGrid._readString(
                  entry['duration']) ??
              _FirestoreCourseGrid._readString(entry['length']) ??
              _FirestoreCourseGrid._formatDuration(entry['durationMinutes']);
          final description =
              _FirestoreCourseGrid._readString(entry['description']) ??
                  _FirestoreCourseGrid._readString(entry['subtitle']);
          final videoUrl =
              _FirestoreCourseGrid._readString(entry['videoUrl']) ??
                  _FirestoreCourseGrid._readString(entry['video']);
          final thumbnailUrl =
              _FirestoreCourseGrid._readString(entry['thumbnailUrl']) ??
                  _FirestoreCourseGrid._readString(entry['thumbnail']);
          modules.add(_CourseModuleInfo(
              title: title,
              duration: duration,
              description: description,
              videoUrl: videoUrl,
              thumbnailUrl: thumbnailUrl));
        } else if (entry is String) {
          modules.add(_CourseModuleInfo(title: entry));
        }
      }
    }

    if (modules.isEmpty) {
      modules.add(_CourseModuleInfo(
          title: course.title,
          duration: course.meta.isNotEmpty ? course.meta.first.label : null,
          description: course.subtitle));
    }
    return modules;
  }
}

class _DocumentsButton extends StatelessWidget {
  const _DocumentsButton({
    required this.documentCount,
    required this.isLoading,
    required this.onTap,
  });

  final int documentCount;
  final bool isLoading;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: isLoading ? null : onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
        decoration: BoxDecoration(
          color: isLoading ? const Color(0xFFF1F5F9) : const Color(0xFFEFF6FF),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: const Color(0xFFDBEAFE),
            width: 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.description_outlined,
              color:
                  isLoading ? const Color(0xFF94A3B8) : const Color(0xFF3B82F6),
              size: 14,
            ),
            const SizedBox(width: 4),
            Text(
              isLoading
                  ? 'Loading...'
                  : '$documentCount ${documentCount == 1 ? "Document" : "Documents"}',
              style: TextStyle(
                color: isLoading
                    ? const Color(0xFF94A3B8)
                    : const Color(0xFF3B82F6),
                fontSize: 11,
                fontWeight: FontWeight.w600,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _DocumentsDialog extends StatelessWidget {
  const _DocumentsDialog({required this.documents});

  final List<Map<String, dynamic>> documents;

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      child: Container(
        constraints: const BoxConstraints(maxWidth: 500, maxHeight: 600),
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  width: 40,
                  height: 40,
                  decoration: BoxDecoration(
                    gradient: const LinearGradient(
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                      colors: [Color(0xFF3B82F6), Color(0xFF1D4ED8)],
                    ),
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: const Icon(Icons.description_outlined,
                      color: Colors.white, size: 20),
                ),
                const SizedBox(width: 12),
                const Expanded(
                  child: Text(
                    'Course Documents',
                    style: TextStyle(
                      color: Color(0xFF1E293B),
                      fontSize: 18,
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                ),
                IconButton(
                  onPressed: () => Navigator.of(context).pop(),
                  icon: const Icon(Icons.close, color: Color(0xFF64748B)),
                ),
              ],
            ),
            const SizedBox(height: 20),
            if (documents.isEmpty)
              Container(
                width: double.infinity,
                padding: const EdgeInsets.symmetric(vertical: 40),
                child: Column(
                  children: [
                    Container(
                      width: 56,
                      height: 56,
                      decoration: BoxDecoration(
                        color: const Color(0xFFF1F5F9),
                        borderRadius: BorderRadius.circular(14),
                      ),
                      child: const Icon(Icons.folder_open_outlined,
                          color: Color(0xFF94A3B8), size: 28),
                    ),
                    const SizedBox(height: 12),
                    const Text(
                      'No documents available',
                      style: TextStyle(
                        color: Color(0xFF475569),
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 4),
                    const Text(
                      'Documents will appear here once added',
                      style: TextStyle(
                        color: Color(0xFF94A3B8),
                        fontSize: 12,
                      ),
                    ),
                  ],
                ),
              )
            else
              Flexible(
                child: ListView.separated(
                  shrinkWrap: true,
                  itemCount: documents.length,
                  separatorBuilder: (_, __) => const Divider(
                    height: 1,
                    color: Color(0xFFF1F5F9),
                  ),
                  itemBuilder: (context, index) {
                    final document = documents[index];
                    final docName =
                        document['doc_name'] as String? ?? 'Untitled Document';
                    final docUrl = document['docUrl'] as String?;

                    return _DocumentTile(
                      docName: docName,
                      docUrl: docUrl,
                      onTap: () => _downloadDocument(docName, docUrl, context),
                    );
                  },
                ),
              ),
          ],
        ),
      ),
    );
  }

  Future<void> _downloadDocument(
      String docName, String? docUrl, BuildContext context) async {
    if (docUrl == null || docUrl.isEmpty) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Document download URL not available')),
        );
      }
      return;
    }

    try {
      if (kIsWeb) {
        // For web, open in new tab
        await launchUrl(Uri.parse(docUrl),
            mode: LaunchMode.externalApplication);
      } else {
        // For mobile/desktop, use url_launcher
        await launchUrl(Uri.parse(docUrl),
            mode: LaunchMode.externalApplication);
      }
    } catch (e) {
      debugPrint('‚ùå Error downloading document: $e');
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to download document: $e')),
        );
      }
    }
  }
}

class _DocumentTile extends StatelessWidget {
  const _DocumentTile({
    required this.docName,
    required this.docUrl,
    required this.onTap,
  });

  final String docName;
  final String? docUrl;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: docUrl != null ? onTap : null,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                color: docUrl != null
                    ? const Color(0xFFEFF6FF)
                    : const Color(0xFFF1F5F9),
                borderRadius: BorderRadius.circular(10),
              ),
              child: Icon(
                Icons.insert_drive_file_outlined,
                color: docUrl != null
                    ? const Color(0xFF3B82F6)
                    : const Color(0xFF94A3B8),
                size: 20,
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    docName,
                    style: TextStyle(
                      color: docUrl != null
                          ? const Color(0xFF1E293B)
                          : const Color(0xFF64748B),
                      fontSize: 14,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  if (docUrl == null) ...[
                    const SizedBox(height: 4),
                    const Text(
                      'Download not available',
                      style: TextStyle(
                        color: Color(0xFF94A3B8),
                        fontSize: 12,
                      ),
                    ),
                  ],
                ],
              ),
            ),
            if (docUrl != null)
              Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: const Color(0xFFEFF6FF),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: const Icon(
                  Icons.download_outlined,
                  color: Color(0xFF3B82F6),
                  size: 18,
                ),
              ),
          ],
        ),
      ),
    );
  }
}

class _CourseModuleInfo {
  const _CourseModuleInfo({
    required this.title,
    this.duration,
    this.description,
    this.videoUrl,
    this.thumbnailUrl,
    this.id,
  });

  final String title;
  final String? duration;
  final String? description;
  final String? videoUrl;
  final String? thumbnailUrl;
  final String? id; // Video document ID for matching/highlighting
}

class _ModulesPanel extends StatefulWidget {
  const _ModulesPanel({
    required this.modules,
    required this.courseId,
    this.courseData,
    this.currentVideoId,
    this.onModuleTap,
    this.isAdmin = false,
  });

  final List<_CourseModuleInfo> modules;
  final String courseId;
  final Map<String, dynamic>? courseData;
  final String?
      currentVideoId; // ID of the currently playing video for highlighting
  final ValueChanged<_CourseModuleInfo>?
      onModuleTap; // Callback to update video in parent
  final bool isAdmin;

  @override
  State<_ModulesPanel> createState() => _ModulesPanelState();
}

class _ModulesPanelState extends State<_ModulesPanel> {
  final Map<String, String?> _thumbnailCache = {};
  bool _isLoadingVideos = false;
  List<_CourseModuleInfo> _loadedVideos = [];
  List<Map<String, dynamic>> _documents = [];
  bool _isLoadingDocuments = false;

  @override
  void initState() {
    super.initState();
    _loadVideosFromCourse();
    _loadDocuments();
  }

  Future<void> _loadVideosFromCourse() async {
    if (_isLoadingVideos) return;
    setState(() {
      _isLoadingVideos = true;
    });

    try {
      // First, get the course document to access its data
      final courseDoc = await FirebaseFirestore.instance
          .collection('courses')
          .doc(widget.courseId)
          .get();

      if (!courseDoc.exists) {
        debugPrint('üì¶ Course Modules: Course not found: ${widget.courseId}');
        if (mounted) {
          setState(() {
            _loadedVideos = widget.modules;
            _isLoadingVideos = false;
          });
        }
        return;
      }

      final courseData = courseDoc.data() ?? {};
      debugPrint(
          'üì¶ Course Modules: Course data keys: ${courseData.keys.toList()}');

      final videosField = courseData['videos'];
      debugPrint(
          'üì¶ Course Modules: videos field type: ${videosField.runtimeType}, value: $videosField');

      // Extract video IDs from the 'videos' field (document references)
      List<String> videoIds = [];
      if (videosField is List) {
        debugPrint(
            'üì¶ Course Modules: videos is a List with ${videosField.length} items');
        for (final item in videosField) {
          if (item is String && item.isNotEmpty) {
            // Could be a direct ID string
            videoIds.add(item);
            debugPrint('üì¶ Course Modules: Added video ID (String): $item');
          } else if (item is DocumentReference) {
            // Document reference like /videos/NvaN84IWD1bIiCy7yh7Z
            videoIds.add(item.id);
            debugPrint(
                'üì¶ Course Modules: Added video ID (DocumentReference): ${item.id}');
          } else if (item is String && item.startsWith('/videos/')) {
            // Path string like "/videos/NvaN84IWD1bIiCy7yh7Z"
            final id = item.split('/').last;
            if (id.isNotEmpty) {
              videoIds.add(id);
              debugPrint(
                  'üì¶ Course Modules: Added video ID (path string): $id');
            }
          } else {
            debugPrint(
                'üì¶ Course Modules: Skipped video item of type: ${item.runtimeType}');
          }
        }
      } else if (videosField != null) {
        debugPrint(
            'üì¶ Course Modules: videos field is not a List, type: ${videosField.runtimeType}');
      }

      debugPrint(
          'üì¶ Course Modules: Total video IDs extracted: ${videoIds.length}');

      final List<_CourseModuleInfo> fetchedVideos = [];

      // Strategy 1: Fetch videos by document IDs if available
      // Use direct document gets to preserve order and try both collection names
      if (videoIds.isNotEmpty) {
        debugPrint(
            'üì¶ Course Modules: Fetching ${videoIds.length} videos by ID');

        // Try 'video' collection first (singular - seems to be the primary one)
        final videoCollection = FirebaseFirestore.instance.collection('video');
        final videosCollection =
            FirebaseFirestore.instance.collection('videos');

        // Fetch videos one by one to preserve order and handle both collections
        for (final videoId in videoIds) {
          try {
            // Try 'video' collection first
            final doc = await videoCollection.doc(videoId).get();
            if (doc.exists) {
              final videoInfo = _parseVideoDoc(doc);
              if (videoInfo != null) {
                fetchedVideos.add(videoInfo);
                debugPrint(
                    'üì¶ Course Modules: Found video in "video" collection: $videoId');
                continue;
              }
            }

            // If not found, try 'videos' collection (plural)
            final docPlural = await videosCollection.doc(videoId).get();
            if (docPlural.exists) {
              final videoInfo = _parseVideoDoc(docPlural);
              if (videoInfo != null) {
                fetchedVideos.add(videoInfo);
                debugPrint(
                    'üì¶ Course Modules: Found video in "videos" collection: $videoId');
                continue;
              }
            }

            debugPrint(
                '‚ö†Ô∏è Course Modules: Video not found in either collection: $videoId');
          } catch (e) {
            debugPrint('‚ùå Course Modules: Error fetching video $videoId: $e');
          }
        }

        debugPrint(
            'üì¶ Course Modules: Successfully fetched ${fetchedVideos.length} out of ${videoIds.length} videos');
      }

      // Only use videos from the 'videos' field - no fallback queries by topic/tag
      // This ensures we only show videos that belong to this specific course
      debugPrint(
          'üì¶ Course Modules: Total videos fetched from course videos field: ${fetchedVideos.length}');

      if (mounted) {
        setState(() {
          _loadedVideos =
              fetchedVideos.isNotEmpty ? fetchedVideos : widget.modules;
          _isLoadingVideos = false;
        });
      }
    } catch (e) {
      debugPrint('üì¶ Course Modules: Failed to load videos from course: $e');
      if (mounted) {
        setState(() {
          _loadedVideos = widget.modules;
          _isLoadingVideos = false;
        });
      }
    }
  }

  Future<void> _loadDocuments() async {
    if (_isLoadingDocuments) return;
    setState(() {
      _isLoadingDocuments = true;
    });

    try {
      // Get the course document to access its docs field
      final courseDoc = await FirebaseFirestore.instance
          .collection('courses')
          .doc(widget.courseId)
          .get();

      if (!courseDoc.exists) {
        debugPrint('üìÑ Course Documents: Course not found: ${widget.courseId}');
        if (mounted) {
          setState(() {
            _documents = [];
            _isLoadingDocuments = false;
          });
        }
        return;
      }

      final courseData = courseDoc.data() ?? {};
      final docsField = courseData['docs'];

      List<String> documentIds = [];
      if (docsField is List) {
        for (final item in docsField) {
          if (item is String && item.isNotEmpty) {
            documentIds.add(item);
          } else if (item is DocumentReference) {
            documentIds.add(item.id);
          }
        }
      }

      final List<Map<String, dynamic>> fetchedDocuments = [];

      // Fetch documents from the 'document' collection
      if (documentIds.isNotEmpty) {
        final documentsCollection =
            FirebaseFirestore.instance.collection('document');

        for (final docId in documentIds) {
          try {
            final doc = await documentsCollection.doc(docId).get();
            if (doc.exists) {
              final data = doc.data() ?? {};
              fetchedDocuments.add({
                'id': doc.id,
                'doc_name': data['doc_name'] as String? ?? 'Untitled Document',
                'docUrl': data['docUrl'] as String?,
                ...data,
              });
            }
          } catch (e) {
            debugPrint(
                '‚ùå Course Documents: Error fetching document $docId: $e');
          }
        }
      }

      debugPrint(
          'üìÑ Course Documents: Loaded ${fetchedDocuments.length} documents');

      if (mounted) {
        setState(() {
          _documents = fetchedDocuments;
          _isLoadingDocuments = false;
        });
      }
    } catch (e) {
      debugPrint('‚ùå Error loading documents: $e');
      if (mounted) {
        setState(() {
          _documents = [];
          _isLoadingDocuments = false;
        });
      }
    }
  }

  void _showDocumentsDialog() {
    showDialog(
      context: context,
      builder: (context) => _DocumentsDialog(documents: _documents),
    );
  }

  _CourseModuleInfo? _parseVideoDoc(
      DocumentSnapshot<Map<String, dynamic>> doc) {
    final data = doc.data();
    if (data == null) return null;

    final title = data['title'] as String? ?? 'Untitled Video';
    // Handle duration as int or String
    final rawDuration = data['duration'];
    String? duration;
    if (rawDuration is int) {
      // Convert seconds to MM:SS format
      final mins = (rawDuration ~/ 60).toString().padLeft(2, '0');
      final secs = (rawDuration % 60).toString().padLeft(2, '0');
      duration = '$mins:$secs';
    } else if (rawDuration is String) {
      duration = rawDuration;
    }
    final description = data['description'] as String?;
    final videoUrl = data['videoUrl'] as String? ?? data['url'] as String?;
    final thumbnailUrl =
        data['thumbnail'] as String? ?? data['thumbnailUrl'] as String?;

    debugPrint('üì¶ Course Modules: Adding video: $title');

    // Cache the thumbnail
    if (thumbnailUrl != null) {
      _thumbnailCache[title] = thumbnailUrl;
    }

    return _CourseModuleInfo(
      title: title,
      duration: duration,
      description: description,
      videoUrl: videoUrl,
      thumbnailUrl: thumbnailUrl,
      id: doc.id, // Store the document ID for matching
    );
  }

  Future<void> _navigateToModuleDetail(
      BuildContext context, _CourseModuleInfo module) async {
    try {
      // Query Firestore collections to find the matching video document
      // Try both 'video' (singular) and 'videos' (plural) collections
      final videoCollection = FirebaseFirestore.instance.collection('video');
      final videosCollection = FirebaseFirestore.instance.collection('videos');

      QuerySnapshot<Map<String, dynamic>> querySnapshot;

      // Try to find by exact title match first in 'video' collection
      querySnapshot = await videoCollection
          .where('title', isEqualTo: module.title)
          .limit(1)
          .get();

      // If not found, try 'videos' collection
      if (querySnapshot.docs.isEmpty) {
        querySnapshot = await videosCollection
            .where('title', isEqualTo: module.title)
            .limit(1)
            .get();
      }

      // If still not found and we have a videoUrl, try searching by videoUrl in 'video' collection
      if (querySnapshot.docs.isEmpty && module.videoUrl != null) {
        querySnapshot = await videoCollection
            .where('videoUrl', isEqualTo: module.videoUrl)
            .limit(1)
            .get();
      }

      // If still not found, try 'videos' collection by videoUrl
      if (querySnapshot.docs.isEmpty && module.videoUrl != null) {
        querySnapshot = await videosCollection
            .where('videoUrl', isEqualTo: module.videoUrl)
            .limit(1)
            .get();
      }

      if (querySnapshot.docs.isEmpty) {
        // If no document found, show a message
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Content details not available yet.')),
          );
        }
        return;
      }

      // Convert the Firestore document to _LibraryCardData
      final doc = querySnapshot.docs.first;
      final cardData = _FirestoreCourseGrid._mapSnapshot(
        doc,
        paletteIndex: 0,
        showContinueButton: false,
      );

      if (cardData == null) {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Unable to load content details.')),
          );
        }
        return;
      }

      // Navigate to ContentDetailPage, preserving the original course context
      // so the modules panel still shows all videos from the original course
      if (context.mounted) {
        // Get the original course ID from the parent widget
        final originalCourseId = widget.courseId;
        Navigator.of(context).push(
          MaterialPageRoute<void>(
            builder: (ctx) => ContentDetailPage(
              course: cardData,
              relatedCourses: const [],
              originalCourseId: originalCourseId, // Pass original course ID
              currentVideoId:
                  cardData.id, // Pass current video ID for highlighting
              isAdmin: widget.isAdmin,
            ),
          ),
        );
      }
    } catch (e) {
      debugPrint('Error navigating to module detail: $e');
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
              content: Text('An error occurred while loading content.')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // Use loaded videos if available, otherwise fall back to passed modules
    final displayModules =
        _loadedVideos.isNotEmpty ? _loadedVideos : widget.modules;
    final videoCount = displayModules.length;

    return Container(
      decoration: BoxDecoration(
        gradient: const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [Color(0xFFFFFFFF), Color(0xFFFAFBFE)],
        ),
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: const Color(0xFFE8ECF4)),
        boxShadow: [
          BoxShadow(
            color: const Color(0xFF1E3A5F).withValues(alpha: 0.06),
            blurRadius: 24,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header Section
          Container(
            padding: const EdgeInsets.fromLTRB(24, 20, 24, 16),
            decoration: const BoxDecoration(
              border: Border(
                  bottom: BorderSide(color: Color(0xFFF0F3F8), width: 1)),
            ),
            child: Row(
              children: [
                Container(
                  width: 42,
                  height: 42,
                  decoration: BoxDecoration(
                    gradient: const LinearGradient(
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                      colors: [Color(0xFF3B82F6), Color(0xFF1D4ED8)],
                    ),
                    borderRadius: BorderRadius.circular(12),
                    boxShadow: [
                      BoxShadow(
                        color: const Color(0xFF3B82F6).withValues(alpha: 0.3),
                        blurRadius: 8,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: const Icon(Icons.video_library_rounded,
                      color: Colors.white, size: 22),
                ),
                const SizedBox(width: 14),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Course Modules',
                        style: TextStyle(
                          color: Color(0xFF1E293B),
                          fontSize: 17,
                          fontWeight: FontWeight.w700,
                          letterSpacing: -0.3,
                        ),
                      ),
                      const SizedBox(height: 2),
                      Text(
                        _isLoadingVideos
                            ? 'Loading videos...'
                            : '$videoCount ${videoCount == 1 ? "video" : "videos"} available',
                        style: TextStyle(
                          color: const Color(0xFF64748B),
                          fontSize: 12,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ),
                Row(
                  children: [
                    if (!_isLoadingVideos && displayModules.isNotEmpty)
                      Container(
                        padding: const EdgeInsets.symmetric(
                            horizontal: 10, vertical: 5),
                        decoration: BoxDecoration(
                          color: const Color(0xFFDCFCE7),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(Icons.check_circle,
                                color: const Color(0xFF16A34A), size: 14),
                            const SizedBox(width: 4),
                            Text(
                              'Ready',
                              style: TextStyle(
                                color: const Color(0xFF16A34A),
                                fontSize: 11,
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                          ],
                        ),
                      ),
                    const SizedBox(width: 8),
                    // Documents button
                    _DocumentsButton(
                      documentCount: _documents.length,
                      isLoading: _isLoadingDocuments,
                      onTap: _showDocumentsDialog,
                    ),
                  ],
                ),
              ],
            ),
          ),
          // Content Section
          if (_isLoadingVideos)
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 40),
              child: Center(
                child: Column(
                  children: [
                    SizedBox(
                      width: 40,
                      height: 40,
                      child: CircularProgressIndicator(
                        strokeWidth: 3,
                        valueColor: AlwaysStoppedAnimation<Color>(
                            const Color(0xFF3B82F6)),
                      ),
                    ),
                    const SizedBox(height: 16),
                    const Text(
                      'Fetching course content...',
                      style: TextStyle(
                          color: Color(0xFF64748B),
                          fontSize: 13,
                          fontWeight: FontWeight.w500),
                    ),
                  ],
                ),
              ),
            )
          else if (displayModules.isEmpty)
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 40, horizontal: 24),
              child: Center(
                child: Column(
                  children: [
                    Container(
                      width: 64,
                      height: 64,
                      decoration: BoxDecoration(
                        color: const Color(0xFFF1F5F9),
                        borderRadius: BorderRadius.circular(16),
                      ),
                      child: const Icon(Icons.videocam_off_rounded,
                          color: Color(0xFF94A3B8), size: 32),
                    ),
                    const SizedBox(height: 16),
                    const Text(
                      'No videos available',
                      style: TextStyle(
                          color: Color(0xFF475569),
                          fontSize: 15,
                          fontWeight: FontWeight.w600),
                    ),
                    const SizedBox(height: 4),
                    const Text(
                      'Videos will appear here once added',
                      style: TextStyle(color: Color(0xFF94A3B8), fontSize: 13),
                    ),
                  ],
                ),
              ),
            )
          else
            ListView.separated(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              padding: const EdgeInsets.symmetric(vertical: 8),
              itemCount: displayModules.length,
              separatorBuilder: (_, __) => const Divider(
                  height: 1,
                  indent: 24,
                  endIndent: 24,
                  color: Color(0xFFF1F5F9)),
              itemBuilder: (context, index) {
                final module = displayModules[index];
                final firestoreThumbnail = _thumbnailCache[module.title];
                final effectiveThumbnail =
                    firestoreThumbnail ?? module.thumbnailUrl;
                final hasVideo =
                    module.videoUrl != null || firestoreThumbnail != null;

                // Check if this module is the currently playing video
                // Match by document ID first, then by title as fallback
                final isCurrentVideo = widget.currentVideoId != null &&
                    (module.id != null && module.id == widget.currentVideoId ||
                        module.id == null &&
                            module.title == widget.currentVideoId);

                return _ModuleVideoCard(
                  index: index + 1,
                  module: module,
                  thumbnailUrl: effectiveThumbnail,
                  hasVideo: hasVideo,
                  isCurrentVideo: isCurrentVideo,
                  onTap: () {
                    // Use callback if available (updates video in place), otherwise navigate
                    if (widget.onModuleTap != null) {
                      widget.onModuleTap!(module);
                    } else {
                      _navigateToModuleDetail(context, module);
                    }
                  },
                );
              },
            ),
        ],
      ),
    );
  }
}

class _ModuleVideoCard extends StatefulWidget {
  const _ModuleVideoCard({
    required this.index,
    required this.module,
    required this.onTap,
    this.thumbnailUrl,
    this.hasVideo = false,
    this.isCurrentVideo = false,
  });

  final int index;
  final _CourseModuleInfo module;
  final String? thumbnailUrl;
  final bool hasVideo;
  final bool isCurrentVideo;
  final VoidCallback onTap;

  @override
  State<_ModuleVideoCard> createState() => _ModuleVideoCardState();
}

class _ModuleVideoCardState extends State<_ModuleVideoCard> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        curve: Curves.easeOutCubic,
        margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
        decoration: BoxDecoration(
          color: widget.isCurrentVideo
              ? const Color(0xFFEFF6FF)
              : (_isHovered ? const Color(0xFFF8FAFC) : Colors.transparent),
          borderRadius: BorderRadius.circular(14),
          border: widget.isCurrentVideo
              ? Border.all(color: const Color(0xFF3B82F6), width: 2)
              : null,
        ),
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            borderRadius: BorderRadius.circular(14),
            onTap: widget.onTap,
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  // Thumbnail / Index
                  _buildThumbnail(),
                  const SizedBox(width: 14),
                  // Content
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          widget.module.title,
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                          style: TextStyle(
                            color: const Color(0xFF1E293B),
                            fontSize: 14,
                            fontWeight: FontWeight.w600,
                            height: 1.3,
                          ),
                        ),
                        if (widget.module.description != null &&
                            widget.module.description!.isNotEmpty) ...[
                          const SizedBox(height: 4),
                          Text(
                            widget.module.description!,
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                            style: const TextStyle(
                              color: Color(0xFF64748B),
                              fontSize: 12,
                              height: 1.4,
                            ),
                          ),
                        ],
                        const SizedBox(height: 6),
                        Row(
                          children: [
                            if (widget.module.duration != null &&
                                widget.module.duration!.isNotEmpty) ...[
                              Container(
                                padding: const EdgeInsets.symmetric(
                                    horizontal: 8, vertical: 3),
                                decoration: BoxDecoration(
                                  color: const Color(0xFFF1F5F9),
                                  borderRadius: BorderRadius.circular(6),
                                ),
                                child: Row(
                                  mainAxisSize: MainAxisSize.min,
                                  children: [
                                    const Icon(Icons.schedule_rounded,
                                        size: 12, color: Color(0xFF64748B)),
                                    const SizedBox(width: 4),
                                    Text(
                                      widget.module.duration!,
                                      style: const TextStyle(
                                          color: Color(0xFF64748B),
                                          fontSize: 11,
                                          fontWeight: FontWeight.w500),
                                    ),
                                  ],
                                ),
                              ),
                              const SizedBox(width: 8),
                            ],
                            if (widget.hasVideo)
                              Container(
                                padding: const EdgeInsets.symmetric(
                                    horizontal: 8, vertical: 3),
                                decoration: BoxDecoration(
                                  color: const Color(0xFFEFF6FF),
                                  borderRadius: BorderRadius.circular(6),
                                ),
                                child: Row(
                                  mainAxisSize: MainAxisSize.min,
                                  children: [
                                    Icon(Icons.play_circle_outline_rounded,
                                        size: 12,
                                        color: const Color(0xFF3B82F6)),
                                    const SizedBox(width: 4),
                                    Text(
                                      'Video',
                                      style: TextStyle(
                                          color: const Color(0xFF3B82F6),
                                          fontSize: 11,
                                          fontWeight: FontWeight.w500),
                                    ),
                                  ],
                                ),
                              ),
                          ],
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(width: 8),
                  // Play button
                  AnimatedContainer(
                    duration: const Duration(milliseconds: 200),
                    width: 36,
                    height: 36,
                    decoration: BoxDecoration(
                      color: _isHovered
                          ? const Color(0xFF3B82F6)
                          : const Color(0xFFF1F5F9),
                      borderRadius: BorderRadius.circular(10),
                    ),
                    child: Icon(
                      Icons.play_arrow_rounded,
                      color:
                          _isHovered ? Colors.white : const Color(0xFF64748B),
                      size: 20,
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildThumbnail() {
    if (widget.thumbnailUrl != null && widget.thumbnailUrl!.isNotEmpty) {
      return Container(
        width: 64,
        height: 48,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(10),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withValues(alpha: 0.08),
              blurRadius: 8,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        clipBehavior: Clip.antiAlias,
        child: Stack(
          fit: StackFit.expand,
          children: [
            Image.network(
              widget.thumbnailUrl!,
              fit: BoxFit.cover,
              errorBuilder: (_, __, ___) => _buildIndexPlaceholder(),
            ),
            // Gradient overlay
            Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [
                    Colors.transparent,
                    Colors.black.withValues(alpha: 0.4),
                  ],
                ),
              ),
            ),
            // Play icon overlay
            Center(
              child: AnimatedContainer(
                duration: const Duration(milliseconds: 200),
                width: _isHovered ? 28 : 24,
                height: _isHovered ? 28 : 24,
                decoration: BoxDecoration(
                  color: Colors.white.withValues(alpha: 0.95),
                  shape: BoxShape.circle,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withValues(alpha: 0.2),
                      blurRadius: 4,
                    ),
                  ],
                ),
                child: const Icon(Icons.play_arrow_rounded,
                    color: Color(0xFF3B82F6), size: 16),
              ),
            ),
          ],
        ),
      );
    }
    return _buildIndexPlaceholder();
  }

  Widget _buildIndexPlaceholder() {
    return Container(
      width: 64,
      height: 48,
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            const Color(0xFFE2E8F0),
            const Color(0xFFCBD5E1),
          ],
        ),
        borderRadius: BorderRadius.circular(10),
      ),
      child: Center(
        child: widget.hasVideo
            ? const Icon(Icons.play_circle_filled_rounded,
                color: Color(0xFF64748B), size: 24)
            : Text(
                '${widget.index}',
                style: const TextStyle(
                  color: Color(0xFF475569),
                  fontSize: 16,
                  fontWeight: FontWeight.w700,
                ),
              ),
      ),
    );
  }
}

class _DetailStatChip extends StatefulWidget {
  const _DetailStatChip(
      {required this.icon, required this.label, this.courseId});

  final IconData icon;
  final String label;
  final String? courseId;

  @override
  State<_DetailStatChip> createState() => _DetailStatChipState();
}

class _DetailStatChipState extends State<_DetailStatChip> {
  int _count = 0;
  bool _isLoading = true;
  bool _isLiked = false;
  bool _isSaved = false;

  @override
  void initState() {
    super.initState();
    if (widget.label == 'Like' && widget.courseId != null) {
      _loadLikeCount();
      _checkIfLiked();
    } else if (widget.label == 'Save' && widget.courseId != null) {
      _checkIfSaved();
    } else {
      setState(() {
        _isLoading = false;
      });
    }
  }

  Future<void> _checkIfLiked() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;

    try {
      final userDoc =
          await FirebaseFirestore.instance.collection('users').doc(uid).get();

      if (userDoc.exists) {
        final data = userDoc.data();
        final likedVideos = data?['likedVideos'] as List<dynamic>?;
        if (mounted) {
          setState(() {
            _isLiked = likedVideos?.contains(widget.courseId) ?? false;
          });
        }
      }
    } catch (e) {
      debugPrint('Failed to check if liked: $e');
    }
  }

  Future<void> _checkIfSaved() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) {
      setState(() {
        _isLoading = false;
      });
      return;
    }

    try {
      final userDoc =
          await FirebaseFirestore.instance.collection('users').doc(uid).get();

      if (userDoc.exists) {
        final data = userDoc.data();
        final favouriteCourses = data?['favouriteCourses'] as List<dynamic>?;
        if (mounted) {
          setState(() {
            _isSaved = favouriteCourses?.contains(widget.courseId) ?? false;
            _isLoading = false;
          });
        }
      } else {
        if (mounted) {
          setState(() {
            _isLoading = false;
          });
        }
      }
    } catch (e) {
      debugPrint('Failed to check if saved: $e');
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  Future<void> _loadLikeCount() async {
    try {
      // Try 'video' collection first
      final videoDoc = await FirebaseFirestore.instance
          .collection('video')
          .doc(widget.courseId)
          .get();

      if (videoDoc.exists) {
        final data = videoDoc.data();
        final upVote = data?['up_vote'];
        if (mounted) {
          setState(() {
            _count = upVote is int ? upVote.abs() : 0;
            _isLoading = false;
          });
        }
        return;
      }

      // Try 'videos' collection
      final videosDoc = await FirebaseFirestore.instance
          .collection('videos')
          .doc(widget.courseId)
          .get();

      if (videosDoc.exists) {
        final data = videosDoc.data();
        final upVote = data?['up_vote'];
        if (mounted) {
          setState(() {
            _count = upVote is int ? upVote.abs() : 0;
            _isLoading = false;
          });
        }
        return;
      }

      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    } catch (e) {
      debugPrint('Failed to load like count: $e');
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  Future<void> _handleLike() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null || widget.courseId == null) return;

    // Prevent multiple likes
    if (_isLiked) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('You have already liked this video'),
          behavior: SnackBarBehavior.floating,
        ),
      );
      return;
    }

    // Optimistically update UI
    setState(() {
      _isLiked = true;
      _count = _count + 1;
    });

    try {
      // Try 'video' collection first
      final videoRef =
          FirebaseFirestore.instance.collection('video').doc(widget.courseId);

      final videoDoc = await videoRef.get();

      if (videoDoc.exists) {
        await videoRef.update({
          'up_vote': FieldValue.increment(1),
        });

        // Add to user's likedVideos array
        await FirebaseFirestore.instance.collection('users').doc(uid).set({
          'likedVideos': FieldValue.arrayUnion([widget.courseId]),
        }, SetOptions(merge: true));

        return;
      }

      // Try 'videos' collection
      final videosRef =
          FirebaseFirestore.instance.collection('videos').doc(widget.courseId);

      final videosDoc = await videosRef.get();

      if (videosDoc.exists) {
        await videosRef.update({
          'up_vote': FieldValue.increment(1),
        });

        // Add to user's likedVideos array
        await FirebaseFirestore.instance.collection('users').doc(uid).set({
          'likedVideos': FieldValue.arrayUnion([widget.courseId]),
        }, SetOptions(merge: true));
      }
    } catch (e) {
      debugPrint('Failed to like video: $e');
      // Revert optimistic update on error
      setState(() {
        _isLiked = false;
        _count = _count - 1;
      });
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Failed to like video. Please try again.'),
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  Future<void> _handleSave() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null || widget.courseId == null) return;

    final newState = !_isSaved;

    // Optimistically update UI
    setState(() {
      _isSaved = newState;
    });

    try {
      final userRef = FirebaseFirestore.instance.collection('users').doc(uid);

      if (newState) {
        // Add to favouriteCourses
        await userRef.set({
          'favouriteCourses': FieldValue.arrayUnion([widget.courseId]),
        }, SetOptions(merge: true));

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Added to favorites'),
              behavior: SnackBarBehavior.floating,
            ),
          );
        }
      } else {
        // Remove from favouriteCourses
        await userRef.set({
          'favouriteCourses': FieldValue.arrayRemove([widget.courseId]),
        }, SetOptions(merge: true));

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Removed from favorites'),
              behavior: SnackBarBehavior.floating,
            ),
          );
        }
      }
    } catch (e) {
      debugPrint('Failed to save/unsave video: $e');
      // Revert optimistic update on error
      setState(() {
        _isSaved = !newState;
      });
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Failed to update favorites. Please try again.'),
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final displayLabel =
        widget.label == 'Like' ? 'Like ($_count)' : widget.label;
    final isActive = widget.label == 'Like'
        ? _isLiked
        : (widget.label == 'Save' ? _isSaved : false);
    final icon = widget.label == 'Like'
        ? (_isLiked ? Icons.thumb_up_alt : Icons.thumb_up_alt_outlined)
        : (widget.label == 'Save'
            ? (_isSaved ? Icons.favorite : Icons.favorite_border)
            : widget.icon);

    return OutlinedButton.icon(
      onPressed: widget.label == 'Like'
          ? _handleLike
          : (widget.label == 'Save' ? _handleSave : null),
      style: OutlinedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 14),
        foregroundColor: isActive
            ? ContentLibraryPage._buttonBlue
            : ContentLibraryPage._mutedColor,
        side: BorderSide(
            color: isActive
                ? ContentLibraryPage._buttonBlue
                : ContentLibraryPage._borderColor),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      ),
      icon: Icon(icon, size: 18),
      label: Text(displayLabel),
    );
  }
}

class _LessonCompletionActions extends StatefulWidget {
  const _LessonCompletionActions({
    required this.course,
    required this.canDownload,
    this.onDownload,
  });

  final _LibraryCardData course;
  final bool canDownload;
  final VoidCallback? onDownload;

  @override
  State<_LessonCompletionActions> createState() =>
      _LessonCompletionActionsState();
}

class _LessonCompletionActionsState extends State<_LessonCompletionActions> {
  bool _isCompleted = false;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _checkCompletion();
  }

  Future<void> _checkCompletion() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) {
      setState(() {
        _isLoading = false;
      });
      return;
    }
    try {
      final courseId = widget.course.id;
      final doc = await FirebaseFirestore.instance
          .collection('users')
          .doc(uid)
          .collection('completed_courses')
          .doc(courseId)
          .get();
      if (mounted) {
        setState(() {
          _isCompleted = doc.exists;
          _isLoading = false;
        });
      }
    } catch (e) {
      debugPrint('Failed to check completion: $e');
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final bool isCompleted = _isCompleted;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Wrap(
          spacing: 16,
          runSpacing: 12,
          children: [
            _DetailStatChip(
                icon: Icons.thumb_up_alt_outlined,
                label: 'Like',
                courseId: widget.course.id),
            _DetailStatChip(
                icon: Icons.favorite_border,
                label: 'Save',
                courseId: widget.course.id),
            const _DetailStatChip(icon: Icons.share_outlined, label: 'Share'),
            OutlinedButton.icon(
              onPressed: widget.canDownload ? widget.onDownload : null,
              style: OutlinedButton.styleFrom(
                padding:
                    const EdgeInsets.symmetric(horizontal: 20, vertical: 14),
                foregroundColor: widget.canDownload
                    ? ContentLibraryPage._buttonBlue
                    : ContentLibraryPage._mutedColor,
                side: BorderSide(
                  color: widget.canDownload
                      ? ContentLibraryPage._buttonBlue
                      : ContentLibraryPage._borderColor,
                ),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(16)),
              ),
              icon: const Icon(Icons.download_rounded),
              label: const Text('Download'),
            ),
            ElevatedButton.icon(
              onPressed: _toggleCompletion,
              style: ElevatedButton.styleFrom(
                backgroundColor: isCompleted
                    ? const Color(0xFFDCFCE7)
                    : ContentLibraryPage._buttonBlue,
                foregroundColor:
                    isCompleted ? const Color(0xFF047857) : Colors.white,
                padding:
                    const EdgeInsets.symmetric(horizontal: 22, vertical: 16),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(16)),
                elevation: 0,
                textStyle:
                    const TextStyle(fontWeight: FontWeight.w700, fontSize: 14),
              ),
              icon:
                  Icon(isCompleted ? Icons.check_circle : Icons.flag_outlined),
              label: Text(isCompleted ? 'Completed' : 'Mark As Complete'),
            ),
          ],
        ),
        AnimatedSwitcher(
          duration: const Duration(milliseconds: 200),
          child: isCompleted
              ? Padding(
                  key: const ValueKey('completion_status'),
                  padding: const EdgeInsets.only(top: 12),
                  child: Row(
                    children: const [
                      Icon(Icons.check_circle,
                          color: Color(0xFF047857), size: 18),
                      SizedBox(width: 8),
                      Text(
                        'Lesson marked as complete',
                        style: TextStyle(
                          color: Color(0xFF047857),
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                )
              : const SizedBox.shrink(),
        ),
      ],
    );
  }

  Future<void> _toggleCompletion() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;

    final courseId = widget.course.id;
    final newState = !_isCompleted;

    setState(() {
      _isCompleted = newState;
    });

    try {
      final docRef = FirebaseFirestore.instance
          .collection('users')
          .doc(uid)
          .collection('completed_courses')
          .doc(courseId);

      if (newState) {
        final now = FieldValue.serverTimestamp();
        final topic = widget.course.originalData['topic'] ??
            widget.course.originalData['category'] ??
            widget.course.originalData['framework'];
        await docRef.set({
          'courseId': courseId,
          'title': widget.course.title,
          'topic': topic,
          'completed': true,
          'completedAt': now,
          'timestamp': now,
        });
      } else {
        await docRef.delete();
      }
    } catch (e) {
      debugPrint('Failed to save completion: $e');
      setState(() {
        _isCompleted = !newState;
      });
    }
  }
}

class _ContentVideoPlayer extends StatefulWidget {
  const _ContentVideoPlayer({required this.course});

  final _LibraryCardData course;

  @override
  State<_ContentVideoPlayer> createState() => _ContentVideoPlayerState();
}

class _ContentVideoPlayerState extends State<_ContentVideoPlayer> {
  VideoPlayerController? _controller;
  Future<void>? _initialize;
  bool _initializationFailed = false;
  Uri? _videoUri;
  Uri? _downloadUri;
  bool _hasShownPlaybackError = false;
  String? _embedUrl;
  bool _isFullscreen = false;
  double _playbackSpeed = 1.0;
  bool _hasIncrementedVideoWatch = false;

  @override
  void initState() {
    super.initState();
    _configureController();
  }

  @override
  void didUpdateWidget(covariant _ContentVideoPlayer oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.course.videoUrl != widget.course.videoUrl) {
      _configureController();
    }
  }

  @override
  void dispose() {
    _controller?.dispose();
    super.dispose();
  }

  Future<void> _configureController() async {
    final previous = _controller;
    _controller = null;
    _initialize = null;
    _initializationFailed = false;
    _videoUri = null;
    _downloadUri = null;
    _hasShownPlaybackError = false;
    _embedUrl = null;
    _hasIncrementedVideoWatch = false;
    await previous?.dispose();

    _ResolvedCourseMedia media;
    try {
      media = await _CourseMediaResolver.resolve(widget.course);
    } catch (error) {
      debugPrint('Failed to resolve course media: $error');
      if (!mounted) {
        return;
      }
      setState(() {
        _initializationFailed = true;
      });
      return;
    }

    if (!mounted) {
      return;
    }

    String? videoUrl = media.streamUrl?.trim();
    String? downloadUrl = media.downloadUrl?.trim();

    if ((videoUrl == null || videoUrl.isEmpty) &&
        downloadUrl != null &&
        downloadUrl.isNotEmpty) {
      videoUrl = downloadUrl;
    }
    if ((downloadUrl == null || downloadUrl.isEmpty) &&
        videoUrl != null &&
        videoUrl.isNotEmpty) {
      downloadUrl = videoUrl;
    }

    // Debug: log resolved URLs for this course
    // This helps verify Firestore "video" document resolution and field mapping at runtime.
    try {
      debugPrint(
          'VideoResolver: courseId=${widget.course.id} streamUrl=${media.streamUrl} downloadUrl=${media.downloadUrl}');
    } catch (_) {}

    final uriCandidate = downloadUrl ?? videoUrl;
    _downloadUri = uriCandidate == null ? null : Uri.tryParse(uriCandidate);

    if (videoUrl == null || videoUrl.isEmpty) {
      setState(() {});
      return;
    }

    final uri = Uri.tryParse(videoUrl);
    if (uri == null) {
      setState(() {
        _initializationFailed = true;
      });
      return;
    }

    _videoUri = uri;

    if (kIsWeb && _prefersEmbed(uri)) {
      setState(() {
        _embedUrl = _normalizeEmbedUrl(videoUrl!);
      });
      return;
    }

    final controller = VideoPlayerController.networkUrl(uri);
    _controller = controller;
    _initialize = controller.initialize().then((_) async {
      if (!mounted) {
        await controller.dispose();
        return;
      }
      controller
        ..setLooping(true)
        ..setVolume(1);
      setState(() {});
    }).catchError((error) async {
      debugPrint('Video initialization failed: $error');
      await controller.dispose();
      if (mounted) {
        setState(() {
          _controller = null;
          _initialize = null;
          _initializationFailed = true;
          // Web fallback: if native player fails, try showing the source in an iframe.
          if (kIsWeb && _embedUrl == null && _videoUri != null) {
            _embedUrl = _normalizeEmbedUrl(_videoUri.toString());
          }
        });
      }
    });

    setState(() {});
  }

  void _togglePlayPause() {
    final controller = _controller;
    if (controller == null || !controller.value.isInitialized) {
      return;
    }
    if (controller.value.isPlaying) {
      controller.pause();
    } else {
      controller.play().catchError((error) {
        debugPrint('Video playback failed: $error');
        if (!_hasShownPlaybackError) {
          _hasShownPlaybackError = true;
          _showSnackBar(
              'Unable to start the video automatically. Try clicking the play button again or open in a new tab.');
        }
      });

      // Increment video watch counter on first play
      if (!_hasIncrementedVideoWatch) {
        _hasIncrementedVideoWatch = true;
        _incrementVideoWatchCount();
      }
    }
    setState(() {});
  }

  Future<void> _incrementVideoWatchCount() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;

    try {
      final userRef = FirebaseFirestore.instance.collection('users').doc(uid);
      await userRef.set({
        'videosWatched': FieldValue.increment(1),
      }, SetOptions(merge: true));

      debugPrint('Video watch count incremented for user $uid');
    } catch (e) {
      debugPrint('Failed to increment video watch count: $e');
    }
  }

  void _toggleMute() {
    final controller = _controller;
    if (controller == null || !controller.value.isInitialized) {
      return;
    }
    final bool isMuted = controller.value.volume == 0;
    controller.setVolume(isMuted ? 1 : 0);
    setState(() {});
  }

  double get _aspectRatio {
    final controller = _controller;
    if (controller == null || !controller.value.isInitialized) {
      return 16 / 9;
    }
    final ratio = controller.value.aspectRatio;
    if (ratio.isNaN || ratio <= 0) {
      return 16 / 9;
    }
    return ratio;
  }

  void _showSnackBar(String message) {
    if (!mounted) {
      return;
    }
    final messenger = ScaffoldMessenger.maybeOf(context);
    messenger
      ?..hideCurrentSnackBar()
      ..showSnackBar(
        SnackBar(
          content: Text(message),
          behavior: SnackBarBehavior.floating,
        ),
      );
  }

  Future<void> _openInNewTab() async {
    final uri = _downloadUri ?? _videoUri;
    if (uri == null) {
      return;
    }
    try {
      final launched = await launchUrl(
        uri,
        mode: LaunchMode.platformDefault,
        webOnlyWindowName: '_blank',
      );
      if (!launched) {
        _showSnackBar('We could not open the video link.');
      }
    } catch (error) {
      debugPrint('Failed to open video in new tab: $error');
      _showSnackBar('We could not open the video link.');
    }
  }

  void _skipForward() {
    final controller = _controller;
    if (controller == null || !controller.value.isInitialized) return;
    final current = controller.value.position;
    final target = current + const Duration(seconds: 10);
    controller.seekTo(target > controller.value.duration
        ? controller.value.duration
        : target);
  }

  void _skipBackward() {
    final controller = _controller;
    if (controller == null || !controller.value.isInitialized) return;
    final current = controller.value.position;
    final target = current - const Duration(seconds: 10);
    controller.seekTo(target < Duration.zero ? Duration.zero : target);
  }

  void _changePlaybackSpeed() {
    final controller = _controller;
    if (controller == null || !controller.value.isInitialized) return;
    double newSpeed;
    if (_playbackSpeed == 1.0) {
      newSpeed = 1.25;
    } else if (_playbackSpeed == 1.25) {
      newSpeed = 1.5;
    } else if (_playbackSpeed == 1.5) {
      newSpeed = 2.0;
    } else {
      newSpeed = 1.0;
    }
    controller.setPlaybackSpeed(newSpeed);
    setState(() {
      _playbackSpeed = newSpeed;
    });
  }

  void _toggleFullscreen() {
    if (_isFullscreen) {
      Navigator.of(context).pop();
      setState(() {
        _isFullscreen = false;
      });
    } else {
      setState(() {
        _isFullscreen = true;
      });
      Navigator.of(context)
          .push(
        PageRouteBuilder(
          opaque: true,
          barrierColor: Colors.black,
          pageBuilder: (context, _, __) => _FullscreenVideoView(
            controller: _controller,
            embedUrl: _embedUrl,
            aspectRatio: _aspectRatio,
            onExit: () {
              Navigator.of(context).pop();
              setState(() {
                _isFullscreen = false;
              });
            },
          ),
        ),
      )
          .then((_) {
        if (mounted) {
          setState(() {
            _isFullscreen = false;
          });
        }
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final controller = _controller;
    final embedUrl = _embedUrl;

    final videoWidget = Container(
      decoration: BoxDecoration(
        color: Colors.black,
        borderRadius: BorderRadius.circular(24),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.08),
            blurRadius: 26,
            offset: const Offset(0, 14),
          ),
        ],
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(24),
        child: embedUrl != null
            ? _buildEmbeddedView(embedUrl)
            : AspectRatio(
                aspectRatio: _aspectRatio,
                child: controller == null
                    ? _buildPlaceholder()
                    : FutureBuilder<void>(
                        future: _initialize,
                        builder: (context, snapshot) {
                          if (snapshot.connectionState ==
                              ConnectionState.waiting) {
                            return _buildLoading();
                          }
                          if (_initializationFailed ||
                              !controller.value.isInitialized) {
                            return _buildPlaceholder();
                          }
                          return ValueListenableBuilder<VideoPlayerValue>(
                            valueListenable: controller,
                            builder: (context, value, _) {
                              return _buildPlayer(controller, value);
                            },
                          );
                        },
                      ),
              ),
      ),
    );

    return videoWidget;
  }

  Widget _buildEmbeddedView(String url) {
    return Stack(
      fit: StackFit.expand,
      children: [
        Positioned.fill(
          child: Container(color: Colors.black),
        ),
        Positioned.fill(
          child:
              embed.CoachEmbedView(url: url, borderRadius: BorderRadius.zero),
        ),
        Positioned(
          top: 16,
          right: 16,
          child: OutlinedButton.icon(
            style: OutlinedButton.styleFrom(
              foregroundColor: Colors.white,
              side: const BorderSide(color: Colors.white54),
              backgroundColor: Colors.black.withOpacity(0.35),
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(18)),
            ),
            onPressed: _openInNewTab,
            icon: const Icon(Icons.open_in_new_rounded, size: 18),
            label: const Text('Open in new tab'),
          ),
        ),
      ],
    );
  }

  Widget _buildPlayer(
      VideoPlayerController controller, VideoPlayerValue value) {
    final position = _formatDuration(value.position);
    final duration = value.duration == Duration.zero
        ? '--:--'
        : _formatDuration(value.duration);

    return Stack(
      alignment: Alignment.center,
      children: [
        Positioned.fill(
          child: FittedBox(
            fit: BoxFit.cover,
            child: SizedBox(
              width: value.size.width,
              height: value.size.height,
              child: VideoPlayer(controller),
            ),
          ),
        ),
        Positioned.fill(
          child: Material(
            color: Colors.transparent,
            child: InkWell(
              onTap: _togglePlayPause,
            ),
          ),
        ),
        if (!value.isPlaying)
          Positioned(
            child: IgnorePointer(
              ignoring: true,
              child: Container(
                decoration: BoxDecoration(
                  color: Colors.black.withOpacity(0.45),
                  shape: BoxShape.circle,
                ),
                padding: const EdgeInsets.all(20),
                child: const Icon(
                  Icons.play_arrow_rounded,
                  color: Colors.white,
                  size: 48,
                ),
              ),
            ),
          ),
        Positioned(
          left: 16,
          right: 16,
          bottom: 16,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              VideoProgressIndicator(
                controller,
                allowScrubbing: true,
                colors: VideoProgressColors(
                  playedColor: ContentLibraryPage._buttonBlue,
                  bufferedColor: Colors.white.withOpacity(0.3),
                  backgroundColor: Colors.white24,
                ),
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  _ControlChip(
                    icon: value.isPlaying
                        ? Icons.pause_rounded
                        : Icons.play_arrow_rounded,
                    label: value.isPlaying ? 'Pause' : 'Play',
                    onTap: _togglePlayPause,
                  ),
                  const SizedBox(width: 8),
                  _ControlChip(
                    icon: Icons.replay_10_rounded,
                    label: '-10s',
                    onTap: _skipBackward,
                  ),
                  const SizedBox(width: 8),
                  _ControlChip(
                    icon: Icons.forward_10_rounded,
                    label: '+10s',
                    onTap: _skipForward,
                  ),
                  const SizedBox(width: 8),
                  _ControlChip(
                    icon: value.volume == 0
                        ? Icons.volume_off_rounded
                        : Icons.volume_up_rounded,
                    label: value.volume == 0 ? 'Unmute' : 'Mute',
                    onTap: _toggleMute,
                  ),
                  const SizedBox(width: 8),
                  _ControlChip(
                    icon: Icons.speed_rounded,
                    label: '${_playbackSpeed}x',
                    onTap: _changePlaybackSpeed,
                  ),
                  const SizedBox(width: 8),
                  _ControlChip(
                    icon: _isFullscreen
                        ? Icons.fullscreen_exit_rounded
                        : Icons.fullscreen_rounded,
                    label: _isFullscreen ? 'Exit' : 'Full',
                    onTap: _toggleFullscreen,
                  ),
                  const Spacer(),
                  Text(
                    '$position / $duration',
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 12,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildLoading() {
    return const Center(
      child: SizedBox(
        width: 40,
        height: 40,
        child: CircularProgressIndicator(
          valueColor:
              AlwaysStoppedAnimation<Color>(ContentLibraryPage._buttonBlue),
        ),
      ),
    );
  }

  Widget _buildPlaceholder() {
    final thumbnail = widget.course.thumbnailUrl;
    final accent = widget.course.thumbnailColor;

    return Stack(
      fit: StackFit.expand,
      children: [
        if (thumbnail != null && thumbnail.isNotEmpty)
          Image.network(
            thumbnail,
            fit: BoxFit.cover,
            errorBuilder: (context, error, stackTrace) {
              return Container(color: accent);
            },
          )
        else
          Container(
            decoration: BoxDecoration(
              gradient: LinearGradient(
                colors: [
                  accent,
                  accent.withOpacity(0.8),
                ],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
            ),
          ),
        Container(color: Colors.black.withOpacity(0.45)),
        const Center(
          child: Icon(
            Icons.play_circle_fill_rounded,
            color: Colors.white,
            size: 68,
          ),
        ),
        Positioned(
          left: 24,
          right: 24,
          bottom: 24,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (_initializationFailed)
                const Text(
                  'We couldn\'t load this video automatically.',
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 13,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              if ((_downloadUri ?? _videoUri) != null) ...[
                const SizedBox(height: 12),
                OutlinedButton.icon(
                  onPressed: _openInNewTab,
                  style: OutlinedButton.styleFrom(
                    foregroundColor: Colors.white,
                    side: const BorderSide(color: Colors.white70),
                    backgroundColor: Colors.white.withOpacity(0.12),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(18)),
                  ),
                  icon: const Icon(Icons.open_in_new_rounded),
                  label: const Text('Open video in a new tab'),
                ),
              ],
              if ((_downloadUri ?? _videoUri) == null &&
                  _initializationFailed) ...[
                const SizedBox(height: 12),
                const Text(
                  'No video source is available yet.',
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 12,
                  ),
                ),
              ],
            ],
          ),
        ),
      ],
    );
  }

  String _formatDuration(Duration duration) {
    final minutes = duration.inMinutes.remainder(60).toString().padLeft(2, '0');
    final seconds = duration.inSeconds.remainder(60).toString().padLeft(2, '0');
    final hours = duration.inHours;
    if (hours > 0) {
      return '${hours.toString().padLeft(2, '0')}:$minutes:$seconds';
    }
    return '$minutes:$seconds';
  }

  bool _prefersEmbed(Uri uri) {
    final host = uri.host.toLowerCase();
    if (host.contains('youtube.') || host == 'youtu.be') {
      return true;
    }
    if (host.contains('vimeo.')) {
      return true;
    }
    if (host.contains('loom.com')) {
      return true;
    }
    if (host.contains('wistia') ||
        host.contains('streamable') ||
        host.contains('vidyard')) {
      return true;
    }

    final lastSegment = uri.pathSegments.isEmpty ? '' : uri.pathSegments.last;
    if (lastSegment.contains('.')) {
      final extension = lastSegment.split('.').last.toLowerCase();
      const playableExtensions = <String>{
        'mp4',
        'webm',
        'm4v',
        'mov',
        'm3u8',
        'avi',
        'mkv'
      };
      if (playableExtensions.contains(extension)) {
        return false;
      }
    }

    return false;
  }

  String _normalizeEmbedUrl(String rawUrl) {
    final url = rawUrl.trim();
    final uri = Uri.tryParse(url);
    if (uri == null) {
      return url;
    }
    final host = uri.host.toLowerCase();

    if (host == 'youtu.be') {
      final id = uri.pathSegments.isNotEmpty ? uri.pathSegments.last : '';
      return id.isEmpty ? url : 'https://www.youtube.com/embed/$id';
    }
    if (host.contains('youtube.')) {
      final id = uri.queryParameters['v'] ??
          (uri.pathSegments.contains('embed') ? uri.pathSegments.last : null);
      if (id != null && id.isNotEmpty) {
        return 'https://www.youtube.com/embed/$id';
      }
      return url;
    }
    if (host.contains('vimeo.')) {
      final id = uri.pathSegments.isNotEmpty ? uri.pathSegments.last : '';
      return id.isEmpty ? url : 'https://player.vimeo.com/video/$id';
    }
    if (host.contains('loom.com')) {
      final segments = uri.pathSegments;
      if (segments.contains('share')) {
        final index = segments.indexOf('share');
        if (index >= 0 && index < segments.length - 1) {
          final id = segments[index + 1];
          return 'https://www.loom.com/embed/$id';
        }
      }
      if (segments.contains('embed')) {
        return url;
      }
      if (segments.isNotEmpty) {
        return 'https://www.loom.com/embed/${segments.last}';
      }
    }
    if (host.contains('wistia')) {
      final id = uri.pathSegments.isNotEmpty ? uri.pathSegments.last : '';
      return id.isEmpty ? url : 'https://fast.wistia.net/embed/iframe/$id';
    }
    if (host.contains('streamable.com')) {
      final id = uri.pathSegments.isNotEmpty ? uri.pathSegments.last : '';
      return id.isEmpty ? url : 'https://streamable.com/e/$id';
    }
    if (host.contains('vidyard.com')) {
      final id = uri.pathSegments.isNotEmpty ? uri.pathSegments.last : '';
      return id.isEmpty ? url : 'https://play.vidyard.com/$id.html';
    }

    return url;
  }
}

class _FullscreenVideoView extends StatelessWidget {
  const _FullscreenVideoView({
    required this.controller,
    required this.embedUrl,
    required this.aspectRatio,
    required this.onExit,
  });

  final VideoPlayerController? controller;
  final String? embedUrl;
  final double aspectRatio;
  final VoidCallback onExit;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      body: SafeArea(
        child: Stack(
          children: [
            Center(
              child: embedUrl != null
                  ? embed.CoachEmbedView(
                      url: embedUrl!, borderRadius: BorderRadius.zero)
                  : controller != null && controller!.value.isInitialized
                      ? AspectRatio(
                          aspectRatio: aspectRatio,
                          child: VideoPlayer(controller!),
                        )
                      : const Center(
                          child: Text(
                            'Video not available',
                            style: TextStyle(color: Colors.white),
                          ),
                        ),
            ),
            Positioned(
              top: 16,
              right: 16,
              child: IconButton(
                icon: const Icon(Icons.fullscreen_exit_rounded,
                    color: Colors.white, size: 32),
                onPressed: onExit,
                tooltip: 'Exit Fullscreen',
                style: IconButton.styleFrom(
                  backgroundColor: Colors.black.withOpacity(0.5),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _ControlChip extends StatelessWidget {
  const _ControlChip(
      {required this.icon, required this.label, required this.onTap});

  final IconData icon;
  final String label;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      borderRadius: BorderRadius.circular(18),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(18),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
          decoration: BoxDecoration(
            color: Colors.white.withOpacity(0.12),
            borderRadius: BorderRadius.circular(18),
            border: Border.all(color: Colors.white.withOpacity(0.2)),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(icon, size: 18, color: Colors.white),
              const SizedBox(width: 8),
              Text(
                label,
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 12,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _CommunityComposer extends StatefulWidget {
  const _CommunityComposer({required this.course});

  final _LibraryCardData course;

  @override
  State<_CommunityComposer> createState() => _CommunityComposerState();
}

class _CommunityComposerState extends State<_CommunityComposer> {
  final TextEditingController _commentController = TextEditingController();
  bool _isPosting = false;
  final List<PlatformFile> _selectedFiles = [];
  double _uploadProgress = 0.0;

  @override
  void dispose() {
    _commentController.dispose();
    super.dispose();
  }

  Future<void> _pickMedia() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: [
          'jpg',
          'jpeg',
          'png',
          'gif',
          'mp4',
          'mov',
          'pdf',
          'doc',
          'docx'
        ],
        allowMultiple: true,
        withData: true,
      );

      if (result != null && result.files.isNotEmpty) {
        setState(() {
          _selectedFiles.addAll(result.files);
        });
      }
    } catch (e) {
      debugPrint('Error picking media: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error selecting file: $e')),
        );
      }
    }
  }

  void _removeFile(int index) {
    setState(() {
      _selectedFiles.removeAt(index);
    });
  }

  String _formatFileSize(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
  }

  Future<void> _postComment() async {
    final text = _commentController.text.trim();
    if (text.isEmpty && _selectedFiles.isEmpty) return;

    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) return;

    setState(() {
      _isPosting = true;
      _uploadProgress = 0.0;
    });

    try {
      // Fetch user data
      final userDoc =
          await FirebaseFirestore.instance.collection('users').doc(uid).get();
      final userData = userDoc.data();
      String userName = 'User';
      if (userData != null) {
        final firstName = userData['firstName'] as String?;
        final lastName = userData['lastName'] as String?;
        if (firstName != null || lastName != null) {
          userName = '${firstName ?? ''} ${lastName ?? ''}'.trim();
        } else if (userData['displayName'] != null) {
          userName = userData['displayName'] as String;
        } else if (userData['email'] != null) {
          userName = (userData['email'] as String).split('@').first;
        }
      }

      // Upload files to Firebase Storage
      final uploadedMedia = <Map<String, dynamic>>[];
      for (int i = 0; i < _selectedFiles.length; i++) {
        final file = _selectedFiles[i];
        if (file.bytes == null) continue;

        final fileName =
            '${DateTime.now().millisecondsSinceEpoch}_${file.name}';
        final storagePath = 'content_comments/${widget.course.id}/$fileName';
        final storageRef = FirebaseStorage.instance.ref().child(storagePath);

        final uploadTask = storageRef.putData(file.bytes!);

        uploadTask.snapshotEvents.listen((snapshot) {
          setState(() {
            _uploadProgress =
                (i + (snapshot.bytesTransferred / snapshot.totalBytes)) /
                    _selectedFiles.length;
          });
        });

        final snapshot = await uploadTask;
        final downloadUrl = await snapshot.ref.getDownloadURL();

        uploadedMedia.add({
          'url': downloadUrl,
          'fileName': file.name,
          'fileSize': file.size,
          'fileType': _getFileType(file.extension),
        });
      }

      // Post comment to video_comments collection
      await FirebaseFirestore.instance.collection('video_comments').add({
        'videoId': widget.course.id,
        'userId': uid,
        'userName': userName,
        'comment': text,
        'media': uploadedMedia,
        'timestamp': FieldValue.serverTimestamp(),
      });

      _commentController.clear();
      setState(() {
        _selectedFiles.clear();
      });

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Comment posted successfully!')),
        );
      }
    } catch (e) {
      debugPrint('Failed to post comment: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
              content: Text('Failed to post comment. Please try again.')),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isPosting = false;
          _uploadProgress = 0.0;
        });
      }
    }
  }

  String _getFileType(String? extension) {
    if (extension == null) return 'file';
    final ext = extension.toLowerCase();
    if (['jpg', 'jpeg', 'png', 'gif', 'webp'].contains(ext)) return 'image';
    if (['mp4', 'mov', 'avi', 'webm'].contains(ext)) return 'video';
    if (['pdf'].contains(ext)) return 'pdf';
    if (['doc', 'docx'].contains(ext)) return 'document';
    return 'file';
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: ContentLibraryPage._borderColor),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Community Discussion',
            style: TextStyle(
              color: ContentLibraryPage._titleColor,
              fontSize: 18,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 20),
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const CircleAvatar(
                radius: 20,
                backgroundColor: Color(0xFFE5E7EB),
                child: Icon(Icons.person_outline,
                    color: Color(0xFF6B7280), size: 20),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    TextField(
                      controller: _commentController,
                      maxLines: 3,
                      decoration: InputDecoration(
                        hintText: 'Share your thoughts or ask a question...',
                        filled: true,
                        fillColor: const Color(0xFFF9FAFB),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(16),
                          borderSide: const BorderSide(
                              color: ContentLibraryPage._borderColor),
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(16),
                          borderSide: const BorderSide(
                              color: ContentLibraryPage._buttonBlue),
                        ),
                        contentPadding: const EdgeInsets.all(16),
                      ),
                    ),
                    // Selected files preview
                    if (_selectedFiles.isNotEmpty) ...[
                      const SizedBox(height: 12),
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: _selectedFiles.asMap().entries.map((entry) {
                          final index = entry.key;
                          final file = entry.value;
                          final isImage = ['jpg', 'jpeg', 'png', 'gif', 'webp']
                              .contains(file.extension?.toLowerCase());

                          return Container(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 12, vertical: 8),
                            decoration: BoxDecoration(
                              color: const Color(0xFFF3F4F6),
                              borderRadius: BorderRadius.circular(12),
                              border: Border.all(
                                  color: ContentLibraryPage._borderColor),
                            ),
                            child: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                if (isImage && file.bytes != null)
                                  ClipRRect(
                                    borderRadius: BorderRadius.circular(6),
                                    child: Image.memory(
                                      file.bytes!,
                                      width: 32,
                                      height: 32,
                                      fit: BoxFit.cover,
                                    ),
                                  )
                                else
                                  Icon(
                                    _getFileIcon(file.extension),
                                    size: 20,
                                    color: ContentLibraryPage._mutedColor,
                                  ),
                                const SizedBox(width: 8),
                                ConstrainedBox(
                                  constraints:
                                      const BoxConstraints(maxWidth: 120),
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      Text(
                                        file.name,
                                        style: const TextStyle(
                                          fontSize: 12,
                                          fontWeight: FontWeight.w500,
                                          color: ContentLibraryPage._titleColor,
                                        ),
                                        maxLines: 1,
                                        overflow: TextOverflow.ellipsis,
                                      ),
                                      Text(
                                        _formatFileSize(file.size),
                                        style: TextStyle(
                                          fontSize: 10,
                                          color: ContentLibraryPage._mutedColor,
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                                const SizedBox(width: 8),
                                InkWell(
                                  onTap: () => _removeFile(index),
                                  borderRadius: BorderRadius.circular(12),
                                  child: const Icon(Icons.close,
                                      size: 16, color: Color(0xFF6B7280)),
                                ),
                              ],
                            ),
                          );
                        }).toList(),
                      ),
                    ],
                    // Upload progress
                    if (_isPosting && _selectedFiles.isNotEmpty) ...[
                      const SizedBox(height: 8),
                      LinearProgressIndicator(
                        value: _uploadProgress,
                        backgroundColor: ContentLibraryPage._borderColor,
                        borderRadius: BorderRadius.circular(4),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        'Uploading... ${(_uploadProgress * 100).toStringAsFixed(0)}%',
                        style: TextStyle(
                          fontSize: 12,
                          color: ContentLibraryPage._mutedColor,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              const SizedBox(width: 12),
              Column(
                children: [
                  IconButton(
                    onPressed: _isPosting ? null : _pickMedia,
                    icon: const Icon(Icons.attach_file_rounded),
                    tooltip: 'Attach file',
                    style: IconButton.styleFrom(
                      backgroundColor: const Color(0xFFF3F4F6),
                      foregroundColor: ContentLibraryPage._mutedColor,
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12)),
                    ),
                  ),
                  const SizedBox(height: 8),
                  ElevatedButton(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: ContentLibraryPage._buttonBlue,
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(
                          horizontal: 24, vertical: 16),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(16)),
                    ),
                    onPressed: _isPosting ? null : _postComment,
                    child: _isPosting
                        ? const SizedBox(
                            width: 16,
                            height: 16,
                            child: CircularProgressIndicator(
                              color: Colors.white,
                              strokeWidth: 2,
                            ),
                          )
                        : const Text('Post'),
                  ),
                ],
              ),
            ],
          ),
          const SizedBox(height: 28),
          const Divider(color: ContentLibraryPage._borderColor),
          const SizedBox(height: 20),
          _CommentsList(videoId: widget.course.id),
        ],
      ),
    );
  }

  IconData _getFileIcon(String? extension) {
    if (extension == null) return Icons.insert_drive_file;
    final ext = extension.toLowerCase();
    if (['jpg', 'jpeg', 'png', 'gif', 'webp'].contains(ext)) return Icons.image;
    if (['mp4', 'mov', 'avi', 'webm'].contains(ext)) return Icons.videocam;
    if (['pdf'].contains(ext)) return Icons.picture_as_pdf;
    if (['doc', 'docx'].contains(ext)) return Icons.description;
    return Icons.insert_drive_file;
  }
}

class _CommentItem extends StatefulWidget {
  const _CommentItem({
    required this.commentId,
    required this.userId,
    required this.userName,
    required this.comment,
    required this.timeAgo,
  });

  final String commentId;
  final String userId;
  final String userName;
  final String comment;
  final String timeAgo;

  @override
  State<_CommentItem> createState() => _CommentItemState();
}

class _CommentItemState extends State<_CommentItem> {
  bool _isEditing = false;
  late TextEditingController _editController;

  @override
  void initState() {
    super.initState();
    _editController = TextEditingController(text: widget.comment);
  }

  @override
  void dispose() {
    _editController.dispose();
    super.dispose();
  }

  bool get _isOwnComment {
    final currentUserId = FirebaseAuth.instance.currentUser?.uid;
    return currentUserId != null && currentUserId == widget.userId;
  }

  Future<void> _deleteComment() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Comment'),
        content: const Text(
            'Are you sure you want to delete this comment? This action cannot be undone.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Delete'),
          ),
        ],
      ),
    );

    if (confirmed != true) return;

    try {
      await FirebaseFirestore.instance
          .collection('video_comments')
          .doc(widget.commentId)
          .delete();

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Comment deleted successfully')),
        );
      }
    } catch (e) {
      debugPrint('Failed to delete comment: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
              content: Text('Failed to delete comment. Please try again.')),
        );
      }
    }
  }

  Future<void> _saveEdit() async {
    final newText = _editController.text.trim();
    if (newText.isEmpty) return;

    try {
      await FirebaseFirestore.instance
          .collection('video_comments')
          .doc(widget.commentId)
          .update({'comment': newText});

      if (mounted) {
        setState(() => _isEditing = false);
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Comment updated successfully')),
        );
      }
    } catch (e) {
      debugPrint('Failed to update comment: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
              content: Text('Failed to update comment. Please try again.')),
        );
      }
    }
  }

  void _cancelEdit() {
    setState(() {
      _isEditing = false;
      _editController.text = widget.comment;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 20),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          CircleAvatar(
            radius: 18,
            backgroundColor: const Color(0xFFE5E7EB),
            child: Text(
              widget.userName.isNotEmpty
                  ? widget.userName[0].toUpperCase()
                  : 'U',
              style: const TextStyle(
                color: ContentLibraryPage._titleColor,
                fontWeight: FontWeight.w600,
                fontSize: 14,
              ),
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Text(
                      widget.userName,
                      style: const TextStyle(
                        color: ContentLibraryPage._titleColor,
                        fontWeight: FontWeight.w600,
                        fontSize: 14,
                      ),
                    ),
                    const SizedBox(width: 8),
                    Text(
                      widget.timeAgo,
                      style: const TextStyle(
                        color: ContentLibraryPage._mutedColor,
                        fontSize: 12,
                      ),
                    ),
                    if (_isOwnComment) ...[
                      const Spacer(),
                      PopupMenuButton<String>(
                        icon: const Icon(
                          Icons.more_horiz,
                          color: ContentLibraryPage._mutedColor,
                          size: 20,
                        ),
                        onSelected: (value) {
                          if (value == 'edit') {
                            setState(() => _isEditing = true);
                          } else if (value == 'delete') {
                            _deleteComment();
                          }
                        },
                        itemBuilder: (context) => [
                          const PopupMenuItem(
                            value: 'edit',
                            child: Row(
                              children: [
                                Icon(Icons.edit_outlined,
                                    size: 18,
                                    color: ContentLibraryPage._mutedColor),
                                SizedBox(width: 8),
                                Text('Edit'),
                              ],
                            ),
                          ),
                          const PopupMenuItem(
                            value: 'delete',
                            child: Row(
                              children: [
                                Icon(Icons.delete_outline,
                                    size: 18, color: Colors.red),
                                SizedBox(width: 8),
                                Text('Delete',
                                    style: TextStyle(color: Colors.red)),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ],
                  ],
                ),
                const SizedBox(height: 6),
                if (_isEditing)
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      TextField(
                        controller: _editController,
                        maxLines: 3,
                        autofocus: true,
                        decoration: InputDecoration(
                          filled: true,
                          fillColor: const Color(0xFFF9FAFB),
                          border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(12),
                            borderSide: const BorderSide(
                                color: ContentLibraryPage._borderColor),
                          ),
                          focusedBorder: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(12),
                            borderSide: const BorderSide(
                                color: ContentLibraryPage._buttonBlue),
                          ),
                          contentPadding: const EdgeInsets.all(12),
                        ),
                      ),
                      const SizedBox(height: 8),
                      Row(
                        children: [
                          ElevatedButton(
                            style: ElevatedButton.styleFrom(
                              backgroundColor: ContentLibraryPage._buttonBlue,
                              foregroundColor: Colors.white,
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 16, vertical: 8),
                              shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8)),
                            ),
                            onPressed: _saveEdit,
                            child: const Text('Save'),
                          ),
                          const SizedBox(width: 8),
                          TextButton(
                            style: TextButton.styleFrom(
                              foregroundColor: ContentLibraryPage._mutedColor,
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 16, vertical: 8),
                            ),
                            onPressed: _cancelEdit,
                            child: const Text('Cancel'),
                          ),
                        ],
                      ),
                    ],
                  )
                else
                  Text(
                    widget.comment,
                    style: const TextStyle(
                      color: ContentLibraryPage._titleColor,
                      fontSize: 14,
                      height: 1.5,
                    ),
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _CommentsList extends StatelessWidget {
  const _CommentsList({required this.videoId});

  final String videoId;

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
      stream: FirebaseFirestore.instance
          .collection('video_comments')
          .where('videoId', isEqualTo: videoId)
          .limit(20)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          debugPrint('Comments error: ${snapshot.error}');
          return Container(
            padding: const EdgeInsets.all(20),
            alignment: Alignment.center,
            child: const Text(
              'No comments yet. Be the first to share your thoughts!',
              style: TextStyle(
                color: ContentLibraryPage._mutedColor,
                fontSize: 14,
              ),
            ),
          );
        }

        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(
            child: Padding(
              padding: EdgeInsets.all(20),
              child: CircularProgressIndicator(strokeWidth: 2),
            ),
          );
        }

        var comments = snapshot.data?.docs ?? [];

        // Sort by timestamp if available
        comments.sort((a, b) {
          final aData = a.data();
          final bData = b.data();
          final aTimestamp = aData['timestamp'];
          final bTimestamp = bData['timestamp'];
          if (aTimestamp == null) return 1;
          if (bTimestamp == null) return -1;
          return (bTimestamp as Timestamp).compareTo(aTimestamp as Timestamp);
        });

        if (comments.isEmpty) {
          return Container(
            padding: const EdgeInsets.all(20),
            alignment: Alignment.center,
            child: const Text(
              'No comments yet. Be the first to share your thoughts!',
              style: TextStyle(
                color: ContentLibraryPage._mutedColor,
                fontSize: 14,
              ),
            ),
          );
        }

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '${comments.length} ${comments.length == 1 ? 'Comment' : 'Comments'}',
              style: const TextStyle(
                color: ContentLibraryPage._titleColor,
                fontSize: 15,
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 16),
            ConstrainedBox(
              constraints: const BoxConstraints(maxHeight: 600),
              child: ListView(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                children: comments.map((doc) {
                  final data = doc.data();
                  final userName =
                      data['userName'] as String? ?? 'Unknown User';
                  final comment = data['comment'] as String? ?? '';
                  final timestamp = data['timestamp'] as Timestamp?;

                  String timeAgo = 'Just now';
                  if (timestamp != null) {
                    final diff = DateTime.now().difference(timestamp.toDate());
                    if (diff.inDays > 0) {
                      timeAgo = '${diff.inDays}d ago';
                    } else if (diff.inHours > 0) {
                      timeAgo = '${diff.inHours}h ago';
                    } else if (diff.inMinutes > 0) {
                      timeAgo = '${diff.inMinutes}m ago';
                    }
                  }

                  return _CommentItem(
                    commentId: doc.id,
                    userId: data['userId'] as String? ?? '',
                    userName: userName,
                    comment: comment,
                    timeAgo: timeAgo,
                  );
                }).toList(),
              ),
            ),
          ],
        );
      },
    );
  }
}

class _SuggestionCard extends StatelessWidget {
  const _SuggestionCard(
      {required this.data, required this.onTap, required this.onDownload});

  final _LibraryCardData data;
  final VoidCallback onTap;
  final VoidCallback onDownload;

  @override
  Widget build(BuildContext context) {
    // Always allow attempting a download; resolver will fetch from Firestore on tap.
    const bool canDownload = true;
    return SizedBox(
      width: 220,
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(20),
          onTap: onTap,
          child: Container(
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(20),
              border: Border.all(color: ContentLibraryPage._borderColor),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                ClipRRect(
                  borderRadius:
                      const BorderRadius.vertical(top: Radius.circular(20)),
                  child: SizedBox(
                    height: 110,
                    child: Stack(
                      fit: StackFit.expand,
                      children: [
                        if (data.thumbnailUrl != null)
                          Image.network(
                            data.thumbnailUrl!,
                            fit: BoxFit.cover,
                            errorBuilder: (context, error, stackTrace) =>
                                Container(color: const Color(0xFF1F2937)),
                          )
                        else
                          Container(color: const Color(0xFF1F2937)),
                        const Align(
                          alignment: Alignment.center,
                          child: Icon(Icons.play_circle_fill,
                              color: Colors.white, size: 44),
                        ),
                      ],
                    ),
                  ),
                ),
                Expanded(
                  child: Padding(
                    padding: const EdgeInsets.fromLTRB(16, 14, 16, 12),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          _truncateToCharacters(data.title, 26),
                          style: const TextStyle(
                            color: ContentLibraryPage._titleColor,
                            fontWeight: FontWeight.w600,
                            fontSize: 13,
                          ),
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                        ),
                        const SizedBox(height: 6),
                        Flexible(
                          fit: FlexFit.loose,
                          child: Text(
                            _truncateToWords(data.subtitle, 12),
                            style: const TextStyle(
                              color: ContentLibraryPage._mutedColor,
                              fontSize: 12,
                              height: 1.4,
                            ),
                            maxLines: 3,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        const SizedBox(height: 8),
                        SizedBox(
                          width: double.infinity,
                          child: OutlinedButton(
                            onPressed: onDownload,
                            style: OutlinedButton.styleFrom(
                              minimumSize: const Size.fromHeight(36),
                              foregroundColor: ContentLibraryPage._buttonBlue,
                              side: const BorderSide(
                                  color: ContentLibraryPage._buttonBlue),
                              shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(12)),
                            ),
                            child: const Text('Download'),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class _FirestoreStatusMessage extends StatelessWidget {
  const _FirestoreStatusMessage({required this.icon, required this.message});

  final IconData icon;
  final String message;

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(22),
        border: Border.all(color: ContentLibraryPage._borderColor),
      ),
      child: Row(
        children: [
          Icon(icon, color: ContentLibraryPage._mutedColor),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              message,
              style: const TextStyle(
                color: ContentLibraryPage._mutedColor,
                fontSize: 14,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _FilterChip extends StatelessWidget {
  const _FilterChip({
    required this.label,
    required this.backgroundColor,
    required this.onPressed,
    this.textColor = Colors.white,
    this.borderColor,
    this.isActive = false,
  });

  final String label;
  final Color backgroundColor;
  final Color textColor;
  final Color? borderColor;
  final bool isActive;
  final VoidCallback onPressed;

  @override
  Widget build(BuildContext context) {
    final Color resolvedBorderColor = borderColor ?? backgroundColor;
    final Color resolvedFill = isActive
        ? backgroundColor
        : backgroundColor.withOpacity(
            backgroundColor.opacity == 1 ? 0.85 : backgroundColor.opacity);

    return Material(
      color: Colors.transparent,
      child: InkWell(
        borderRadius: BorderRadius.circular(28),
        onTap: onPressed,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
          decoration: BoxDecoration(
            color: resolvedFill,
            borderRadius: BorderRadius.circular(28),
            border: Border.all(
              color: isActive
                  ? ContentLibraryPage._buttonBlue
                  : resolvedBorderColor,
              width: isActive ? 1.6 : 1,
            ),
            boxShadow: isActive
                ? [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.08),
                      blurRadius: 10,
                      offset: const Offset(0, 4),
                    ),
                  ]
                : null,
          ),
          child: Text(
            label,
            style: TextStyle(
              color: textColor,
              fontSize: 14,
              fontWeight: FontWeight.w700,
              letterSpacing: 0.5,
            ),
          ),
        ),
      ),
    );
  }
}

class _LibraryCard extends StatelessWidget {
  const _LibraryCard({
    required this.data,
    this.isAdmin = false,
    this.onTap,
    this.onDownloadTap,
    this.onDeleteTap,
    this.onEdit,
  });

  final _LibraryCardData data;
  final bool isAdmin;
  final VoidCallback? onTap;
  final VoidCallback? onDownloadTap;
  final VoidCallback? onDeleteTap;
  final VoidCallback? onEdit;

  @override
  Widget build(BuildContext context) {
    final String title = _truncateToCharacters(data.title, 20);
    final String subtitle = _truncateToWords(data.subtitle, 15);
    final bool hasImage =
        data.thumbnailUrl != null || data.thumbnailAsset != null;
    final Color overlayBaseColor =
        hasImage ? Colors.black : data.thumbnailColor;
    final Color primaryTextColor = hasImage
        ? Colors.white
        : (data.thumbnailColor.computeLuminance() > 0.5
            ? ContentLibraryPage._titleColor
            : Colors.white);
    final Color secondaryTextColor = hasImage
        ? Colors.white70
        : (data.thumbnailColor.computeLuminance() > 0.5
            ? ContentLibraryPage._mutedColor
            : Colors.white70);
    // Always allow attempting a download; resolver will fetch from Firestore on tap.
    const bool canDownload = true;

    return Material(
      color: Colors.transparent,
      child: InkWell(
        borderRadius: BorderRadius.circular(22),
        onTap: onTap,
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(22),
            border: Border.all(color: ContentLibraryPage._borderColor),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 12,
                offset: const Offset(0, 6),
              ),
            ],
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              ClipRRect(
                borderRadius:
                    const BorderRadius.vertical(top: Radius.circular(22)),
                child: SizedBox(
                  height: 150,
                  child: Stack(
                    fit: StackFit.expand,
                    children: [
                      if (data.thumbnailUrl != null)
                        Image.network(
                          data.thumbnailUrl!,
                          fit: BoxFit.cover,
                          errorBuilder: (context, error, stackTrace) =>
                              Container(color: data.thumbnailColor),
                          loadingBuilder: (context, child, loadingProgress) {
                            if (loadingProgress == null) {
                              return child;
                            }
                            return Container(
                              color: data.thumbnailColor,
                              alignment: Alignment.center,
                              child: const SizedBox(
                                width: 24,
                                height: 24,
                                child:
                                    CircularProgressIndicator(strokeWidth: 2),
                              ),
                            );
                          },
                        )
                      else if (data.thumbnailAsset != null)
                        Image.asset(
                          data.thumbnailAsset!,
                          fit: BoxFit.cover,
                        )
                      else
                        Container(color: data.thumbnailColor),
                      DecoratedBox(
                        decoration: BoxDecoration(
                          gradient: LinearGradient(
                            begin: Alignment.topCenter,
                            end: Alignment.bottomCenter,
                            colors: hasImage
                                ? [
                                    overlayBaseColor.withOpacity(0.6),
                                    overlayBaseColor.withOpacity(0.2)
                                  ]
                                : [
                                    overlayBaseColor.withOpacity(0.92),
                                    overlayBaseColor.withOpacity(0.5)
                                  ],
                          ),
                        ),
                      ),
                      const Align(
                        alignment: Alignment.center,
                        child: Icon(
                          Icons.play_circle_fill,
                          color: Colors.white,
                          size: 48,
                        ),
                      ),
                      Padding(
                        padding: const EdgeInsets.all(20),
                        child: Stack(
                          children: [
                            if (data.overlayTitle != null)
                              Positioned(
                                left: 0,
                                top: 0,
                                right: data.badgeLabel != null ? 100 : 0,
                                child: Text(
                                  data.overlayTitle!,
                                  maxLines: 2,
                                  overflow: TextOverflow.ellipsis,
                                  style: TextStyle(
                                    color: primaryTextColor,
                                    fontSize: 15,
                                    fontWeight: FontWeight.w700,
                                  ),
                                ),
                              ),
                            if (data.badgeLabel != null)
                              Positioned(
                                top: 0,
                                right: 0,
                                child: Container(
                                  padding: const EdgeInsets.symmetric(
                                      horizontal: 14, vertical: 6),
                                  decoration: BoxDecoration(
                                    color: const Color(0xFF111827)
                                        .withOpacity(0.9),
                                    borderRadius: BorderRadius.circular(14),
                                  ),
                                  child: Text(
                                    data.badgeLabel!,
                                    style: const TextStyle(
                                      color: Colors.white,
                                      fontSize: 12,
                                      fontWeight: FontWeight.w600,
                                    ),
                                  ),
                                ),
                              ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ),
              Padding(
                padding: const EdgeInsets.fromLTRB(20, 20, 20, 16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: const TextStyle(
                        color: ContentLibraryPage._titleColor,
                        fontSize: 15,
                        fontWeight: FontWeight.w700,
                      ),
                    ),
                    if (subtitle.isNotEmpty) ...[
                      const SizedBox(height: 6),
                      Text(
                        subtitle,
                        style: const TextStyle(
                          color: ContentLibraryPage._mutedColor,
                          fontSize: 13,
                          height: 1.4,
                        ),
                      ),
                    ],
                    if (data.tags.isNotEmpty) ...[
                      const SizedBox(height: 12),
                      Wrap(
                        spacing: 8,
                        runSpacing: 8,
                        children: data.tags
                            .map(
                              (tag) => Container(
                                padding: const EdgeInsets.symmetric(
                                    horizontal: 12, vertical: 6),
                                decoration: BoxDecoration(
                                  color: const Color(0xFFF3F4F6),
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: Text(
                                  tag,
                                  style: const TextStyle(
                                    color: ContentLibraryPage._mutedColor,
                                    fontSize: 12,
                                    fontWeight: FontWeight.w600,
                                  ),
                                ),
                              ),
                            )
                            .toList(),
                      ),
                    ],
                    const SizedBox(height: 16),
                    Wrap(
                      spacing: 16,
                      runSpacing: 12,
                      children: data.meta
                          .map(
                            (meta) => Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Icon(meta.icon,
                                    size: 16,
                                    color: ContentLibraryPage._mutedColor),
                                const SizedBox(width: 6),
                                Text(
                                  meta.label,
                                  style: const TextStyle(
                                    color: ContentLibraryPage._mutedColor,
                                    fontSize: 12,
                                    fontWeight: FontWeight.w600,
                                  ),
                                ),
                              ],
                            ),
                          )
                          .toList(),
                    ),
                    if (data.showButton) ...[
                      const SizedBox(height: 18),
                      SizedBox(
                        width: double.infinity,
                        child: ElevatedButton(
                          style: ElevatedButton.styleFrom(
                            backgroundColor: ContentLibraryPage._buttonBlue,
                            foregroundColor: Colors.white,
                            padding: const EdgeInsets.symmetric(vertical: 16),
                            shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(14)),
                            elevation: 0,
                          ),
                          onPressed: () {},
                          child: const Text(
                            'Continue Learning',
                            style: TextStyle(
                              fontSize: 14,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                      ),
                    ],
                    const SizedBox(height: 14),
                    Row(
                      children: [
                        OutlinedButton.icon(
                          onPressed: onDownloadTap,
                          style: OutlinedButton.styleFrom(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 18, vertical: 12),
                            side: const BorderSide(
                                color: ContentLibraryPage._buttonBlue),
                            foregroundColor: ContentLibraryPage._buttonBlue,
                            shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(14)),
                          ),
                          icon: const Icon(Icons.download_rounded, size: 18),
                          label: const Text(
                            'Download',
                            style: TextStyle(
                                fontWeight: FontWeight.w600, fontSize: 13),
                          ),
                        ),
                        if (isAdmin) ...[
                          if (onEdit != null) ...[
                            const SizedBox(width: 12),
                            IconButton(
                              onPressed: onEdit,
                              icon: const Icon(Icons.edit_outlined, size: 22),
                              style: IconButton.styleFrom(
                                foregroundColor: const Color(0xFF3B82F6),
                                backgroundColor: const Color(0xFFDBEAFE),
                                padding: const EdgeInsets.all(12),
                                shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(12)),
                              ),
                              tooltip: 'Edit content',
                            ),
                          ],
                          if (onDeleteTap != null) ...[
                            const SizedBox(width: 12),
                            IconButton(
                              onPressed: onDeleteTap,
                              icon: const Icon(Icons.delete_outline, size: 22),
                              style: IconButton.styleFrom(
                                foregroundColor: const Color(0xFFEF4444),
                                backgroundColor: const Color(0xFFFEE2E2),
                                padding: const EdgeInsets.all(12),
                                shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(12)),
                              ),
                              tooltip: 'Delete content',
                            ),
                          ],
                        ],
                      ],
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _LibraryFilterChipData {
  const _LibraryFilterChipData({
    required this.label,
    required this.backgroundColor,
    this.textColor = Colors.white,
    this.borderColor,
    this.filterKey,
  });

  final String label;
  final Color backgroundColor;
  final Color textColor;
  final Color? borderColor;
  final String? filterKey;
}

class _LibraryMetaData {
  const _LibraryMetaData({required this.icon, required this.label});

  final IconData icon;
  final String label;
}

class _FormattedDescription extends StatelessWidget {
  const _FormattedDescription({required this.text});

  final String text;

  @override
  Widget build(BuildContext context) {
    if (text.isEmpty) return const SizedBox.shrink();

    final spans = <InlineSpan>[];
    final sentences = text.split('. ');

    for (var i = 0; i < sentences.length; i++) {
      var sentence = sentences[i].trim();
      if (sentence.isEmpty) continue;

      if (!sentence.endsWith('.') &&
          !sentence.endsWith(':') &&
          i < sentences.length - 1) {
        sentence += '.';
      }

      if (sentence.endsWith(':')) {
        if (spans.isNotEmpty) {
          spans.add(const TextSpan(text: '\n\n'));
        }
        spans.add(TextSpan(
          text: sentence,
          style: const TextStyle(
            color: ContentLibraryPage._titleColor,
            fontSize: 16,
            fontWeight: FontWeight.w700,
            height: 1.5,
          ),
        ));
        spans.add(const TextSpan(text: '\n'));
      } else {
        final colonIndex = sentence.indexOf(':');
        if (colonIndex > 0 && colonIndex < 40) {
          final prefix = sentence.substring(0, colonIndex + 1);
          final content = sentence.substring(colonIndex + 1).trim();

          if (spans.isNotEmpty && !spans.last.toPlainText().endsWith('\n\n')) {
            spans.add(const TextSpan(text: '\n'));
          }

          spans.add(TextSpan(
            text: prefix,
            style: const TextStyle(
              color: ContentLibraryPage._titleColor,
              fontSize: 15,
              fontWeight: FontWeight.w700,
              height: 1.7,
            ),
          ));
          spans.add(TextSpan(
            text: ' $content${i < sentences.length - 1 ? '.' : ''}',
            style: const TextStyle(
              color: ContentLibraryPage._mutedColor,
              fontSize: 15,
              height: 1.7,
            ),
          ));
          if (i < sentences.length - 1) {
            spans.add(const TextSpan(text: ' '));
          }
        } else {
          spans.add(TextSpan(
            text: '$sentence${i < sentences.length - 1 ? ' ' : ''}',
            style: const TextStyle(
              color: ContentLibraryPage._mutedColor,
              fontSize: 15,
              height: 1.7,
            ),
          ));
        }
      }
    }

    return Container(
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: const Color(0xFFFAFBFC),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: const Color(0xFFE5E7EB)),
      ),
      child: RichText(
        text: TextSpan(
          style: const TextStyle(
            fontFamily: 'Inter',
            fontSize: 15,
            color: ContentLibraryPage._mutedColor,
            height: 1.7,
          ),
          children: spans,
        ),
      ),
    );
  }
}

class _LibraryCardData {
  _LibraryCardData({
    required this.id,
    required this.title,
    required this.subtitle,
    required this.thumbnailColor,
    required this.meta,
    required this.tags,
    required this.normalizedTags,
    required this.originalData,
    this.overlayTitle,
    this.overlaySubtitle,
    this.badgeLabel,
    this.showButton = false,
    this.thumbnailUrl,
    this.thumbnailAsset,
    this.videoUrl,
    this.downloadUrl,
    this.primaryTopicNormalized,
    this.badgeLabelNormalized,
  });

  final String id;
  final String title;
  final String subtitle;
  final Color thumbnailColor;
  final List<_LibraryMetaData> meta;
  final List<String> tags;
  final List<String> normalizedTags;
  final Map<String, dynamic> originalData;
  final String? overlayTitle;
  final String? overlaySubtitle;
  final String? badgeLabel;
  final bool showButton;
  final String? thumbnailUrl;
  final String? thumbnailAsset;
  final String? videoUrl;
  final String? downloadUrl;
  final String? primaryTopicNormalized;
  final String? badgeLabelNormalized;
}

class _ResolvedCourseMedia {
  const _ResolvedCourseMedia({this.streamUrl, this.downloadUrl});

  final String? streamUrl;
  final String? downloadUrl;

  static const empty = _ResolvedCourseMedia();
}

Future<void> _attemptLibraryCourseDownload(
  BuildContext context,
  _LibraryCardData course,
) async {
  final messenger = ScaffoldMessenger.maybeOf(context);
  _ResolvedCourseMedia media;
  try {
    media = await _CourseMediaResolver.resolve(course);
  } catch (error) {
    debugPrint('Could not resolve download link: $error');
    messenger?.showSnackBar(
      const SnackBar(
          content: Text('Download link not available for this content yet.')),
    );
    return;
  }

  final url = media.downloadUrl ?? media.streamUrl;
  try {
    debugPrint('DownloadAttempt: courseId=${course.id} url=$url');
  } catch (_) {}
  if (url == null || url.isEmpty) {
    messenger?.showSnackBar(
      const SnackBar(
          content: Text('Download link not available for this content yet.')),
    );
    return;
  }

  final uri = Uri.tryParse(url);
  if (uri == null) {
    messenger?.showSnackBar(
      const SnackBar(content: Text('We couldn\'t open the download link.')),
    );
    return;
  }

  try {
    final launched = await launchUrl(
      uri,
      mode: LaunchMode.externalApplication,
    );
    if (!launched) {
      final fallbackLaunched = await launchUrl(
        uri,
        mode: LaunchMode.platformDefault,
        webOnlyWindowName: '_blank',
      );
      if (!fallbackLaunched) {
        messenger?.showSnackBar(
          const SnackBar(
              content: Text('We couldn\'t launch the download link.')),
        );
      }
    } else {
      messenger?.showSnackBar(
        const SnackBar(content: Text('Download started...')),
      );
    }
  } catch (error) {
    debugPrint('Download error: $error');
    messenger?.showSnackBar(
      const SnackBar(
          content: Text('Something went wrong while starting the download.')),
    );
  }
}

// Resolves media URLs for library content, following references into the `video` collection when needed.
class _CourseMediaResolver {
  _CourseMediaResolver._();

  static final Map<String, Future<_ResolvedCourseMedia>> _cache =
      <String, Future<_ResolvedCourseMedia>>{};
  static final Set<String> _backfilledCourseIds = <String>{};

  static const List<String> _videoFieldCandidates = <String>[
    'video',
    'videoRef',
    'videoReference',
    'videoDoc',
    'videoDocRef',
    'videoDocument',
    'videoDocumentRef',
    'videoDownload',
    'media',
    'mediaRef',
    'mediaDocument',
    'mediaItem',
    'content',
    'asset',
  ];

  static const List<String> _videoIdKeys = <String>[
    'videoId',
    'videoDocId',
    'videoDocumentId',
    'mediaId',
    'videoSlug',
  ];

  static const List<String> _streamKeys = <String>[
    'streamUrl',
    'streamLink',
    'playbackUrl',
    'playbackLink',
    'videoUrl',
    'videoURL',
    'contentUrl',
    'mediaUrl',
    'lessonUrl',
    'url',
    'link',
    // Additional common variants
    'hlsUrl',
    'hls',
    'mpdUrl',
    'mp4',
    'mp4Url',
  ];

  static const List<String> _downloadKeys = <String>[
    'downloadLink',
    'downloadURL',
    'downloadUrl',
    'download',
    'fileUrl',
    'fileURL',
    'resourceUrl',
    'resourceURL',
    'archiveUrl',
    'mediaDownloadUrl',
    'videoDownloadUrl',
    // Additional common variants
    'download_link',
    'directUrl',
    'directURL',
    'videoFile',
    'storageUrl',
    'storageURL',
    'storagePath',
  ];

  static Future<_ResolvedCourseMedia> resolve(_LibraryCardData course) {
    final existing = _cache[course.id];
    if (existing != null) {
      return existing;
    }
    final future = _resolveInternal(course);
    _cache[course.id] = future;
    return future;
  }

  static bool mightHaveDownload(_LibraryCardData course) {
    if (_sanitizeUrl(course.downloadUrl) != null) {
      return true;
    }
    if (_sanitizeUrl(course.videoUrl) != null) {
      return true;
    }

    final data = course.originalData;
    for (final key in _videoFieldCandidates) {
      if (_valueSuggestsMedia(data[key])) {
        return true;
      }
    }
    for (final key in _videoIdKeys) {
      final id = _FirestoreCourseGrid._readString(data[key]);
      if (id != null && id.isNotEmpty) {
        return true;
      }
    }
    return false;
  }

  static Future<_ResolvedCourseMedia> _resolveInternal(
      _LibraryCardData course) async {
    String? stream = _sanitizeUrl(course.videoUrl);
    String? download = _sanitizeUrl(course.downloadUrl);

    final queue = Queue<dynamic>();
    final Set<Map<String, dynamic>> visitedMaps = <Map<String, dynamic>>{};
    final Set<String> visitedDocPaths = <String>{};

    void enqueue(dynamic value) {
      if (value == null) {
        return;
      }
      queue.add(value);
    }

    final data = course.originalData;
    for (final key in _videoFieldCandidates) {
      enqueue(data[key]);
    }
    for (final key in _videoIdKeys) {
      final id = _FirestoreCourseGrid._readString(data[key]);
      if (id != null && id.isNotEmpty) {
        enqueue(id);
      }
    }

    while (queue.isNotEmpty && (stream == null || download == null)) {
      final current = queue.removeFirst();
      if (current == null) {
        continue;
      }

      if (current is String) {
        final sanitized = _sanitizeUrl(current);
        if (sanitized != null) {
          stream ??= sanitized;
          download ??= sanitized;
          continue;
        }

        final trimmed = current.trim();
        if (trimmed.isEmpty) {
          continue;
        }

        final candidates = <String>{};
        if (trimmed.contains('/')) {
          candidates.add(trimmed);
        } else {
          candidates
            ..add('video/$trimmed')
            ..add('videos/$trimmed');
        }

        for (final path in candidates) {
          if (visitedDocPaths.contains(path)) {
            continue;
          }
          try {
            enqueue(FirebaseFirestore.instance.doc(path));
          } catch (error) {
            debugPrint('Invalid Firestore doc path $path: $error');
          }
        }
        continue;
      }

      if (current is DocumentReference) {
        final path = current.path;
        if (visitedDocPaths.contains(path)) {
          continue;
        }
        visitedDocPaths.add(path);
        try {
          final snapshot = await current.get();
          final snapshotData = snapshot.data();
          if (snapshotData is Map<String, dynamic>) {
            enqueue(snapshotData);
          }
        } catch (error) {
          debugPrint('Failed to load video document $path: $error');
        }
        continue;
      }

      if (current is Map<String, dynamic>) {
        if (visitedMaps.contains(current)) {
          continue;
        }
        visitedMaps.add(current);

        stream ??= _extractUrlFromMap(current, _streamKeys);
        download ??= _extractUrlFromMap(current, _downloadKeys);
        if (download == null && stream != null) {
          download = stream;
        }

        if (stream != null && download != null) {
          break;
        }

        for (final value in current.values) {
          enqueue(value);
        }
        continue;
      }

      if (current is Iterable) {
        for (final item in current) {
          enqueue(item);
        }
        continue;
      }
    }

    // If still not found, try to locate a matching document in the top-level `video`/`videos` collection.
    if ((stream == null || download == null)) {
      try {
        debugPrint(
            'MediaResolver: Attempting fallback video doc search for course ${course.id}');
        final videoMap = await _findVideoDocForCourse(course);
        if (videoMap != null) {
          debugPrint(
              'MediaResolver: Found video doc with keys: ${videoMap.keys.toList()}');
          stream ??= _extractUrlFromMap(videoMap, _streamKeys);
          download ??= _extractUrlFromMap(videoMap, _downloadKeys);
          if (download == null && stream != null) {
            download = stream;
          }
          debugPrint(
              'MediaResolver: After video doc extraction - stream: ${stream != null}, download: ${download != null}');
        } else {
          debugPrint(
              'MediaResolver: No video document found for course ${course.id}');
        }
      } catch (e) {
        debugPrint('Video search fallback failed: $e');
      }
    }

    if (download == null && stream != null) {
      download = stream;
    }

    // Best-effort: mirror the resolved download link back into the course doc so
    // mobile/other clients that expect a course-level download field can read it
    // directly. We throttle to one backfill per course id per app session.
    // Source of truth remains the `video` document; this is just a convenience mirror.
    if (download != null &&
        download.isNotEmpty &&
        !_backfilledCourseIds.contains(course.id)) {
      _backfilledCourseIds.add(course.id);
      // Fire and forget; ignore errors in case of security rules.
      final String nonNullDownload = download;
      Future.microtask(() => _backfillCourseDownloadField(
          courseId: course.id, download: nonNullDownload));
    }

    return _ResolvedCourseMedia(streamUrl: stream, downloadUrl: download);
  }

  // Attempts to find a related document inside `video` or `videos` collection for the given course.
  static Future<Map<String, dynamic>?> _findVideoDocForCourse(
      _LibraryCardData course) async {
    final f = FirebaseFirestore.instance;

    // First, try direct document ID match (common pattern where video doc ID == course doc ID)
    try {
      final videoDoc = await f.collection('video').doc(course.id).get();
      if (videoDoc.exists && videoDoc.data() != null) {
        debugPrint(
            'MediaResolver: Found video document by direct ID match: video/${course.id}');
        return Map<String, dynamic>.from(videoDoc.data()!);
      }
    } catch (e) {
      debugPrint('MediaResolver: Direct video doc lookup failed: $e');
    }

    try {
      final videosDoc = await f.collection('videos').doc(course.id).get();
      if (videosDoc.exists && videosDoc.data() != null) {
        debugPrint(
            'MediaResolver: Found video document by direct ID match: videos/${course.id}');
        return Map<String, dynamic>.from(videosDoc.data()!);
      }
    } catch (e) {
      debugPrint('MediaResolver: Direct videos doc lookup failed: $e');
    }

    final List<Future<QuerySnapshot<Map<String, dynamic>>>> queries = [];
    try {
      queries.add(f
          .collection('video')
          .where('courseId', isEqualTo: course.id)
          .limit(1)
          .get());
    } catch (_) {}
    try {
      queries.add(f
          .collection('videos')
          .where('courseId', isEqualTo: course.id)
          .limit(1)
          .get());
    } catch (_) {}
    // Common alternate id key variants
    for (final key in <String>[
      'courseID',
      'course',
      'course_id',
      'contentId',
      'content_id',
      'courseSlug'
    ]) {
      try {
        queries.add(f
            .collection('video')
            .where(key, isEqualTo: course.id)
            .limit(1)
            .get());
      } catch (_) {}
      try {
        queries.add(f
            .collection('videos')
            .where(key, isEqualTo: course.id)
            .limit(1)
            .get());
      } catch (_) {}
    }
    try {
      final courseRef = f.collection('courses').doc(course.id);
      queries.add(f
          .collection('video')
          .where('courseRef', isEqualTo: courseRef)
          .limit(1)
          .get());
    } catch (_) {}
    try {
      final courseRef = f.collection('courses').doc(course.id);
      queries.add(f
          .collection('videos')
          .where('courseRef', isEqualTo: courseRef)
          .limit(1)
          .get());
    } catch (_) {}
    // Some schemas use 'courseDocRef' or 'courseDocument'
    try {
      final courseRef = f.collection('courses').doc(course.id);
      queries.add(f
          .collection('video')
          .where('courseDocRef', isEqualTo: courseRef)
          .limit(1)
          .get());
    } catch (_) {}
    try {
      final courseRef = f.collection('courses').doc(course.id);
      queries.add(f
          .collection('videos')
          .where('courseDocRef', isEqualTo: courseRef)
          .limit(1)
          .get());
    } catch (_) {}
    // As a last resort, try matching by exact title
    try {
      if (course.title.isNotEmpty) {
        queries.add(f
            .collection('video')
            .where('title', isEqualTo: course.title)
            .limit(1)
            .get());
      }
    } catch (_) {}
    try {
      if (course.title.isNotEmpty) {
        queries.add(f
            .collection('videos')
            .where('title', isEqualTo: course.title)
            .limit(1)
            .get());
      }
    } catch (_) {}
    // Some schemas store the course title explicitly
    try {
      if (course.title.isNotEmpty) {
        queries.add(f
            .collection('video')
            .where('courseTitle', isEqualTo: course.title)
            .limit(1)
            .get());
      }
    } catch (_) {}
    try {
      if (course.title.isNotEmpty) {
        queries.add(f
            .collection('videos')
            .where('courseTitle', isEqualTo: course.title)
            .limit(1)
            .get());
      }
    } catch (_) {}

    for (final future in queries) {
      try {
        final snap = await future;
        if (snap.docs.isNotEmpty) {
          return Map<String, dynamic>.from(snap.docs.first.data());
        }
      } catch (e) {
        debugPrint('Video query failed: $e');
      }
    }

    return null;
  }

  static String? _extractUrlFromMap(
      Map<String, dynamic> map, List<String> keys) {
    final Set<Map<String, dynamic>> visited = <Map<String, dynamic>>{};

    String? search(Map<String, dynamic> target) {
      if (visited.contains(target)) {
        return null;
      }
      visited.add(target);

      for (final key in keys) {
        final candidate = _sanitizeUrl(target[key]);
        if (candidate != null) {
          return candidate;
        }
      }

      for (final entry in target.entries) {
        final value = entry.value;
        if (value is Map<String, dynamic>) {
          final nested = search(value);
          if (nested != null) {
            return nested;
          }
        } else if (value is Iterable) {
          for (final item in value) {
            if (item is Map<String, dynamic>) {
              final nested = search(item);
              if (nested != null) {
                return nested;
              }
            } else if (keys.contains(entry.key)) {
              final candidate = _sanitizeUrl(item);
              if (candidate != null) {
                return candidate;
              }
            }
          }
        } else if (keys.contains(entry.key)) {
          final candidate = _sanitizeUrl(value);
          if (candidate != null) {
            return candidate;
          }
        }
      }

      return null;
    }

    return search(map);
  }

  static bool _valueSuggestsMedia(dynamic value, {int depth = 0}) {
    if (value == null || depth > 4) {
      return false;
    }
    if (value is DocumentReference) {
      return true;
    }
    if (value is String) {
      final sanitized = _sanitizeUrl(value);
      if (sanitized != null) {
        return true;
      }
      final trimmed = value.trim();
      return trimmed.isNotEmpty;
    }
    if (value is Map<String, dynamic>) {
      for (final key in _downloadKeys.followedBy(_streamKeys)) {
        final candidate = _sanitizeUrl(value[key]);
        if (candidate != null) {
          return true;
        }
      }
      for (final entry in value.entries) {
        if (_valueSuggestsMedia(entry.value, depth: depth + 1)) {
          return true;
        }
      }
      return false;
    }
    if (value is Iterable) {
      for (final item in value) {
        if (_valueSuggestsMedia(item, depth: depth + 1)) {
          return true;
        }
      }
    }
    return false;
  }

  static String? _sanitizeUrl(dynamic raw) {
    final resolved = _FirestoreCourseGrid._readString(raw);
    if (resolved == null) {
      return null;
    }
    final trimmed = resolved.trim();
    if (trimmed.isEmpty) {
      return null;
    }
    if (trimmed.startsWith('http://') || trimmed.startsWith('https://')) {
      return trimmed;
    }
    if (trimmed.startsWith('www.')) {
      return 'https://$trimmed';
    }
    return null;
  }

  // Writes a mirrored download link into the courses/{id} document to keep the
  // "Download" value populated in Firestore from video.downloadLink.
  static Future<void> _backfillCourseDownloadField(
      {required String courseId, required String download}) async {
    try {
      final doc =
          FirebaseFirestore.instance.collection('courses').doc(courseId);
      // Use common keys so both web and mobile clients can locate the field.
      // Merge to avoid clobbering existing unrelated fields.
      await doc.set(<String, dynamic>{
        'downloadLink': download, // primary requested key
        'downloadUrl': download, // common alias
        'videoDownloadUrl': download, // mobile alias
        'mediaDownloadUrl': download, // another alias used in some screens
        'updatedAt': FieldValue.serverTimestamp(),
      }, SetOptions(merge: true));
    } catch (e) {
      debugPrint('Backfill downloadLink failed for course=$courseId: $e');
    }
  }
}

/// Repository responsible for resolving and writing course completion records.
class CompletionRepository {
  CompletionRepository._();

  static final Map<String, _CompletionDocLocation> _cache =
      <String, _CompletionDocLocation>{};

  static String _key(String userId, String courseId) => '$userId|$courseId';

  static Future<_CompletionDocLocation> resolveLocation({
    required String userId,
    required String courseId,
  }) async {
    final key = _key(userId, courseId);
    final cached = _cache[key];
    if (cached != null) return cached;

    final f = FirebaseFirestore.instance;
    final docUsersCourseCompletions = f
        .collection('users')
        .doc(userId)
        .collection('courseCompletions')
        .doc(courseId);
    final docUsersCompletions = f
        .collection('users')
        .doc(userId)
        .collection('completions')
        .doc(courseId);
    final qCourseCompletions = f
        .collection('courseCompletions')
        .where('userId', isEqualTo: userId)
        .where('courseId', isEqualTo: courseId)
        .limit(1);
    final qCompletions = f
        .collection('completions')
        .where('userId', isEqualTo: userId)
        .where('courseId', isEqualTo: courseId)
        .limit(1);

    try {
      final results = await Future.wait<dynamic>([
        docUsersCourseCompletions.get(),
        docUsersCompletions.get(),
        qCourseCompletions.get(),
        qCompletions.get(),
      ]);

      final doc1 = results[0] as DocumentSnapshot<Map<String, dynamic>>;
      if (doc1.exists) {
        final loc = _CompletionDocLocation(
            ref: doc1.reference,
            kind: _CompletionPathKind.userCourseCompletions);
        _cache[key] = loc;
        return loc;
      }
      final doc2 = results[1] as DocumentSnapshot<Map<String, dynamic>>;
      if (doc2.exists) {
        final loc = _CompletionDocLocation(
            ref: doc2.reference, kind: _CompletionPathKind.userCompletions);
        _cache[key] = loc;
        return loc;
      }
      final qs1 = results[2] as QuerySnapshot<Map<String, dynamic>>;
      if (qs1.docs.isNotEmpty) {
        final docRef = f.collection('courseCompletions').doc(qs1.docs.first.id);
        final loc = _CompletionDocLocation(
            ref: docRef, kind: _CompletionPathKind.courseCompletionsRoot);
        _cache[key] = loc;
        return loc;
      }
      final qs2 = results[3] as QuerySnapshot<Map<String, dynamic>>;
      if (qs2.docs.isNotEmpty) {
        final docRef = f.collection('completions').doc(qs2.docs.first.id);
        final loc = _CompletionDocLocation(
            ref: docRef, kind: _CompletionPathKind.completionsRoot);
        _cache[key] = loc;
        return loc;
      }
    } catch (e) {
      debugPrint('CompletionRepository.resolveLocation error: $e');
    }

    // Default location if none exists yet: users/{uid}/courseCompletions/{courseId}
    final fallback = _CompletionDocLocation(
        ref: docUsersCourseCompletions,
        kind: _CompletionPathKind.userCourseCompletions);
    _cache[key] = fallback;
    return fallback;
  }

  static Stream<DocumentSnapshot<Map<String, dynamic>>> completionStream({
    required String userId,
    required String courseId,
  }) async* {
    final loc = await resolveLocation(userId: userId, courseId: courseId);
    yield* loc.ref.snapshots();
  }

  static Future<void> markComplete({
    required String userId,
    required String courseId,
    String? title,
  }) async {
    final loc = await resolveLocation(userId: userId, courseId: courseId);
    final now = FieldValue.serverTimestamp();
    await loc.ref.set(<String, dynamic>{
      'userId': userId,
      'courseId': courseId,
      if (title != null) 'title': title,
      // Try to be compatible with various schemas
      'status': 'completed',
      'completed': true,
      'completion': 1.0,
      'completionLevel': 1.0,
      'completedAt': now,
      'updatedAt': now,
      'source': 'app',
    }, SetOptions(merge: true));
  }
}

enum _CompletionPathKind {
  userCourseCompletions,
  userCompletions,
  courseCompletionsRoot,
  completionsRoot,
}

class _CompletionDocLocation {
  _CompletionDocLocation({required this.ref, required this.kind});
  final DocumentReference<Map<String, dynamic>> ref;
  final _CompletionPathKind kind;
}

// Removed Mark Complete button per UX update

String _truncateToCharacters(String input, int maxChars) {
  final trimmed = input.trim();
  if (trimmed.length <= maxChars) {
    return trimmed;
  }
  final truncated = trimmed.substring(0, maxChars).trimRight();
  return '$truncated.....';
}

String _truncateToWords(String input, int maxWords) {
  final trimmed = input.trim();
  if (trimmed.isEmpty) {
    return trimmed;
  }
  final words =
      trimmed.split(RegExp(r'\s+')).where((word) => word.isNotEmpty).toList();
  if (words.length <= maxWords) {
    return trimmed;
  }
  final truncated = words.take(maxWords).join(' ');
  return '$truncated.....';
}

class AssessmentsPage extends StatefulWidget {
  const AssessmentsPage({super.key});

  static const Color _titleColor = Color(0xFF111827);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _cardBorder = Color(0xFFE5E7EB);
  static const Color _infoLink = Color(0xFF2563EB);
  static const Color _accentChip = Color(0xFFE8EDFF);
  static const Color _accentChipText = Color(0xFF1E3A8A);

  @override
  State<AssessmentsPage> createState() => _AssessmentsPageState();
}

class _AssessmentsPageState extends State<AssessmentsPage> {
  Map<String, dynamic> _assessmentData = {};
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadAssessmentData();
  }

  /// Helper to safely get string values from fields that might be List or String
  String _getStringValue(dynamic value) {
    if (value == null) return '';
    if (value is String) return value;
    if (value is List) {
      // If it's a list, join with commas or return first element
      if (value.isEmpty) return '';
      if (value.length == 1) return value.first.toString();
      return value.join(', ');
    }
    return value.toString();
  }

  /// Helper to check if a file field has a valid URL
  bool _hasFileUrl(String field) {
    final value = _assessmentData[field];
    if (value == null) return false;
    if (value is String) return value.isNotEmpty;
    if (value is List && value.isNotEmpty) {
      final firstItem = value.first;
      return firstItem is String && firstItem.isNotEmpty;
    }
    return false;
  }

  /// Helper to get file URL from a field that might be String or List
  String? _getFileUrl(String field) {
    final value = _assessmentData[field];
    if (value == null) return null;
    if (value is String) return value.isNotEmpty ? value : null;
    if (value is List && value.isNotEmpty) {
      final firstItem = value.first;
      return firstItem is String && firstItem.isNotEmpty ? firstItem : null;
    }
    return null;
  }

  Future<void> _loadAssessmentData() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) {
      setState(() => _isLoading = false);
      return;
    }

    try {
      // Query assessmentResults collection where memberId references the user document
      final userRef = FirebaseFirestore.instance.collection('users').doc(uid);
      final snapshot = await FirebaseFirestore.instance
          .collection('assessmentResults')
          .where('memberId', isEqualTo: userRef)
          .limit(1)
          .get();

      if (snapshot.docs.isNotEmpty) {
        if (mounted) {
          setState(() {
            _assessmentData = snapshot.docs.first.data();
            _isLoading = false;
          });
        }
      } else {
        // Fallback: try old structure with userId string
        final fallbackSnapshot = await FirebaseFirestore.instance
            .collection('assessmentResults')
            .where('userId', isEqualTo: uid)
            .limit(1)
            .get();

        if (fallbackSnapshot.docs.isNotEmpty) {
          if (mounted) {
            setState(() {
              _assessmentData = fallbackSnapshot.docs.first.data();
              _isLoading = false;
            });
          }
        } else {
          if (mounted) setState(() => _isLoading = false);
        }
      }
    } catch (e) {
      debugPrint('Error loading assessment data: $e');
      if (mounted) setState(() => _isLoading = false);
    }
  }

  Future<void> _downloadResults(String fileField) async {
    // Map assessment type to correct file URL field
    final fieldMap = {
      'Kolbe Index': 'Kolbe',
      'Guiding Genius Report': 'GuidingGenius',
      'Guiding Truths': 'GuidingTruths',
      'Working Genius': 'WorkingGenius',
      'Print Assessment': 'Print',
      'VIA Character Assessment': 'VIA',
    };

    final field = fieldMap[fileField] ?? fileField;
    final url = _getFileUrl(field);

    // If external URL exists, open it
    if (url != null && url.isNotEmpty) {
      try {
        final uri = Uri.parse(url);
        await launchUrl(uri, mode: LaunchMode.externalApplication);
        return;
      } catch (e) {
        debugPrint('Error opening external URL: $e');
        // Fall through to PDF generation
      }
    }

    // Generate PDF from local data
    await _generateAssessmentPdf(fileField);
  }

  Future<void> _generateAssessmentPdf(String assessmentType) async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please sign in to download results')),
      );
      return;
    }

    try {
      final pdf = pw.Document();

      pdf.addPage(
        pw.Page(
          pageFormat: PdfPageFormat.a4,
          margin: const pw.EdgeInsets.all(40),
          build: (pw.Context context) {
            return pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                // Header
                pw.Container(
                  width: double.infinity,
                  padding: const pw.EdgeInsets.all(24),
                  decoration: pw.BoxDecoration(
                    color: PdfColor.fromHex('#2F55EE'),
                    borderRadius: pw.BorderRadius.circular(16),
                  ),
                  child: pw.Column(
                    crossAxisAlignment: pw.CrossAxisAlignment.start,
                    children: [
                      pw.Text(
                        assessmentType.toUpperCase(),
                        style: pw.TextStyle(
                          color: PdfColors.white,
                          fontSize: 24,
                          fontWeight: pw.FontWeight.bold,
                        ),
                      ),
                      pw.SizedBox(height: 8),
                      pw.Text(
                        'Assessment Results',
                        style: const pw.TextStyle(
                          color: PdfColors.white,
                          fontSize: 14,
                        ),
                      ),
                      pw.SizedBox(height: 12),
                      pw.Text(
                        'Generated for: ${user.email ?? "Unknown"}',
                        style: const pw.TextStyle(
                          color: PdfColors.white,
                          fontSize: 12,
                        ),
                      ),
                    ],
                  ),
                ),
                pw.SizedBox(height: 24),

                // Assessment-specific content
                ..._buildAssessmentPdfContent(assessmentType),

                pw.Spacer(),

                // Footer
                pw.Divider(color: PdfColor.fromHex('#E2E8F0')),
                pw.SizedBox(height: 8),
                pw.Text(
                  'Generated on ${DateTime.now().toString().split('.')[0]}',
                  style: pw.TextStyle(
                    fontSize: 10,
                    color: PdfColor.fromHex('#6B7280'),
                  ),
                ),
              ],
            );
          },
        ),
      );

      final bytes = await pdf.save();
      final fileName =
          '${assessmentType.replaceAll(' ', '_')}_Results_${DateTime.now().millisecondsSinceEpoch}.pdf';

      if (kIsWeb) {
        final blob = html.Blob([bytes], 'application/pdf');
        final blobUrl = html.Url.createObjectUrlFromBlob(blob);
        final anchor = html.AnchorElement(href: blobUrl)
          ..setAttribute('download', fileName)
          ..click();
        html.Url.revokeObjectUrl(blobUrl);
      } else {
        await Printing.sharePdf(bytes: bytes, filename: fileName);
      }

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('‚úì PDF downloaded successfully!'),
          backgroundColor: Color(0xFF22C55E),
        ),
      );
    } catch (e) {
      debugPrint('Error generating assessment PDF: $e');
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error generating PDF: ${e.toString()}'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  List<pw.Widget> _buildAssessmentPdfContent(String assessmentType) {
    switch (assessmentType) {
      case 'Kolbe Index':
        return _buildKolbePdfContent();
      case 'Working Genius':
        return _buildWorkingGeniusPdfContent();
      case 'Guiding Truths':
        return _buildGuidingTruthsPdfContent();
      case 'Guiding Genius Report':
        return _buildGuidingGeniusPdfContent();
      case 'Print Assessment':
        return _buildPrintPdfContent();
      case 'VIA Character Assessment':
        return _buildViaPdfContent();
      default:
        return [pw.Text('No data available for this assessment.')];
    }
  }

  List<pw.Widget> _buildKolbePdfContent() {
    final factFinder = _assessmentData['K_fact'] ?? 0;
    final followThrough = _assessmentData['K_follow'] ?? 0;
    final quickStart = _assessmentData['K_quick'] ?? 0;
    final implementor = _assessmentData['K_implementor'] ?? 0;
    final strengths = _getStringValue(_assessmentData['K_strengths']);

    return [
      _pdfSectionTitle('Kolbe A Index Scores'),
      pw.SizedBox(height: 16),
      pw.Row(
        children: [
          _pdfMetricBox('Fact Finder', factFinder.toString()),
          pw.SizedBox(width: 12),
          _pdfMetricBox('Follow Through', followThrough.toString()),
          pw.SizedBox(width: 12),
          _pdfMetricBox('Quick Start', quickStart.toString()),
          pw.SizedBox(width: 12),
          _pdfMetricBox('Implementor', implementor.toString()),
        ],
      ),
      if (strengths.isNotEmpty) ...[
        pw.SizedBox(height: 24),
        _pdfSectionTitle('Key Strengths'),
        pw.SizedBox(height: 8),
        _pdfTextContent(strengths),
      ],
    ];
  }

  List<pw.Widget> _buildWorkingGeniusPdfContent() {
    final geniusZone = _getStringValue(_assessmentData['WG_zone']);
    final strengths = _getStringValue(_assessmentData['WG_strengths']);

    return [
      _pdfSectionTitle('Working Genius Profile'),
      pw.SizedBox(height: 16),
      if (geniusZone.isNotEmpty) ...[
        _pdfLabeledField('Your Genius Zone', geniusZone),
        pw.SizedBox(height: 16),
      ],
      if (strengths.isNotEmpty) ...[
        _pdfLabeledField('Strengths', strengths),
      ],
      if (geniusZone.isEmpty && strengths.isEmpty)
        pw.Text('No Working Genius data available.',
            style: const pw.TextStyle(color: PdfColors.grey)),
    ];
  }

  List<pw.Widget> _buildGuidingTruthsPdfContent() {
    final truths = _getStringValue(_assessmentData['GT_truths']);

    return [
      _pdfSectionTitle('Guiding Truths'),
      pw.SizedBox(height: 16),
      if (truths.isNotEmpty)
        _pdfTextContent(truths)
      else
        pw.Text('No Guiding Truths data available.',
            style: const pw.TextStyle(color: PdfColors.grey)),
    ];
  }

  List<pw.Widget> _buildGuidingGeniusPdfContent() {
    final strengths = _getStringValue(_assessmentData['GG_strengths']);
    final energizing = _getStringValue(_assessmentData['GG_enegizing']);

    return [
      _pdfSectionTitle('Guiding Genius Report'),
      pw.SizedBox(height: 16),
      if (strengths.isNotEmpty) ...[
        _pdfLabeledField('Strengths', strengths),
        pw.SizedBox(height: 12),
      ],
      if (energizing.isNotEmpty) ...[
        _pdfLabeledField('Energizing', energizing),
      ],
      if (strengths.isEmpty && energizing.isEmpty)
        pw.Text('No Guiding Genius data available.',
            style: const pw.TextStyle(color: PdfColors.grey)),
    ];
  }

  List<pw.Widget> _buildPrintPdfContent() {
    final primaryDrive = _getStringValue(_assessmentData['PA_drive']);
    final secondaryDrive = _getStringValue(_assessmentData['PA_sdrive']);

    return [
      _pdfSectionTitle('PRINT Assessment Results'),
      pw.SizedBox(height: 16),
      if (primaryDrive.isNotEmpty) ...[
        _pdfLabeledField('Primary Drive', primaryDrive),
        pw.SizedBox(height: 12),
      ],
      if (secondaryDrive.isNotEmpty) ...[
        _pdfLabeledField('Secondary Drive', secondaryDrive),
      ],
      if (primaryDrive.isEmpty && secondaryDrive.isEmpty)
        pw.Text('No PRINT Assessment data available.',
            style: const pw.TextStyle(color: PdfColors.grey)),
    ];
  }

  List<pw.Widget> _buildViaPdfContent() {
    final topStrengths = _getStringValue(_assessmentData['topStrengths']);

    return [
      _pdfSectionTitle('VIA Character Strengths'),
      pw.SizedBox(height: 16),
      if (topStrengths.isNotEmpty)
        _pdfLabeledField('Top Strengths', topStrengths)
      else
        pw.Text('No VIA Assessment data available.',
            style: const pw.TextStyle(color: PdfColors.grey)),
    ];
  }

  pw.Widget _pdfSectionTitle(String title) {
    return pw.Text(
      title,
      style: pw.TextStyle(
        fontSize: 18,
        fontWeight: pw.FontWeight.bold,
        color: PdfColor.fromHex('#0F172A'),
      ),
    );
  }

  pw.Widget _pdfMetricBox(String label, String value) {
    return pw.Expanded(
      child: pw.Container(
        padding: const pw.EdgeInsets.all(16),
        decoration: pw.BoxDecoration(
          color: PdfColor.fromHex('#F68D2E'),
          borderRadius: pw.BorderRadius.circular(12),
        ),
        child: pw.Column(
          children: [
            pw.Text(
              value,
              style: pw.TextStyle(
                fontSize: 28,
                fontWeight: pw.FontWeight.bold,
                color: PdfColors.white,
              ),
            ),
            pw.SizedBox(height: 4),
            pw.Text(
              label,
              textAlign: pw.TextAlign.center,
              style: const pw.TextStyle(
                fontSize: 10,
                color: PdfColors.white,
              ),
            ),
          ],
        ),
      ),
    );
  }

  pw.Widget _pdfLabeledField(String label, String value) {
    return pw.Container(
      width: double.infinity,
      padding: const pw.EdgeInsets.all(16),
      decoration: pw.BoxDecoration(
        border: pw.Border.all(color: PdfColor.fromHex('#E2E8F0')),
        borderRadius: pw.BorderRadius.circular(8),
      ),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Text(
            label,
            style: pw.TextStyle(
              fontSize: 12,
              fontWeight: pw.FontWeight.bold,
              color: PdfColor.fromHex('#6B7280'),
            ),
          ),
          pw.SizedBox(height: 8),
          pw.Text(
            value,
            style: pw.TextStyle(
              fontSize: 14,
              color: PdfColor.fromHex('#0F172A'),
            ),
          ),
        ],
      ),
    );
  }

  pw.Widget _pdfTextContent(String text) {
    return pw.Container(
      width: double.infinity,
      padding: const pw.EdgeInsets.all(16),
      decoration: pw.BoxDecoration(
        color: PdfColor.fromHex('#F9FAFB'),
        borderRadius: pw.BorderRadius.circular(8),
      ),
      child: pw.Text(
        text,
        style: pw.TextStyle(
          fontSize: 12,
          color: PdfColor.fromHex('#374151'),
          lineSpacing: 4,
        ),
      ),
    );
  }

  TextStyle get _headingStyle => const TextStyle(
        fontSize: 24,
        fontWeight: FontWeight.w700,
        color: AssessmentsPage._titleColor,
      );

  Widget _downloadLink(String assessmentType) {
    // Always enable download - will generate PDF from data if no external URL
    return GestureDetector(
      onTap: () => _downloadResults(assessmentType),
      child: const Text(
        'Download Results',
        style: TextStyle(
          color: AssessmentsPage._infoLink,
          fontSize: 14,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }

  Widget _card({required Widget child, EdgeInsets? padding}) {
    return Container(
      padding: padding ?? const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: AssessmentsPage._cardBorder),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.03),
            blurRadius: 12,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: child,
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        final horizontalPadding = constraints.maxWidth > 1180 ? 56.0 : 32.0;
        final isStacked = constraints.maxWidth < 1100;

        // Get Kolbe data from new field names (K_fact, K_follow, K_quick, K_implementor, K_strengths)
        final kolbeMetrics = [
          _KolbeTile(
              title: 'Fact Finder', value: _assessmentData['K_fact'] ?? 0),
          _KolbeTile(
              title: 'Follow Through', value: _assessmentData['K_follow'] ?? 0),
          _KolbeTile(
              title: 'Quick Start', value: _assessmentData['K_quick'] ?? 0),
          _KolbeTile(
              title: 'Implementor',
              value: _assessmentData['K_implementor'] ?? 0),
        ];
        final kolbeStrengths = _getStringValue(_assessmentData['K_strengths']);

        Widget buildKolbeCard() {
          return _card(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    const Text(
                      'Kolbe',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.w700,
                        color: AssessmentsPage._titleColor,
                      ),
                    ),
                    _downloadLink('Kolbe Index'),
                  ],
                ),
                const SizedBox(height: 20),
                Row(
                  children: [
                    for (var i = 0; i < kolbeMetrics.length; i++) ...[
                      Expanded(child: kolbeMetrics[i]),
                      if (i != kolbeMetrics.length - 1)
                        const SizedBox(width: 16),
                    ],
                  ],
                ),
              ],
            ),
          );
        }

        // Get Working Genius data from new field names (WG_zone, WG_strengths)
        final geniusZone = _getStringValue(_assessmentData['WG_zone']);
        final wgStrengths = _getStringValue(_assessmentData['WG_strengths']);

        Widget buildWorkingGeniusCard() {
          return _card(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    const Text(
                      'Working Genius',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.w700,
                        color: AssessmentsPage._titleColor,
                      ),
                    ),
                    _downloadLink('Working Genius'),
                  ],
                ),
                const SizedBox(height: 20),
                const Text(
                  'Your Genius Zone',
                  style: TextStyle(
                    color: AssessmentsPage._mutedColor,
                    fontSize: 14,
                  ),
                ),
                const SizedBox(height: 8),
                if (geniusZone.isNotEmpty)
                  Container(
                    padding:
                        const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                    decoration: BoxDecoration(
                      color: AssessmentsPage._accentChip,
                      borderRadius: BorderRadius.circular(24),
                    ),
                    child: Text(
                      geniusZone,
                      style: const TextStyle(
                        color: AssessmentsPage._accentChipText,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                const SizedBox(height: 16),
                const Text(
                  'Strengths',
                  style: TextStyle(
                    color: AssessmentsPage._mutedColor,
                    fontSize: 13,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  decoration: BoxDecoration(
                    color: AssessmentsPage._accentChip,
                    borderRadius: BorderRadius.circular(24),
                  ),
                  child: Text(
                    wgStrengths.isEmpty ? 'Empty' : wgStrengths,
                    style: const TextStyle(
                      color: AssessmentsPage._accentChipText,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ],
            ),
          );
        }

        // Get Guiding Truths data from new field name (GT_truths)
        final gtContent = _getStringValue(_assessmentData['GT_truths']);

        Widget buildGuidingTruthsCard() {
          return _card(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    const Text(
                      'Guiding Truths',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.w700,
                        color: AssessmentsPage._titleColor,
                      ),
                    ),
                    _downloadLink('Guiding Truths'),
                  ],
                ),
                if (gtContent.isNotEmpty) ...[
                  const SizedBox(height: 16),
                  Text(
                    gtContent,
                    style: const TextStyle(
                      color: AssessmentsPage._mutedColor,
                      fontSize: 14,
                      height: 1.5,
                    ),
                  ),
                ],
              ],
            ),
          );
        }

        // Get Guiding Genius Time data from new field names (GG_strengths, GG_enegizing)
        final ggStrengths = _getStringValue(_assessmentData['GG_strengths']);
        final ggEnergizing = _getStringValue(_assessmentData['GG_enegizing']);

        Widget buildGuidingGeniusCard() {
          return _card(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _CardHeader(
                    title: 'Guiding Genius Report',
                    onDownload: () =>
                        _downloadResults('Guiding Genius Report')),
                const SizedBox(height: 20),
                const Text(
                  'Strengths',
                  style: TextStyle(
                    color: AssessmentsPage._mutedColor,
                    fontSize: 14,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  ggStrengths.isEmpty ? 'not yet assessed' : ggStrengths,
                  style: TextStyle(
                      color: AssessmentsPage._titleColor, fontSize: 13),
                ),
                const SizedBox(height: 16),
                const Text(
                  'Energizing',
                  style: TextStyle(
                    color: AssessmentsPage._mutedColor,
                    fontSize: 14,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  ggEnergizing.isEmpty ? 'not yet assessed' : ggEnergizing,
                  style: TextStyle(
                      color: AssessmentsPage._titleColor, fontSize: 13),
                ),
              ],
            ),
          );
        }

        // Get Print Assessment data from new field names (PA_drive, PA_sdrive)
        final primaryDrive = _getStringValue(_assessmentData['PA_drive']);
        final secondaryDrive = _getStringValue(_assessmentData['PA_sdrive']);

        Widget buildPrintCard() {
          return _card(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _CardHeader(
                    title: 'PRINT Assessment',
                    onDownload: () => _downloadResults('Print Assessment')),
                const SizedBox(height: 20),
                _AssessmentField(
                    label: 'Primary Drive',
                    value: primaryDrive.isEmpty ? 'none' : primaryDrive),
                const SizedBox(height: 16),
                _AssessmentField(
                    label: 'Secondary Drive',
                    value: secondaryDrive.isEmpty ? 'none' : secondaryDrive),
              ],
            ),
          );
        }

        // Get VIA data
        final topStrengths = _getStringValue(_assessmentData['topStrengths']);

        Widget buildViaCard() {
          return _card(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _CardHeader(
                    title: 'VIA Character Assessment',
                    onDownload: () =>
                        _downloadResults('VIA Character Assessment')),
                if (topStrengths.isNotEmpty) ...[
                  const SizedBox(height: 16),
                  const Text(
                    'Top Strengths',
                    style: TextStyle(
                      color: AssessmentsPage._mutedColor,
                      fontSize: 14,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    topStrengths,
                    style: const TextStyle(
                        color: AssessmentsPage._titleColor, fontSize: 13),
                  ),
                ],
              ],
            ),
          );
        }

        Widget leftColumn = Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            buildKolbeCard(),
            const SizedBox(height: 24),
            buildWorkingGeniusCard(),
            const SizedBox(height: 24),
            buildGuidingTruthsCard(),
          ],
        );

        Widget rightColumn = Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            buildGuidingGeniusCard(),
            const SizedBox(height: 24),
            buildPrintCard(),
            const SizedBox(height: 24),
            buildViaCard(),
          ],
        );

        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('Framework Assessments', style: _headingStyle),
              const SizedBox(height: 24),
              if (isStacked)
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    leftColumn,
                    const SizedBox(height: 24),
                    rightColumn,
                  ],
                )
              else
                Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Expanded(flex: 3, child: leftColumn),
                    const SizedBox(width: 24),
                    Expanded(flex: 2, child: rightColumn),
                  ],
                ),
              const SizedBox(height: 40),
              Container(height: 1, color: AssessmentsPage._cardBorder),
              const SizedBox(height: 28),
              const Text(
                'Ready to dive deeper?',
                style: TextStyle(
                  color: AssessmentsPage._titleColor,
                  fontSize: 18,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 12),
              const Text(
                'Your assesment results provide powerful insights into your unique strengths and motivations. Use the "Download Results" above to explore comprehensive reports for each assesment.',
                style: TextStyle(
                    color: AssessmentsPage._mutedColor,
                    fontSize: 15,
                    height: 1.4),
              ),
            ],
          ),
        );
      },
    );
  }
}

class _KolbeTile extends StatelessWidget {
  const _KolbeTile({required this.title, this.value = 0});

  final String title;
  final int value;

  @override
  Widget build(BuildContext context) {
    return AspectRatio(
      aspectRatio: 0.85,
      child: Container(
        decoration: BoxDecoration(
          gradient: const LinearGradient(
            colors: [Color(0xFFF68D2E), Color(0xFFF6C34C)],
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
          ),
          borderRadius: BorderRadius.circular(18),
        ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              '$value',
              style: const TextStyle(
                color: Colors.white,
                fontSize: 32,
                fontWeight: FontWeight.w700,
              ),
            ),
            const SizedBox(height: 10),
            Text(
              title,
              textAlign: TextAlign.center,
              style: const TextStyle(
                color: Colors.white,
                fontSize: 14,
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 6),
            const Text(
              'Your Strengths',
              style: TextStyle(
                color: Colors.white70,
                fontSize: 12,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _CardHeader extends StatelessWidget {
  const _CardHeader({required this.title, required this.onDownload});

  final String title;
  final VoidCallback onDownload;

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.w700,
            color: AssessmentsPage._titleColor,
          ),
        ),
        GestureDetector(
          onTap: onDownload,
          child: const Text(
            'Download Results',
            style: TextStyle(
              color: AssessmentsPage._infoLink,
              fontSize: 14,
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
      ],
    );
  }
}

class _AssessmentField extends StatelessWidget {
  const _AssessmentField({required this.label, required this.value});

  final String label;
  final String value;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: const TextStyle(
            color: AssessmentsPage._mutedColor,
            fontSize: 13,
            fontWeight: FontWeight.w600,
          ),
        ),
        const SizedBox(height: 10),
        Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
          decoration: BoxDecoration(
            color: const Color(0xFFE3E7FF),
            borderRadius: BorderRadius.circular(12),
          ),
          child: Text(
            value,
            style: const TextStyle(
              color: AssessmentsPage._titleColor,
              fontSize: 14,
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
      ],
    );
  }
}

class _ProfileTabBar extends StatelessWidget {
  const _ProfileTabBar({
    required this.selectedTab,
    required this.onTabSelected,
  });

  final ProfileTab selectedTab;
  final ValueChanged<ProfileTab> onTabSelected;

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        _ProfileTab(
          label: 'General Info',
          isActive: selectedTab == ProfileTab.generalInfo,
          onTap: () => onTabSelected(ProfileTab.generalInfo),
        ),
        const SizedBox(width: 12),
        _ProfileTab(
          label: 'Notifications',
          isActive: selectedTab == ProfileTab.notifications,
          onTap: () => onTabSelected(ProfileTab.notifications),
        ),
      ],
    );
  }
}

class _ProfileTab extends StatelessWidget {
  const _ProfileTab({required this.label, this.isActive = false, this.onTap});

  final String label;
  final bool isActive;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final Color background = isActive ? Colors.white : const Color(0xFFF3F4F6);
    final Color borderColor =
        isActive ? const Color(0xFFE5E7EB) : Colors.transparent;
    final TextStyle textStyle = TextStyle(
      color: isActive ? const Color(0xFF111827) : const Color(0xFF6B7280),
      fontWeight: FontWeight.w600,
      fontSize: 14,
    );

    final container = Container(
      padding: const EdgeInsets.symmetric(horizontal: 26, vertical: 16),
      decoration: BoxDecoration(
        color: background,
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: borderColor),
        boxShadow: isActive
            ? [
                BoxShadow(
                  color: Colors.black.withOpacity(0.05),
                  blurRadius: 14,
                  offset: const Offset(0, 4),
                ),
              ]
            : null,
      ),
      child: Text(label, style: textStyle),
    );

    if (onTap == null) return container;
    return GestureDetector(
      onTap: onTap,
      child: MouseRegion(
        cursor: SystemMouseCursors.click,
        child: container,
      ),
    );
  }
}

class _ProfileNotificationsContent extends StatelessWidget {
  const _ProfileNotificationsContent({required this.userId});

  final String? userId;

  static const Color _titleColor = Color(0xFF111827);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE5E7EB);
  static const Color _accentTeal = Color(0xFF1AA8B0);

  IconData _getNotificationIcon(String type) {
    switch (type) {
      case 'message':
      case 'direct_message':
        return Icons.mail_outline_rounded;
      case 'coach_request':
      case 'coach_request_accepted':
        return Icons.person_add_outlined;
      case 'session_scheduled':
        return Icons.calendar_today_outlined;
      case 'module_completed':
        return Icons.check_circle_outline_rounded;
      case 'achievement':
        return Icons.emoji_events_outlined;
      case 'new_content':
        return Icons.article_outlined;
      case 'scorecard_submitted':
        return Icons.assessment_outlined;
      case 'profile_updated':
        return Icons.person_outline_rounded;
      case 'welcome':
        return Icons.celebration_outlined;
      default:
        return Icons.notifications_outlined;
    }
  }

  Color _getNotificationColor(String type) {
    switch (type) {
      case 'message':
      case 'direct_message':
        return const Color(0xFF3B82F6);
      case 'coach_request':
      case 'coach_request_accepted':
        return const Color(0xFF8B5CF6);
      case 'session_scheduled':
        return const Color(0xFFF59E0B);
      case 'module_completed':
      case 'achievement':
        return const Color(0xFF10B981);
      case 'new_content':
        return const Color(0xFFEC4899);
      case 'scorecard_submitted':
        return const Color(0xFF6366F1);
      case 'welcome':
        return _accentTeal;
      default:
        return _mutedColor;
    }
  }

  String _formatTimeAgo(DateTime dateTime) {
    final now = DateTime.now();
    final diff = now.difference(dateTime);
    if (diff.inMinutes < 1) return 'Just now';
    if (diff.inMinutes < 60) return '${diff.inMinutes}m ago';
    if (diff.inHours < 24) return '${diff.inHours}h ago';
    if (diff.inDays < 7) return '${diff.inDays}d ago';
    return '${dateTime.day}/${dateTime.month}/${dateTime.year}';
  }

  Future<void> _markAsRead(String notificationId) async {
    try {
      await FirebaseFirestore.instance
          .collection('notifications')
          .doc(notificationId)
          .update({'read': true});
    } catch (e) {
      debugPrint('Error marking notification as read: $e');
    }
  }

  Future<void> _markAllAsRead() async {
    if (userId == null) return;
    try {
      final batch = FirebaseFirestore.instance.batch();
      final unreadNotifications = await FirebaseFirestore.instance
          .collection('notifications')
          .where('recipientId', isEqualTo: userId)
          .where('read', isEqualTo: false)
          .get();
      for (final doc in unreadNotifications.docs) {
        batch.update(doc.reference, {'read': true});
      }
      await batch.commit();
    } catch (e) {
      debugPrint('Error marking all notifications as read: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    if (userId == null) {
      return const Center(
        child: Padding(
          padding: EdgeInsets.all(32),
          child: Text('Please sign in to view notifications',
              style: TextStyle(color: _mutedColor)),
        ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            const Text(
              'Your Notifications',
              style: TextStyle(
                  color: _titleColor,
                  fontSize: 18,
                  fontWeight: FontWeight.w700),
            ),
            TextButton.icon(
              onPressed: _markAllAsRead,
              icon: const Icon(Icons.done_all_rounded, size: 18),
              label: const Text('Mark all as read'),
              style: TextButton.styleFrom(
                foregroundColor: _accentTeal,
                textStyle:
                    const TextStyle(fontWeight: FontWeight.w600, fontSize: 13),
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        StreamBuilder<QuerySnapshot>(
          stream: FirebaseFirestore.instance
              .collection('notifications')
              .where('recipientId', isEqualTo: userId)
              .orderBy('createdAt', descending: true)
              .limit(50)
              .snapshots(),
          builder: (context, notificationsSnapshot) {
            return StreamBuilder<QuerySnapshot>(
              stream: FirebaseFirestore.instance
                  .collection('chats')
                  .where('participants', arrayContains: userId)
                  .orderBy('lastMessageTime', descending: true)
                  .limit(20)
                  .snapshots(),
              builder: (context, messagesSnapshot) {
                if (notificationsSnapshot.connectionState ==
                        ConnectionState.waiting &&
                    messagesSnapshot.connectionState ==
                        ConnectionState.waiting) {
                  return const Center(
                      child: Padding(
                    padding: EdgeInsets.all(48),
                    child: CircularProgressIndicator(
                        valueColor: AlwaysStoppedAnimation<Color>(_accentTeal)),
                  ));
                }

                final List<Map<String, dynamic>> allItems = [];

                // Add notifications
                if (notificationsSnapshot.hasData) {
                  for (final doc in notificationsSnapshot.data!.docs) {
                    final data = doc.data() as Map<String, dynamic>;
                    DateTime? createdAt;
                    final createdAtField = data['createdAt'];
                    if (createdAtField is Timestamp) {
                      createdAt = createdAtField.toDate();
                    }
                    allItems.add({
                      'id': doc.id,
                      'type': data['type'] ?? 'notification',
                      'title': data['title'] ?? 'Notification',
                      'message': data['message'] ?? '',
                      'read': data['read'] ?? false,
                      'createdAt': createdAt ?? DateTime.now(),
                      'isMessage': false,
                      'actorName': data['actorName'],
                      'actorImageUrl': data['actorImageUrl'],
                    });
                  }
                }

                // Add recent messages as notifications
                if (messagesSnapshot.hasData) {
                  for (final doc in messagesSnapshot.data!.docs) {
                    final data = doc.data() as Map<String, dynamic>;
                    DateTime? lastMessageTime;
                    final lastMsgField = data['lastMessageTime'];
                    if (lastMsgField is Timestamp) {
                      lastMessageTime = lastMsgField.toDate();
                    }
                    final lastMessage = data['lastMessage'] as String? ?? '';
                    final lastSenderId = data['lastSenderId'] as String?;
                    // Only show messages from others
                    if (lastSenderId != null &&
                        lastSenderId != userId &&
                        lastMessage.isNotEmpty) {
                      allItems.add({
                        'id': 'msg_${doc.id}',
                        'type': 'message',
                        'title': 'New Message',
                        'message': lastMessage,
                        'read': false,
                        'createdAt': lastMessageTime ?? DateTime.now(),
                        'isMessage': true,
                        'chatId': doc.id,
                        'actorName': data['lastSenderName'],
                      });
                    }
                  }
                }

                // Sort all items by date
                allItems.sort((a, b) => (b['createdAt'] as DateTime)
                    .compareTo(a['createdAt'] as DateTime));

                if (allItems.isEmpty) {
                  return Container(
                    width: double.infinity,
                    padding: const EdgeInsets.symmetric(
                        vertical: 64, horizontal: 24),
                    decoration: BoxDecoration(
                      color: const Color(0xFFF9FAFB),
                      borderRadius: BorderRadius.circular(16),
                      border: Border.all(color: _borderColor),
                    ),
                    child: Column(
                      children: [
                        Icon(Icons.notifications_none_rounded,
                            size: 56,
                            color: _mutedColor.withValues(alpha: 0.5)),
                        const SizedBox(height: 16),
                        const Text('No notifications yet',
                            style: TextStyle(
                                color: _titleColor,
                                fontSize: 16,
                                fontWeight: FontWeight.w600)),
                        const SizedBox(height: 6),
                        const Text(
                            'You\'ll see your notifications and messages here',
                            style: TextStyle(color: _mutedColor, fontSize: 14)),
                      ],
                    ),
                  );
                }

                return Container(
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(16),
                    border: Border.all(color: _borderColor),
                    boxShadow: [
                      BoxShadow(
                          color: Colors.black.withValues(alpha: 0.03),
                          blurRadius: 12,
                          offset: const Offset(0, 4))
                    ],
                  ),
                  child: ListView.separated(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemCount: allItems.length,
                    separatorBuilder: (_, __) =>
                        const Divider(height: 1, color: _borderColor),
                    itemBuilder: (context, index) {
                      final item = allItems[index];
                      final type = item['type'] as String;
                      final isRead = item['read'] as bool;
                      final createdAt = item['createdAt'] as DateTime;

                      return Material(
                        color: isRead ? Colors.white : const Color(0xFFF0FDFA),
                        child: InkWell(
                          onTap: () {
                            if (!isRead && !item['isMessage']) {
                              _markAsRead(item['id'] as String);
                            }
                          },
                          child: Padding(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 20, vertical: 16),
                            child: Row(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Container(
                                  width: 44,
                                  height: 44,
                                  decoration: BoxDecoration(
                                    color: _getNotificationColor(type)
                                        .withValues(alpha: 0.12),
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  child: Icon(_getNotificationIcon(type),
                                      color: _getNotificationColor(type),
                                      size: 22),
                                ),
                                const SizedBox(width: 16),
                                Expanded(
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      Row(
                                        children: [
                                          Expanded(
                                            child: Text(
                                              item['title'] as String,
                                              style: TextStyle(
                                                color: _titleColor,
                                                fontSize: 15,
                                                fontWeight: isRead
                                                    ? FontWeight.w500
                                                    : FontWeight.w700,
                                              ),
                                            ),
                                          ),
                                          if (!isRead)
                                            Container(
                                              width: 8,
                                              height: 8,
                                              margin: const EdgeInsets.only(
                                                  left: 8),
                                              decoration: const BoxDecoration(
                                                  color: _accentTeal,
                                                  shape: BoxShape.circle),
                                            ),
                                        ],
                                      ),
                                      const SizedBox(height: 4),
                                      Text(
                                        item['message'] as String,
                                        style: const TextStyle(
                                            color: _mutedColor,
                                            fontSize: 13,
                                            height: 1.4),
                                        maxLines: 2,
                                        overflow: TextOverflow.ellipsis,
                                      ),
                                      const SizedBox(height: 6),
                                      Row(
                                        children: [
                                          if (item['actorName'] != null) ...[
                                            Icon(Icons.person_outline_rounded,
                                                size: 14,
                                                color: _mutedColor.withValues(
                                                    alpha: 0.7)),
                                            const SizedBox(width: 4),
                                            Text(
                                              item['actorName'] as String,
                                              style: TextStyle(
                                                  color: _mutedColor.withValues(
                                                      alpha: 0.8),
                                                  fontSize: 12,
                                                  fontWeight: FontWeight.w500),
                                            ),
                                            const SizedBox(width: 12),
                                          ],
                                          Icon(Icons.access_time_rounded,
                                              size: 14,
                                              color: _mutedColor.withValues(
                                                  alpha: 0.7)),
                                          const SizedBox(width: 4),
                                          Text(
                                            _formatTimeAgo(createdAt),
                                            style: TextStyle(
                                                color: _mutedColor.withValues(
                                                    alpha: 0.8),
                                                fontSize: 12),
                                          ),
                                        ],
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                      );
                    },
                  ),
                );
              },
            );
          },
        ),
      ],
    );
  }
}

class _TopNavChip extends StatelessWidget {
  const _TopNavChip({
    required this.label,
    required this.icon,
    this.isActive = false,
    this.activeColor,
    this.inactiveColor,
    this.onTap,
    this.activeIcon,
    this.activeTextColor,
    this.inactiveTextColor,
    this.activeIconColor,
    this.inactiveIconColor,
  });

  final String label;
  final IconData icon;
  final bool isActive;
  final Color? activeColor;
  final Color? inactiveColor;
  final VoidCallback? onTap;
  final IconData? activeIcon;
  final Color? activeTextColor;
  final Color? inactiveTextColor;
  final Color? activeIconColor;
  final Color? inactiveIconColor;

  @override
  Widget build(BuildContext context) {
    const Color defaultActive = Color(0xFFF5A26C);
    const Color defaultInactive = Color(0xFFF9D9BF);
    final Color background = isActive
        ? (activeColor ?? defaultActive)
        : (inactiveColor ?? defaultInactive);
    final Color textColor = isActive
        ? (activeTextColor ?? Colors.white)
        : (inactiveTextColor ?? Colors.white);
    final Color iconColor = isActive
        ? (activeIconColor ?? Colors.white)
        : (inactiveIconColor ?? Colors.white);
    final IconData displayIcon =
        isActive && activeIcon != null ? activeIcon! : icon;

    return Container(
      constraints: const BoxConstraints(minWidth: 220),
      decoration: BoxDecoration(
        color: background,
        borderRadius: BorderRadius.circular(14),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 8,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(14),
          onTap: onTap,
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 14),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(displayIcon, color: iconColor),
                const SizedBox(width: 12),
                Text(
                  label,
                  style: TextStyle(
                    color: textColor,
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class _LevelCard extends StatefulWidget {
  const _LevelCard({required this.borderColor});

  final Color borderColor;

  @override
  State<_LevelCard> createState() => _LevelCardState();
}

class _LevelCardState extends State<_LevelCard> {
  int _thinkKeepCompleted = 0;
  int _thinkKeepTotal = 0;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadProgress();
  }

  Future<void> _loadProgress() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) {
      if (mounted) setState(() => _isLoading = false);
      return;
    }

    try {
      // Get all courses with Think or Keep tags
      final coursesSnapshot =
          await FirebaseFirestore.instance.collection('courses').get();

      final thinkKeepCourses = <String>[];
      for (final doc in coursesSnapshot.docs) {
        final data = doc.data();
        final topic = (data['topic'] as String?)?.toLowerCase();
        if (topic == 'think' || topic == 'keep') {
          thinkKeepCourses.add(doc.id);
        }
      }

      // Get completed courses
      final completedSnapshot = await FirebaseFirestore.instance
          .collection('users')
          .doc(uid)
          .collection('completed_courses')
          .get();

      final completedIds = completedSnapshot.docs.map((doc) => doc.id).toSet();
      final completed =
          thinkKeepCourses.where((id) => completedIds.contains(id)).length;

      if (mounted) {
        setState(() {
          _thinkKeepCompleted = completed;
          _thinkKeepTotal = thinkKeepCourses.length;
          _isLoading = false;
        });
      }
    } catch (e) {
      debugPrint('Failed to load level progress: $e');
      if (mounted) setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final progress =
        _thinkKeepTotal > 0 ? _thinkKeepCompleted / _thinkKeepTotal : 0.0;
    final percentage = (progress * 100).toInt();

    return _DashboardCard(
      borderColor: widget.borderColor,
      child: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: const [
                    _CardIcon(
                        color: Color(0xFF7C7FE9),
                        icon: Icons.emoji_events_outlined),
                    SizedBox(width: 12),
                    Text(
                      'Level 1 Learner',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.w700,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                const Text(
                  'Complete Think & Keep courses to level up',
                  style: TextStyle(color: Color(0xFF6B7280), fontSize: 14),
                ),
                const SizedBox(height: 16),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      '$_thinkKeepCompleted / $_thinkKeepTotal',
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.w700,
                      ),
                    ),
                    Text(
                      '$percentage%',
                      style: const TextStyle(
                        color: Color(0xFF7C7FE9),
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: LinearProgressIndicator(
                    value: progress,
                    minHeight: 10,
                    backgroundColor: const Color(0xFFE5E7EB),
                    valueColor:
                        const AlwaysStoppedAnimation<Color>(Color(0xFF3B82F6)),
                  ),
                ),
              ],
            ),
    );
  }
}

class _LearningTimeCard extends StatefulWidget {
  const _LearningTimeCard({required this.borderColor});

  final Color borderColor;

  @override
  State<_LearningTimeCard> createState() => _LearningTimeCardState();
}

class _LearningTimeCardState extends State<_LearningTimeCard> {
  int _totalHours = 0;
  int _totalMinutes = 0;
  int _thisMonthMinutes = 0;
  int _lastMonthMinutes = 0;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadLearningTime();
  }

  Future<void> _loadLearningTime() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) {
      if (mounted) setState(() => _isLoading = false);
      return;
    }

    try {
      final sessionsRef = FirebaseFirestore.instance
          .collection('users')
          .doc(uid)
          .collection('learning_sessions');

      final allSessions =
          await sessionsRef.where('status', isEqualTo: 'completed').get();

      int totalMinutes = 0;
      int thisMonthMinutes = 0;
      int lastMonthMinutes = 0;

      final now = DateTime.now();
      final thisMonthStart = DateTime(now.year, now.month, 1);
      final lastMonthStart = DateTime(now.year, now.month - 1, 1);
      final lastMonthEnd = thisMonthStart.subtract(const Duration(days: 1));

      for (final doc in allSessions.docs) {
        final data = doc.data();
        final minutes = data['durationMinutes'] as int? ?? 0;
        totalMinutes += minutes;

        final startAt = (data['startAt'] as Timestamp?)?.toDate();
        if (startAt != null) {
          if (startAt.isAfter(thisMonthStart) ||
              startAt.isAtSameMomentAs(thisMonthStart)) {
            thisMonthMinutes += minutes;
          } else if (startAt.isAfter(lastMonthStart) &&
              startAt.isBefore(thisMonthStart)) {
            lastMonthMinutes += minutes;
          }
        }
      }

      if (mounted) {
        setState(() {
          _totalMinutes = totalMinutes;
          _totalHours = (totalMinutes / 60).floor();
          _thisMonthMinutes = thisMonthMinutes;
          _lastMonthMinutes = lastMonthMinutes;
          _isLoading = false;
        });
      }
    } catch (e) {
      debugPrint('Failed to load learning time: $e');
      if (mounted) setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final difference = _thisMonthMinutes - _lastMonthMinutes;
    final diffHours = (difference.abs() / 60);
    final diffText = diffHours >= 1
        ? '${diffHours.toStringAsFixed(1)} hours'
        : '${difference.abs()} minutes';
    final isPositive = difference > 0;

    return _DashboardCard(
      borderColor: widget.borderColor,
      child: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: const [
                    _CardIcon(
                        color: Color(0xFF5E81F4),
                        icon: Icons.schedule_outlined),
                    SizedBox(width: 12),
                    Text(
                      'Learning Time',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.w700,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                const Text(
                  'Total time invested',
                  style: TextStyle(color: Color(0xFF6B7280), fontSize: 14),
                ),
                const SizedBox(height: 20),
                Text(
                  '$_totalHours Hours',
                  style: const TextStyle(
                    fontSize: 32,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                if (_totalMinutes % 60 > 0)
                  Padding(
                    padding: const EdgeInsets.only(top: 4),
                    child: Text(
                      '${_totalMinutes % 60} minutes',
                      style: const TextStyle(
                        color: Color(0xFF6B7280),
                        fontSize: 14,
                      ),
                    ),
                  ),
                const SizedBox(height: 12),
                if (difference != 0)
                  Row(
                    children: [
                      Icon(
                        isPositive ? Icons.trending_up : Icons.trending_down,
                        color: isPositive
                            ? const Color(0xFF21A179)
                            : const Color(0xFFEF4444),
                        size: 20,
                      ),
                      const SizedBox(width: 6),
                      Expanded(
                        child: Text(
                          '$diffText ${isPositive ? "more" : "less"} than last month',
                          style: TextStyle(
                            color: isPositive
                                ? const Color(0xFF21A179)
                                : const Color(0xFFEF4444),
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      ),
                    ],
                  )
                else
                  Row(
                    children: const [
                      Icon(Icons.info_outline,
                          color: Color(0xFF6B7280), size: 20),
                      SizedBox(width: 6),
                      Text(
                        'Keep learning to track progress',
                        style: TextStyle(
                          color: Color(0xFF6B7280),
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
              ],
            ),
    );
  }
}

class _StreakCard extends StatefulWidget {
  const _StreakCard({required this.borderColor});

  final Color borderColor;

  @override
  State<_StreakCard> createState() => _StreakCardState();
}

class _StreakCardState extends State<_StreakCard> {
  int _currentStreak = 0;
  int _longestStreak = 0;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadStreak();
  }

  Future<void> _loadStreak() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) {
      if (mounted) setState(() => _isLoading = false);
      return;
    }

    try {
      final streaks = await _calculateStreaks(uid);
      if (mounted) {
        setState(() {
          _currentStreak = streaks['current'] ?? 0;
          _longestStreak = streaks['longest'] ?? 0;
          _isLoading = false;
        });
      }
    } catch (e) {
      debugPrint('Failed to load streak: $e');
      if (mounted) setState(() => _isLoading = false);
    }
  }

  Future<Map<String, int>> _calculateStreaks(String uid) async {
    final activityRef = FirebaseFirestore.instance
        .collection('users')
        .doc(uid)
        .collection('activity');

    final snapshot = await activityRef.orderBy('date', descending: true).get();

    if (snapshot.docs.isEmpty) {
      return {'current': 0, 'longest': 0};
    }

    final dates = snapshot.docs
        .map((doc) {
          final timestamp = doc.data()['date'] as Timestamp?;
          return timestamp?.toDate();
        })
        .where((date) => date != null)
        .map((date) => DateTime(date!.year, date.month, date.day))
        .toSet()
        .toList()
      ..sort((a, b) => b.compareTo(a));

    if (dates.isEmpty) {
      return {'current': 0, 'longest': 0};
    }

    int currentStreak = 0;
    int longestStreak = 0;
    int tempStreak = 1;
    final today = DateTime.now();
    final todayNormalized = DateTime(today.year, today.month, today.day);

    // Check if today or yesterday is in the dates to start counting current streak
    final yesterday = todayNormalized.subtract(const Duration(days: 1));
    if (dates.first == todayNormalized || dates.first == yesterday) {
      currentStreak = 1;
      DateTime expectedDate = dates.first.subtract(const Duration(days: 1));

      for (int i = 1; i < dates.length; i++) {
        if (dates[i] == expectedDate) {
          currentStreak++;
          expectedDate = expectedDate.subtract(const Duration(days: 1));
        } else {
          break;
        }
      }
    }

    // Calculate longest streak
    for (int i = 1; i < dates.length; i++) {
      final daysDiff = dates[i - 1].difference(dates[i]).inDays;
      if (daysDiff == 1) {
        tempStreak++;
      } else {
        longestStreak = longestStreak > tempStreak ? longestStreak : tempStreak;
        tempStreak = 1;
      }
    }
    longestStreak = longestStreak > tempStreak ? longestStreak : tempStreak;
    longestStreak =
        longestStreak > currentStreak ? longestStreak : currentStreak;

    return {'current': currentStreak, 'longest': longestStreak};
  }

  @override
  Widget build(BuildContext context) {
    return _DashboardCard(
      borderColor: widget.borderColor,
      child: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: const [
                    _CardIcon(
                        color: Color(0xFF6F81FF),
                        icon: Icons.calendar_today_outlined),
                    SizedBox(width: 12),
                    Text(
                      'Learning Streak',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.w700,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                const Text(
                  'Consecutive days active',
                  style: TextStyle(color: Color(0xFF6B7280), fontSize: 14),
                ),
                const SizedBox(height: 20),
                Text(
                  '$_currentStreak',
                  style: const TextStyle(
                    fontSize: 36,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                const SizedBox(height: 4),
                const Text(
                  'days',
                  style: TextStyle(
                    color: Color(0xFF6B7280),
                    fontSize: 14,
                  ),
                ),
                const SizedBox(height: 12),
                if (_currentStreak >= _longestStreak && _currentStreak > 0)
                  Row(
                    children: const [
                      Icon(Icons.emoji_emotions_outlined,
                          color: Color(0xFF10B981), size: 20),
                      SizedBox(width: 6),
                      Text(
                        'Your longest streak yet!',
                        style: TextStyle(
                          color: Color(0xFF10B981),
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  )
                else if (_currentStreak > 0)
                  Row(
                    children: [
                      const Icon(Icons.local_fire_department,
                          color: Color(0xFFFF9800), size: 20),
                      const SizedBox(width: 6),
                      Text(
                        'Best: $_longestStreak days',
                        style: const TextStyle(
                          color: Color(0xFF6B7280),
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  )
                else
                  Row(
                    children: const [
                      Icon(Icons.info_outline,
                          color: Color(0xFF6B7280), size: 20),
                      SizedBox(width: 6),
                      Text(
                        'Start learning to build a streak',
                        style: TextStyle(
                          color: Color(0xFF6B7280),
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
              ],
            ),
    );
  }
}

class _AchievementsCard extends StatefulWidget {
  const _AchievementsCard({required this.borderColor});

  final Color borderColor;

  @override
  State<_AchievementsCard> createState() => _AchievementsCardState();
}

class _AchievementsCardState extends State<_AchievementsCard> {
  int _coursesCompleted = 0;
  int _videosWatched = 0;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadAchievements();
  }

  Future<void> _loadAchievements() async {
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid == null) {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
      return;
    }

    try {
      // Get courses completed count
      final completedCoursesSnapshot = await FirebaseFirestore.instance
          .collection('users')
          .doc(uid)
          .collection('completed_courses')
          .get();

      // Get videos watched count
      final userDoc =
          await FirebaseFirestore.instance.collection('users').doc(uid).get();

      final videosWatched = userDoc.data()?['videosWatched'] as int? ?? 0;

      if (mounted) {
        setState(() {
          _coursesCompleted = completedCoursesSnapshot.docs.length;
          _videosWatched = videosWatched;
          _isLoading = false;
        });
      }
    } catch (e) {
      debugPrint('Failed to load achievements: $e');
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return _DashboardCard(
      borderColor: widget.borderColor,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Achievements',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 4),
          const Text(
            'Badges and milestones you\'ve reached',
            style: TextStyle(color: Color(0xFF6B7280), fontSize: 14),
          ),
          const SizedBox(height: 24),
          Row(
            children: [
              const Icon(Icons.play_circle_outline, color: Color(0xFFF5A26C)),
              const SizedBox(width: 12),
              const Expanded(
                child: Text(
                  'Videos Watched',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
              _isLoading
                  ? const SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : Text(
                      '$_videosWatched',
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
            ],
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              const Icon(Icons.school_outlined, color: Color(0xFF3B82F6)),
              const SizedBox(width: 12),
              const Expanded(
                child: Text(
                  'Courses Completed',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
              _isLoading
                  ? const SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : Text(
                      '$_coursesCompleted',
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
            ],
          ),
          const SizedBox(height: 24),
          const Divider(),
          const SizedBox(height: 16),
          const Text(
            'Coach Notes',
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 12),
          StreamBuilder<QuerySnapshot>(
            stream: FirebaseFirestore.instance
                .collection('coachingNotes')
                .where('memberId',
                    isEqualTo: FirebaseAuth.instance.currentUser?.uid)
                .snapshots(),
            builder: (context, snapshot) {
              if (snapshot.connectionState == ConnectionState.waiting) {
                return const Center(
                  child: Padding(
                    padding: EdgeInsets.all(16),
                    child: CircularProgressIndicator(strokeWidth: 2),
                  ),
                );
              }

              if (snapshot.hasError) {
                debugPrint('Error loading coach notes: ${snapshot.error}');
                return Padding(
                  padding: const EdgeInsets.all(16),
                  child: Text(
                    'Error loading notes',
                    style: TextStyle(color: Colors.red.shade400, fontSize: 14),
                  ),
                );
              }

              // Filter out drafts and sort by createdAt in memory
              var notes = (snapshot.data?.docs ?? []).where((doc) {
                final data = doc.data() as Map<String, dynamic>;
                return data['isDraft'] != true;
              }).toList();

              // Sort by createdAt descending
              notes.sort((a, b) {
                final aData = a.data() as Map<String, dynamic>;
                final bData = b.data() as Map<String, dynamic>;
                final aTime = aData['createdAt'] as Timestamp?;
                final bTime = bData['createdAt'] as Timestamp?;
                if (aTime == null && bTime == null) return 0;
                if (aTime == null) return 1;
                if (bTime == null) return -1;
                return bTime.compareTo(aTime);
              });

              // Don't limit - allow scrolling instead

              if (notes.isEmpty) {
                return const Padding(
                  padding: EdgeInsets.all(16),
                  child: Text(
                    'No notes from your coach yet',
                    style: TextStyle(color: Color(0xFF9CA3AF), fontSize: 14),
                  ),
                );
              }

              // Make scrollable with max height
              return ConstrainedBox(
                constraints: const BoxConstraints(maxHeight: 300),
                child: SingleChildScrollView(
                  child: Column(
                children: notes.asMap().entries.map((entry) {
                  final index = entry.key;
                  final doc = entry.value;
                  final data = doc.data() as Map<String, dynamic>;
                  final title = data['title'] as String? ?? 'Note';
                  final content = data['content'] as String? ?? '';
                  final noteType = data['noteType'] as String? ??
                      data['tag'] as String? ??
                      'Note';
                  
                  // Determine note type color and icon
                  Color noteColor;
                  IconData noteIcon;
                  if (noteType == 'Goal') {
                    noteColor = const Color(0xFF10B981); // Green
                    noteIcon = Icons.flag_outlined;
                  } else if (noteType == 'Session Note') {
                    noteColor = const Color(0xFF3B82F6); // Blue
                    noteIcon = Icons.event_note_outlined;
                  } else {
                    noteColor = const Color(0xFF6B7280); // Gray
                    noteIcon = Icons.sticky_note_2_outlined;
                  }
                  return Padding(
                    padding: EdgeInsets.only(
                        bottom: index == notes.length - 1 ? 0 : 12),
                    child: InkWell(
                      onTap: () {
                        // Show note details dialog
                        showDialog(
                          context: context,
                          builder: (context) => _MemberNoteDetailDialog(
                            noteId: doc.id,
                            data: data,
                          ),
                        );
                      },
                      borderRadius: BorderRadius.circular(12),
                      child: Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.white,
                          borderRadius: BorderRadius.circular(12),
                          border: Border.all(color: const Color(0xFFE5E7EB)),
                        ),
                        child: Row(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Container(
                              padding: const EdgeInsets.all(8),
                              decoration: BoxDecoration(
                                color: noteColor.withOpacity(0.1),
                                borderRadius: BorderRadius.circular(8),
                              ),
                              child: Icon(
                                noteIcon,
                                size: 20,
                                color: noteColor,
                              ),
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Row(
                                    children: [
                                      Expanded(
                                        child: Text(
                                          title,
                                          style: const TextStyle(
                                            color: Color(0xFF1F2937),
                                            fontWeight: FontWeight.w600,
                                            fontSize: 14,
                                          ),
                                        ),
                                      ),
                                      Container(
                                        padding: const EdgeInsets.symmetric(
                                            horizontal: 8, vertical: 4),
                                        decoration: BoxDecoration(
                                          color: noteColor.withOpacity(0.1),
                                          borderRadius: BorderRadius.circular(6),
                                        ),
                                        child: Text(
                                          noteType,
                                          style: TextStyle(
                                            color: noteColor,
                                            fontSize: 11,
                                            fontWeight: FontWeight.w600,
                                          ),
                                        ),
                                      ),
                                    ],
                                  ),
                                  if (content.isNotEmpty) ...[
                                    const SizedBox(height: 6),
                                    Text(
                                      content.length > 80
                                          ? '${content.substring(0, 80)}...'
                                          : content,
                                      style: const TextStyle(
                                        color: Color(0xFF6B7280),
                                        fontSize: 12,
                                      ),
                                      maxLines: 2,
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                  ],
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  );
                }).toList(),
                  ),
                ),
              );
            },
          ),
        ],
      ),
    );
  }
}


// Member Note Detail Dialog - shows full note content when tapped
class _MemberNoteDetailDialog extends StatelessWidget {
  const _MemberNoteDetailDialog({
    required this.noteId,
    required this.data,
  });

  final String noteId;
  final Map<String, dynamic> data;

  @override
  Widget build(BuildContext context) {
    final title = data['title'] as String? ?? 'Untitled';
    final content = data['content'] as String? ?? '';
    final noteType = data['noteType'] as String? ?? data['tag'] as String? ?? 'Note';
    
    // Determine note type color
    Color noteColor;
    IconData noteIcon;
    if (noteType == 'Goal') {
      noteColor = const Color(0xFF10B981); // Green
      noteIcon = Icons.flag_outlined;
    } else if (noteType == 'Session Note') {
      noteColor = const Color(0xFF3B82F6); // Blue
      noteIcon =Icons.event_note_outlined;
    } else {
      noteColor = const Color(0xFF6B7280); // Gray
      noteIcon = Icons.sticky_note_2_outlined;
    }

    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
      child: Container(
        width: 600,
        constraints: const BoxConstraints(maxHeight: 600),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(24),
              decoration: BoxDecoration(
                color: noteColor,
                borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
              ),
              child: Row(
                children: [
                  Icon(noteIcon, color: Colors.white, size: 28),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          title,
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 20,
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                        const SizedBox(height: 4),
                        Container(
                          padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                          decoration: BoxDecoration(
                            color: Colors.white.withOpacity(0.2),
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Text(
                            noteType,
                            style: const TextStyle(
                              color: Colors.white,
                              fontSize: 12,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  IconButton(
                    onPressed: () => Navigator.of(context).pop(),
                    icon: const Icon(Icons.close, color: Colors.white),
                  ),
                ],
              ),
            ),
            Flexible(
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(24),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    if (noteType == 'Goal') ...[
                      // Show goal-specific fields if available
                      if (data['startDate'] != null || data['endDate'] != null) ...[
                        Row(
                          children: [
                            if (data['startDate'] != null) ...[
                              const Icon(Icons.calendar_today, size: 16, color: Color(0xFF6B7280)),
                              const SizedBox(width: 6),
                              Text(
                                'Start: ${_formatDate(data['startDate'])}',
                                style: const TextStyle(color: Color(0xFF6B7280), fontSize: 14),
                              ),
                              const SizedBox(width: 16),
                            ],
                            if (data['endDate'] != null) ...[
                              const Icon(Icons.event, size: 16, color: Color(0xFF6B7280)),
                              const SizedBox(width: 6),
                              Text(
                                'End: ${_formatDate(data['endDate'])}',
                                style: const TextStyle(color: Color(0xFF6B7280), fontSize: 14),
                              ),
                            ],
                          ],
                        ),
                        const SizedBox(height: 16),
                      ],
                    ],
                    if (noteType == 'Session Note') ...[
                      // Show session-specific fields
                      if (data['sessionDate'] != null) ...[
                        Row(
                          children: [
                            const Icon(Icons.event, size: 16, color: Color(0xFF6B7280)),
                            const SizedBox(width: 6),
                            Text(
                              'Session Date: ${_formatDate(data['sessionDate'])}',
                              style: const TextStyle(color: Color(0xFF6B7280), fontSize: 14),
                            ),
                          ],
                        ),
                        const SizedBox(height: 16),
                      ],
                    ],
                    const Text(
                      'Note Content',
                      style: TextStyle(
                        color: Color(0xFF374151),
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      content.isNotEmpty ? content : 'No content',
                      style: const TextStyle(
                        color: Color(0xFF6B7280),
                        fontSize: 14,
                        height: 1.6,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _formatDate(dynamic date) {
    if (date == null) return '';
    if (date is Timestamp) {
      final dt = date.toDate();
      return '${dt.month}/${dt.day}/${dt.year}';
    }
    return '';
  }
}

class _ProgressByCategoryCard extends StatefulWidget {
  const _ProgressByCategoryCard({required this.borderColor});

  final Color borderColor;

  @override
  State<_ProgressByCategoryCard> createState() =>
      _ProgressByCategoryCardState();
}

class _ProgressByCategoryCardState extends State<_ProgressByCategoryCard> {
  late Future<List<_PieSlice>> _loadFuture;

  @override
  void initState() {
    super.initState();
    final uid = FirebaseAuth.instance.currentUser?.uid;
    if (uid != null) {
      _loadFuture = CategoryProgressService.loadSlicesForUser(uid);
    } else {
      _loadFuture =
          Future.value(CategoryProgressService.buildSlicesFromCounts(const {}));
    }
  }

  @override
  Widget build(BuildContext context) {
    return _DashboardCard(
      borderColor: widget.borderColor,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Progress by Category',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.w700,
            ),
          ),
          const SizedBox(height: 4),
          const Text(
            'Your completion by content category',
            style: TextStyle(color: Color(0xFF6B7280), fontSize: 14),
          ),
          const SizedBox(height: 24),
          FutureBuilder<List<_PieSlice>>(
            future: _loadFuture,
            builder: (context, snapshot) {
              final bool isLoading =
                  snapshot.connectionState == ConnectionState.waiting &&
                      !snapshot.hasData;
              final slices = snapshot.data ??
                  CategoryProgressService.buildSlicesFromCounts(const {});
              final double total =
                  slices.fold<double>(0, (sum, slice) => sum + slice.value);

              Widget chartChild;
              if (isLoading) {
                chartChild = const SizedBox(
                  width: 32,
                  height: 32,
                  child: CircularProgressIndicator(strokeWidth: 2),
                );
              } else if (total <= 0) {
                chartChild = const Text(
                  'No modules completed yet.',
                  style: TextStyle(
                    color: Color(0xFF9CA3AF),
                    fontSize: 14,
                    fontWeight: FontWeight.w600,
                  ),
                );
              } else {
                chartChild = PieChart(
                  PieChartData(
                    sectionsSpace: 2,
                    centerSpaceRadius: 40,
                    sections: slices
                        .map(
                          (slice) => PieChartSectionData(
                            value: slice.value,
                            color: slice.color,
                            title: '',
                            radius: 80,
                          ),
                        )
                        .toList(),
                  ),
                );
              }

              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(
                    height: 220,
                    child: Align(
                      alignment: Alignment.center,
                      child: chartChild,
                    ),
                  ),
                  const SizedBox(height: 16),
                  Wrap(
                    spacing: 12,
                    runSpacing: 12,
                    children: slices
                        .map(
                          (slice) => _LegendChip(
                              color: slice.color, label: slice.label),
                        )
                        .toList(),
                  ),
                  if (snapshot.hasError) ...[
                    const SizedBox(height: 12),
                    const Text(
                      'Unable to load progress data right now.',
                      style: TextStyle(
                        color: Color(0xFFB91C1C),
                        fontSize: 12,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ],
                ],
              );
            },
          ),
        ],
      ),
    );
  }
}

class _DashboardCard extends StatelessWidget {
  const _DashboardCard({required this.child, required this.borderColor});

  final Widget child;
  final Color borderColor;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.03),
            blurRadius: 14,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: child,
    );
  }
}

class _CardIcon extends StatelessWidget {
  const _CardIcon({required this.color, required this.icon});

  final Color color;
  final IconData icon;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: color.withOpacity(0.12),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Icon(
        icon,
        color: color,
        size: 24,
      ),
    );
  }
}

class _LegendChip extends StatelessWidget {
  const _LegendChip({required this.color, required this.label});

  final Color color;
  final String label;

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: 12,
          height: 12,
          decoration: BoxDecoration(
            color: color,
            borderRadius: BorderRadius.circular(4),
          ),
        ),
        const SizedBox(width: 6),
        Text(
          label,
          style: const TextStyle(
            fontSize: 14,
            color: Color(0xFF6B7280),
            fontWeight: FontWeight.w600,
          ),
        ),
      ],
    );
  }
}

class _PieSlice {
  const _PieSlice(this.label, this.value, this.color);

  final String label;
  final double value;
  final Color color;
}

// ============================================================================
// ANNOUNCEMENT MARQUEE SYSTEM
// ============================================================================

/// Animated marquee banner that displays admin announcements across the app.
/// Fetches announcement configuration from Firestore and displays a smooth
/// scrolling text banner when enabled.
class AnnouncementMarquee extends StatefulWidget {
  const AnnouncementMarquee({super.key});

  @override
  State<AnnouncementMarquee> createState() => _AnnouncementMarqueeState();
}

class _AnnouncementMarqueeState extends State<AnnouncementMarquee>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  bool _isEnabled = false;
  String _text = '';
  Color _backgroundColor = const Color(0xFF1E40AF);
  Color _textColor = Colors.white;
  double _speed = 50.0;
  bool _isLoading = true;
  StreamSubscription<DocumentSnapshot>? _subscription;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 20),
    );
    _loadAnnouncementSettings();
  }

  void _loadAnnouncementSettings() {
    _subscription = FirebaseFirestore.instance
        .collection('app_settings')
        .doc('announcements')
        .snapshots()
        .listen((snapshot) {
      if (!mounted) return;
      final data = snapshot.data();
      if (data == null) {
        setState(() {
          _isEnabled = false;
          _isLoading = false;
        });
        return;
      }

      final enabled = data['enabled'] as bool? ?? false;
      final text = data['text'] as String? ?? '';
      final bgColorHex = data['backgroundColor'] as String? ?? '#1E40AF';
      final textColorHex = data['textColor'] as String? ?? '#FFFFFF';
      final speed = (data['speed'] as num?)?.toDouble() ?? 50.0;

      setState(() {
        _isEnabled = enabled && text.trim().isNotEmpty;
        _text = text;
        _backgroundColor = _hexToColor(bgColorHex);
        _textColor = _hexToColor(textColorHex);
        _speed = speed;
        _isLoading = false;
      });

      if (_isEnabled) {
        // Calculate duration based on text length and speed
        final duration =
            Duration(milliseconds: (text.length * 150 * (100 / speed)).toInt());
        _controller.duration = duration;
        _controller.repeat();
      } else {
        _controller.stop();
      }
    }, onError: (e) {
      debugPrint('Error loading announcement settings: $e');
      if (mounted) {
        setState(() {
          _isEnabled = false;
          _isLoading = false;
        });
      }
    });
  }

  Color _hexToColor(String hex) {
    hex = hex.replaceFirst('#', '');
    if (hex.length == 6) hex = 'FF$hex';
    return Color(int.parse(hex, radix: 16));
  }

  @override
  void dispose() {
    _subscription?.cancel();
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading || !_isEnabled || _text.isEmpty) {
      return const SizedBox.shrink();
    }

    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            _backgroundColor,
            _backgroundColor.withValues(alpha: 0.85),
            _backgroundColor,
          ],
          stops: const [0.0, 0.5, 1.0],
        ),
        boxShadow: [
          BoxShadow(
            color: _backgroundColor.withValues(alpha: 0.3),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: ClipRect(
        child: SizedBox(
          height: 44,
          child: AnimatedBuilder(
            animation: _controller,
            builder: (context, child) {
              return LayoutBuilder(
                builder: (context, constraints) {
                  final textWidth = _calculateTextWidth(
                      _text,
                      TextStyle(
                        color: _textColor,
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                        letterSpacing: 0.3,
                      ));
                  final totalWidth = constraints.maxWidth + textWidth;
                  final offset = _controller.value * totalWidth - textWidth;

                  return Stack(
                    clipBehavior: Clip.none,
                    children: [
                      Positioned(
                        left: -offset,
                        top: 0,
                        bottom: 0,
                        child: Row(
                          children: [
                            _buildMarqueeContent(),
                            SizedBox(width: constraints.maxWidth * 0.5),
                            _buildMarqueeContent(),
                          ],
                        ),
                      ),
                    ],
                  );
                },
              );
            },
          ),
        ),
      ),
    );
  }

  Widget _buildMarqueeContent() {
    return Center(
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
            decoration: BoxDecoration(
              color: _textColor.withValues(alpha: 0.2),
              borderRadius: BorderRadius.circular(20),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.campaign_rounded, color: _textColor, size: 16),
                const SizedBox(width: 6),
                Text(
                  'ANNOUNCEMENT',
                  style: TextStyle(
                    color: _textColor,
                    fontSize: 11,
                    fontWeight: FontWeight.w800,
                    letterSpacing: 1.2,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(width: 20),
          Text(
            _text,
            style: TextStyle(
              color: _textColor,
              fontSize: 14,
              fontWeight: FontWeight.w600,
              letterSpacing: 0.3,
            ),
          ),
          const SizedBox(width: 60),
          Icon(Icons.star_rounded,
              color: _textColor.withValues(alpha: 0.5), size: 16),
          const SizedBox(width: 60),
        ],
      ),
    );
  }

  double _calculateTextWidth(String text, TextStyle style) {
    final textPainter = TextPainter(
      text: TextSpan(text: text, style: style),
      textDirection: ui.TextDirection.ltr,
    )..layout();
    return textPainter.width + 300; // Add padding for the badge
  }
}

// ============================================================================
// ADMIN SYSTEM SETTINGS PAGE
// ============================================================================

/// Admin-only system settings page with announcement configuration.
class AdminSystemSettingsPage extends StatefulWidget {
  const AdminSystemSettingsPage({super.key});

  static const Color _titleColor = Color(0xFF111827);
  static const Color _mutedColor = Color(0xFF6B7280);
  static const Color _borderColor = Color(0xFFE5E7EB);
  static const Color _accentBlue = Color(0xFF2563EB);
  static const Color _successGreen = Color(0xFF10B981);

  @override
  State<AdminSystemSettingsPage> createState() =>
      _AdminSystemSettingsPageState();
}

enum _AdminSettingsTab { announcements, general }

class _AdminSystemSettingsPageState extends State<AdminSystemSettingsPage> {
  _AdminSettingsTab _activeTab = _AdminSettingsTab.announcements;

  // Announcement settings
  bool _announcementEnabled = false;
  final TextEditingController _announcementTextController =
      TextEditingController();
  String _selectedBgColor = '#1E40AF';
  String _selectedTextColor = '#FFFFFF';
  double _announcementSpeed = 50.0;
  bool _isSaving = false;
  bool _isLoading = true;

  // General settings
  bool _isLoadingGeneral = true;
  bool _isSavingGeneral = false;
  final TextEditingController _platformNameController = TextEditingController();
  final TextEditingController _supportEmailController = TextEditingController();
  bool _allowSelfRegistration = true;
  String _defaultUserRole = 'Member';
  bool _autoPlayVideos = true;
  int _sessionTimeoutMinutes = 60;
  bool _maintenanceMode = false;
  bool _requireEmailVerification = false;

  static const List<Map<String, String>> _bgColorOptions = [
    {'name': 'Blue', 'value': '#1E40AF'},
    {'name': 'Purple', 'value': '#7C3AED'},
    {'name': 'Teal', 'value': '#0D9488'},
    {'name': 'Orange', 'value': '#EA580C'},
    {'name': 'Red', 'value': '#DC2626'},
    {'name': 'Green', 'value': '#16A34A'},
    {'name': 'Slate', 'value': '#334155'},
    {'name': 'Rose', 'value': '#E11D48'},
  ];

  static const List<Map<String, String>> _textColorOptions = [
    {'name': 'White', 'value': '#FFFFFF'},
    {'name': 'Light Gray', 'value': '#F3F4F6'},
    {'name': 'Yellow', 'value': '#FEF08A'},
    {'name': 'Cyan', 'value': '#A5F3FC'},
  ];

  @override
  void initState() {
    super.initState();
    _loadSettings();
    _loadGeneralSettings();
  }

  @override
  void dispose() {
    _announcementTextController.dispose();
    _platformNameController.dispose();
    _supportEmailController.dispose();
    super.dispose();
  }

  Future<void> _loadGeneralSettings() async {
    try {
      final doc = await FirebaseFirestore.instance
          .collection('app_settings')
          .doc('general')
          .get();

      if (doc.exists && mounted) {
        final data = doc.data()!;
        setState(() {
          _platformNameController.text =
              data['platformName'] as String? ?? 'Breakaway365';
          _supportEmailController.text = data['supportEmail'] as String? ?? '';
          _allowSelfRegistration =
              data['allowSelfRegistration'] as bool? ?? true;
          _defaultUserRole = data['defaultUserRole'] as String? ?? 'Member';
          _autoPlayVideos = data['autoPlayVideos'] as bool? ?? true;
          _sessionTimeoutMinutes = data['sessionTimeoutMinutes'] as int? ?? 60;
          _maintenanceMode = data['maintenanceMode'] as bool? ?? false;
          _requireEmailVerification =
              data['requireEmailVerification'] as bool? ?? false;
          _isLoadingGeneral = false;
        });
      } else {
        setState(() {
          _platformNameController.text = 'Breakaway365';
          _isLoadingGeneral = false;
        });
      }
    } catch (e) {
      debugPrint('Error loading general settings: $e');
      if (mounted) setState(() => _isLoadingGeneral = false);
    }
  }

  Future<void> _saveGeneralSettings() async {
    setState(() => _isSavingGeneral = true);
    try {
      await FirebaseFirestore.instance
          .collection('app_settings')
          .doc('general')
          .set({
        'platformName': _platformNameController.text.trim(),
        'supportEmail': _supportEmailController.text.trim(),
        'allowSelfRegistration': _allowSelfRegistration,
        'defaultUserRole': _defaultUserRole,
        'autoPlayVideos': _autoPlayVideos,
        'sessionTimeoutMinutes': _sessionTimeoutMinutes,
        'maintenanceMode': _maintenanceMode,
        'requireEmailVerification': _requireEmailVerification,
        'updatedAt': FieldValue.serverTimestamp(),
        'updatedBy': FirebaseAuth.instance.currentUser?.uid,
      }, SetOptions(merge: true));

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Row(
              children: [
                Icon(Icons.check_circle_rounded, color: Colors.white, size: 20),
                SizedBox(width: 12),
                Text('General settings saved successfully!'),
              ],
            ),
            backgroundColor: AdminSystemSettingsPage._successGreen,
            behavior: SnackBarBehavior.floating,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    } catch (e) {
      debugPrint('Error saving general settings: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to save settings: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) setState(() => _isSavingGeneral = false);
    }
  }

  Future<void> _loadSettings() async {
    try {
      final doc = await FirebaseFirestore.instance
          .collection('app_settings')
          .doc('announcements')
          .get();

      if (doc.exists && mounted) {
        final data = doc.data()!;
        setState(() {
          _announcementEnabled = data['enabled'] as bool? ?? false;
          _announcementTextController.text = data['text'] as String? ?? '';
          _selectedBgColor = data['backgroundColor'] as String? ?? '#1E40AF';
          _selectedTextColor = data['textColor'] as String? ?? '#FFFFFF';
          _announcementSpeed = (data['speed'] as num?)?.toDouble() ?? 50.0;
          _isLoading = false;
        });
      } else {
        setState(() => _isLoading = false);
      }
    } catch (e) {
      debugPrint('Error loading announcement settings: $e');
      if (mounted) setState(() => _isLoading = false);
    }
  }

  Future<void> _saveSettings() async {
    setState(() => _isSaving = true);
    try {
      await FirebaseFirestore.instance
          .collection('app_settings')
          .doc('announcements')
          .set({
        'enabled': _announcementEnabled,
        'text': _announcementTextController.text.trim(),
        'backgroundColor': _selectedBgColor,
        'textColor': _selectedTextColor,
        'speed': _announcementSpeed,
        'updatedAt': FieldValue.serverTimestamp(),
        'updatedBy': FirebaseAuth.instance.currentUser?.uid,
      }, SetOptions(merge: true));

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Row(
              children: [
                Icon(Icons.check_circle_rounded, color: Colors.white, size: 20),
                SizedBox(width: 12),
                Text('Announcement settings saved successfully!'),
              ],
            ),
            backgroundColor: AdminSystemSettingsPage._successGreen,
            behavior: SnackBarBehavior.floating,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          ),
        );
      }
    } catch (e) {
      debugPrint('Error saving announcement settings: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to save settings: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  Color _hexToColor(String hex) {
    hex = hex.replaceFirst('#', '');
    if (hex.length == 6) hex = 'FF$hex';
    return Color(int.parse(hex, radix: 16));
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final double horizontalPadding =
            constraints.maxWidth > 1180 ? 56.0 : 32.0;

        return SingleChildScrollView(
          padding:
              EdgeInsets.fromLTRB(horizontalPadding, 32, horizontalPadding, 48),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'System Settings',
                style: TextStyle(
                  color: AdminSystemSettingsPage._titleColor,
                  fontSize: 24,
                  fontWeight: FontWeight.w700,
                ),
              ),
              const SizedBox(height: 8),
              const Text(
                'Configure system-wide settings and announcements',
                style: TextStyle(
                  color: AdminSystemSettingsPage._mutedColor,
                  fontSize: 15,
                ),
              ),
              const SizedBox(height: 32),
              _buildTabBar(),
              const SizedBox(height: 32),
              _activeTab == _AdminSettingsTab.announcements
                  ? _buildAnnouncementsContent()
                  : _buildGeneralContent(),
            ],
          ),
        );
      },
    );
  }

  Widget _buildTabBar() {
    return Container(
      decoration: BoxDecoration(
        color: const Color(0xFFF5F6FA),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: AdminSystemSettingsPage._borderColor),
      ),
      child: Row(
        children: [
          Expanded(
            child: _AdminSettingsTabButton(
              label: 'Announcements',
              icon: Icons.campaign_rounded,
              isActive: _activeTab == _AdminSettingsTab.announcements,
              onTap: () =>
                  setState(() => _activeTab = _AdminSettingsTab.announcements),
            ),
          ),
          Container(
            height: 54,
            width: 1,
            color: AdminSystemSettingsPage._borderColor,
          ),
          Expanded(
            child: _AdminSettingsTabButton(
              label: 'General',
              icon: Icons.settings_outlined,
              isActive: _activeTab == _AdminSettingsTab.general,
              onTap: () =>
                  setState(() => _activeTab = _AdminSettingsTab.general),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildAnnouncementsContent() {
    if (_isLoading) {
      return const Center(
        child: Padding(
          padding: EdgeInsets.all(48),
          child: CircularProgressIndicator(),
        ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Preview Card
        _buildPreviewCard(),
        const SizedBox(height: 32),
        // Configuration Card
        _buildConfigurationCard(),
      ],
    );
  }

  Widget _buildPreviewCard() {
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: AdminSystemSettingsPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.04),
            blurRadius: 16,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(24),
            child: Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        AdminSystemSettingsPage._accentBlue
                            .withValues(alpha: 0.1),
                        AdminSystemSettingsPage._accentBlue
                            .withValues(alpha: 0.05),
                      ],
                    ),
                    borderRadius: BorderRadius.circular(14),
                  ),
                  child: const Icon(
                    Icons.preview_rounded,
                    color: AdminSystemSettingsPage._accentBlue,
                    size: 22,
                  ),
                ),
                const SizedBox(width: 16),
                const Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Live Preview',
                        style: TextStyle(
                          color: AdminSystemSettingsPage._titleColor,
                          fontSize: 18,
                          fontWeight: FontWeight.w700,
                        ),
                      ),
                      SizedBox(height: 4),
                      Text(
                        'See how your announcement will appear to users',
                        style: TextStyle(
                          color: AdminSystemSettingsPage._mutedColor,
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
                Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    color: _announcementEnabled
                        ? AdminSystemSettingsPage._successGreen
                            .withValues(alpha: 0.1)
                        : Colors.grey.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(20),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(
                        _announcementEnabled
                            ? Icons.visibility
                            : Icons.visibility_off,
                        size: 16,
                        color: _announcementEnabled
                            ? AdminSystemSettingsPage._successGreen
                            : Colors.grey,
                      ),
                      const SizedBox(width: 6),
                      Text(
                        _announcementEnabled ? 'Active' : 'Inactive',
                        style: TextStyle(
                          color: _announcementEnabled
                              ? AdminSystemSettingsPage._successGreen
                              : Colors.grey,
                          fontSize: 13,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          const Divider(height: 1, color: AdminSystemSettingsPage._borderColor),
          Container(
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              color: const Color(0xFFF8FAFC),
              borderRadius: const BorderRadius.only(
                bottomLeft: Radius.circular(24),
                bottomRight: Radius.circular(24),
              ),
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(12),
              child: _buildPreviewMarquee(),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPreviewMarquee() {
    final text = _announcementTextController.text.trim();
    if (text.isEmpty) {
      return Container(
        width: double.infinity,
        padding: const EdgeInsets.symmetric(vertical: 16),
        decoration: BoxDecoration(
          color: Colors.grey.withValues(alpha: 0.1),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
              color: Colors.grey.withValues(alpha: 0.2),
              style: BorderStyle.solid),
        ),
        child: const Center(
          child: Text(
            'Enter announcement text to see preview',
            style: TextStyle(
              color: AdminSystemSettingsPage._mutedColor,
              fontSize: 14,
              fontStyle: FontStyle.italic,
            ),
          ),
        ),
      );
    }

    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            _hexToColor(_selectedBgColor),
            _hexToColor(_selectedBgColor).withValues(alpha: 0.85),
            _hexToColor(_selectedBgColor),
          ],
          stops: const [0.0, 0.5, 1.0],
        ),
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: _hexToColor(_selectedBgColor).withValues(alpha: 0.3),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
            decoration: BoxDecoration(
              color: _hexToColor(_selectedTextColor).withValues(alpha: 0.2),
              borderRadius: BorderRadius.circular(20),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.campaign_rounded,
                    color: _hexToColor(_selectedTextColor), size: 16),
                const SizedBox(width: 6),
                Text(
                  'ANNOUNCEMENT',
                  style: TextStyle(
                    color: _hexToColor(_selectedTextColor),
                    fontSize: 11,
                    fontWeight: FontWeight.w800,
                    letterSpacing: 1.2,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Text(
              text,
              style: TextStyle(
                color: _hexToColor(_selectedTextColor),
                fontSize: 14,
                fontWeight: FontWeight.w600,
                letterSpacing: 0.3,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildConfigurationCard() {
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: AdminSystemSettingsPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.04),
            blurRadius: 16,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(24),
            child: Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        const Color(0xFF7C3AED).withValues(alpha: 0.1),
                        const Color(0xFF7C3AED).withValues(alpha: 0.05),
                      ],
                    ),
                    borderRadius: BorderRadius.circular(14),
                  ),
                  child: const Icon(
                    Icons.tune_rounded,
                    color: Color(0xFF7C3AED),
                    size: 22,
                  ),
                ),
                const SizedBox(width: 16),
                const Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Configuration',
                        style: TextStyle(
                          color: AdminSystemSettingsPage._titleColor,
                          fontSize: 18,
                          fontWeight: FontWeight.w700,
                        ),
                      ),
                      SizedBox(height: 4),
                      Text(
                        'Customize your announcement banner',
                        style: TextStyle(
                          color: AdminSystemSettingsPage._mutedColor,
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          const Divider(height: 1, color: AdminSystemSettingsPage._borderColor),
          Padding(
            padding: const EdgeInsets.all(24),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Enable Toggle
                _buildToggleRow(),
                const SizedBox(height: 28),
                // Announcement Text
                _buildTextInput(),
                const SizedBox(height: 28),
                // Color Selection
                _buildColorSelection(),
                const SizedBox(height: 28),
                // Speed Slider
                _buildSpeedSlider(),
                const SizedBox(height: 32),
                // Save Button
                _buildSaveButton(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildToggleRow() {
    return Container(
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: _announcementEnabled
            ? AdminSystemSettingsPage._successGreen.withValues(alpha: 0.05)
            : const Color(0xFFF5F6FA),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: _announcementEnabled
              ? AdminSystemSettingsPage._successGreen.withValues(alpha: 0.2)
              : AdminSystemSettingsPage._borderColor,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(10),
            decoration: BoxDecoration(
              color: _announcementEnabled
                  ? AdminSystemSettingsPage._successGreen
                      .withValues(alpha: 0.15)
                  : Colors.white,
              borderRadius: BorderRadius.circular(12),
            ),
            child: Icon(
              _announcementEnabled
                  ? Icons.notifications_active_rounded
                  : Icons.notifications_off_rounded,
              color: _announcementEnabled
                  ? AdminSystemSettingsPage._successGreen
                  : AdminSystemSettingsPage._mutedColor,
              size: 24,
            ),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Enable Announcement Banner',
                  style: TextStyle(
                    color: AdminSystemSettingsPage._titleColor,
                    fontSize: 16,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  _announcementEnabled
                      ? 'The banner is visible to all coaches and users'
                      : 'The banner is currently hidden from all users',
                  style: const TextStyle(
                    color: AdminSystemSettingsPage._mutedColor,
                    fontSize: 13,
                  ),
                ),
              ],
            ),
          ),
          Switch.adaptive(
            value: _announcementEnabled,
            onChanged: (value) => setState(() => _announcementEnabled = value),
            activeColor: Colors.white,
            activeTrackColor: AdminSystemSettingsPage._successGreen,
            inactiveThumbColor: const Color(0xFFE5E7EB),
            inactiveTrackColor: const Color(0xFFF3F4F6),
          ),
        ],
      ),
    );
  }

  Widget _buildTextInput() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Row(
          children: [
            Icon(Icons.edit_note_rounded,
                color: AdminSystemSettingsPage._titleColor, size: 20),
            SizedBox(width: 8),
            Text(
              'Announcement Text',
              style: TextStyle(
                color: AdminSystemSettingsPage._titleColor,
                fontSize: 15,
                fontWeight: FontWeight.w700,
              ),
            ),
          ],
        ),
        const SizedBox(height: 12),
        TextField(
          controller: _announcementTextController,
          maxLines: 3,
          maxLength: 300,
          onChanged: (_) => setState(() {}),
          decoration: InputDecoration(
            hintText: 'Enter your announcement message here...',
            hintStyle: TextStyle(
                color:
                    AdminSystemSettingsPage._mutedColor.withValues(alpha: 0.6)),
            filled: true,
            fillColor: const Color(0xFFF9FAFB),
            contentPadding: const EdgeInsets.all(18),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14),
              borderSide:
                  const BorderSide(color: AdminSystemSettingsPage._borderColor),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14),
              borderSide: const BorderSide(
                  color: AdminSystemSettingsPage._accentBlue, width: 1.5),
            ),
            counterStyle: const TextStyle(
              color: AdminSystemSettingsPage._mutedColor,
              fontSize: 12,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildColorSelection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Row(
          children: [
            Icon(Icons.palette_rounded,
                color: AdminSystemSettingsPage._titleColor, size: 20),
            SizedBox(width: 8),
            Text(
              'Appearance',
              style: TextStyle(
                color: AdminSystemSettingsPage._titleColor,
                fontSize: 15,
                fontWeight: FontWeight.w700,
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Background Color',
                    style: TextStyle(
                      color: AdminSystemSettingsPage._mutedColor,
                      fontSize: 13,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: 10),
                  Wrap(
                    spacing: 10,
                    runSpacing: 10,
                    children: _bgColorOptions.map((option) {
                      final isSelected = _selectedBgColor == option['value'];
                      return _ColorChip(
                        color: _hexToColor(option['value']!),
                        label: option['name']!,
                        isSelected: isSelected,
                        onTap: () =>
                            setState(() => _selectedBgColor = option['value']!),
                      );
                    }).toList(),
                  ),
                ],
              ),
            ),
            const SizedBox(width: 24),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Text Color',
                    style: TextStyle(
                      color: AdminSystemSettingsPage._mutedColor,
                      fontSize: 13,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: 10),
                  Wrap(
                    spacing: 10,
                    runSpacing: 10,
                    children: _textColorOptions.map((option) {
                      final isSelected = _selectedTextColor == option['value'];
                      return _ColorChip(
                        color: _hexToColor(option['value']!),
                        label: option['name']!,
                        isSelected: isSelected,
                        onTap: () => setState(
                            () => _selectedTextColor = option['value']!),
                        showBorder: true,
                      );
                    }).toList(),
                  ),
                ],
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildSpeedSlider() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            const Icon(Icons.speed_rounded,
                color: AdminSystemSettingsPage._titleColor, size: 20),
            const SizedBox(width: 8),
            const Text(
              'Scroll Speed',
              style: TextStyle(
                color: AdminSystemSettingsPage._titleColor,
                fontSize: 15,
                fontWeight: FontWeight.w700,
              ),
            ),
            const Spacer(),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
              decoration: BoxDecoration(
                color:
                    AdminSystemSettingsPage._accentBlue.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(20),
              ),
              child: Text(
                '${_announcementSpeed.toInt()}%',
                style: const TextStyle(
                  color: AdminSystemSettingsPage._accentBlue,
                  fontSize: 13,
                  fontWeight: FontWeight.w700,
                ),
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            const Icon(Icons.slow_motion_video,
                color: AdminSystemSettingsPage._mutedColor, size: 18),
            Expanded(
              child: SliderTheme(
                data: SliderTheme.of(context).copyWith(
                  activeTrackColor: AdminSystemSettingsPage._accentBlue,
                  inactiveTrackColor: AdminSystemSettingsPage._borderColor,
                  thumbColor: AdminSystemSettingsPage._accentBlue,
                  overlayColor: AdminSystemSettingsPage._accentBlue
                      .withValues(alpha: 0.2),
                  trackHeight: 6,
                  thumbShape:
                      const RoundSliderThumbShape(enabledThumbRadius: 10),
                ),
                child: Slider(
                  value: _announcementSpeed,
                  min: 20,
                  max: 100,
                  divisions: 16,
                  onChanged: (value) =>
                      setState(() => _announcementSpeed = value),
                ),
              ),
            ),
            const Icon(Icons.fast_forward_rounded,
                color: AdminSystemSettingsPage._mutedColor, size: 18),
          ],
        ),
        const SizedBox(height: 8),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'Slower',
              style: TextStyle(
                color:
                    AdminSystemSettingsPage._mutedColor.withValues(alpha: 0.7),
                fontSize: 12,
              ),
            ),
            Text(
              'Faster',
              style: TextStyle(
                color:
                    AdminSystemSettingsPage._mutedColor.withValues(alpha: 0.7),
                fontSize: 12,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildSaveButton() {
    return SizedBox(
      width: double.infinity,
      height: 56,
      child: ElevatedButton(
        onPressed: _isSaving ? null : _saveSettings,
        style: ElevatedButton.styleFrom(
          backgroundColor: AdminSystemSettingsPage._accentBlue,
          foregroundColor: Colors.white,
          elevation: 0,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.w700),
        ),
        child: _isSaving
            ? const SizedBox(
                width: 24,
                height: 24,
                child: CircularProgressIndicator(
                  strokeWidth: 2.5,
                  valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                ),
              )
            : const Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.save_rounded, size: 20, color: Colors.white),
                  SizedBox(width: 10),
                  Text('Save Announcement Settings'),
                ],
              ),
      ),
    );
  }

  Widget _buildGeneralContent() {
    if (_isLoadingGeneral) {
      return const Center(
        child: Padding(
          padding: EdgeInsets.all(48),
          child: CircularProgressIndicator(),
        ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Platform Info Card
        _buildPlatformInfoCard(),
        const SizedBox(height: 24),
        // User Registration Card
        _buildUserRegistrationCard(),
        const SizedBox(height: 24),
        // Content Settings Card
        _buildContentSettingsCard(),
        const SizedBox(height: 24),
        // System Status Card
        _buildSystemStatusCard(),
        const SizedBox(height: 32),
        // Save Button
        _buildGeneralSaveButton(),
      ],
    );
  }

  Widget _buildPlatformInfoCard() {
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: AdminSystemSettingsPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.04),
            blurRadius: 16,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(24),
            child: Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        AdminSystemSettingsPage._accentBlue
                            .withValues(alpha: 0.1),
                        AdminSystemSettingsPage._accentBlue
                            .withValues(alpha: 0.05),
                      ],
                    ),
                    borderRadius: BorderRadius.circular(14),
                  ),
                  child: const Icon(
                    Icons.business_rounded,
                    color: AdminSystemSettingsPage._accentBlue,
                    size: 22,
                  ),
                ),
                const SizedBox(width: 16),
                const Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Platform Information',
                        style: TextStyle(
                          color: AdminSystemSettingsPage._titleColor,
                          fontSize: 18,
                          fontWeight: FontWeight.w700,
                        ),
                      ),
                      SizedBox(height: 4),
                      Text(
                        'Configure basic platform details',
                        style: TextStyle(
                          color: AdminSystemSettingsPage._mutedColor,
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          const Divider(height: 1, color: AdminSystemSettingsPage._borderColor),
          Padding(
            padding: const EdgeInsets.all(24),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildLabeledTextField(
                  label: 'Platform Name',
                  controller: _platformNameController,
                  hint: 'Enter your platform name',
                  icon: Icons.badge_outlined,
                ),
                const SizedBox(height: 20),
                _buildLabeledTextField(
                  label: 'Support Email',
                  controller: _supportEmailController,
                  hint: 'support@example.com',
                  icon: Icons.email_outlined,
                  keyboardType: TextInputType.emailAddress,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildUserRegistrationCard() {
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: AdminSystemSettingsPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.04),
            blurRadius: 16,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(24),
            child: Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        const Color(0xFF8B5CF6).withValues(alpha: 0.1),
                        const Color(0xFF8B5CF6).withValues(alpha: 0.05),
                      ],
                    ),
                    borderRadius: BorderRadius.circular(14),
                  ),
                  child: const Icon(
                    Icons.person_add_rounded,
                    color: Color(0xFF8B5CF6),
                    size: 22,
                  ),
                ),
                const SizedBox(width: 16),
                const Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'User Registration',
                        style: TextStyle(
                          color: AdminSystemSettingsPage._titleColor,
                          fontSize: 18,
                          fontWeight: FontWeight.w700,
                        ),
                      ),
                      SizedBox(height: 4),
                      Text(
                        'Control how new users join the platform',
                        style: TextStyle(
                          color: AdminSystemSettingsPage._mutedColor,
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          const Divider(height: 1, color: AdminSystemSettingsPage._borderColor),
          Padding(
            padding: const EdgeInsets.all(24),
            child: Column(
              children: [
                _buildSettingToggle(
                  title: 'Allow Self-Registration',
                  subtitle: _allowSelfRegistration
                      ? 'Users can create their own accounts'
                      : 'Only admins can create new accounts',
                  icon: Icons.how_to_reg_rounded,
                  value: _allowSelfRegistration,
                  onChanged: (v) => setState(() => _allowSelfRegistration = v),
                ),
                const SizedBox(height: 20),
                _buildSettingToggle(
                  title: 'Require Email Verification',
                  subtitle: _requireEmailVerification
                      ? 'Users must verify email before accessing content'
                      : 'Users can access content immediately after signup',
                  icon: Icons.mark_email_read_rounded,
                  value: _requireEmailVerification,
                  onChanged: (v) =>
                      setState(() => _requireEmailVerification = v),
                ),
                const SizedBox(height: 20),
                _buildDropdownSetting(
                  title: 'Default User Role',
                  subtitle: 'Role assigned to new users',
                  icon: Icons.security_rounded,
                  value: _defaultUserRole,
                  options: const ['Member', 'Coach'],
                  onChanged: (v) =>
                      setState(() => _defaultUserRole = v ?? 'Member'),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildContentSettingsCard() {
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: AdminSystemSettingsPage._borderColor),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.04),
            blurRadius: 16,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(24),
            child: Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        const Color(0xFF0D9488).withValues(alpha: 0.1),
                        const Color(0xFF0D9488).withValues(alpha: 0.05),
                      ],
                    ),
                    borderRadius: BorderRadius.circular(14),
                  ),
                  child: const Icon(
                    Icons.play_circle_rounded,
                    color: Color(0xFF0D9488),
                    size: 22,
                  ),
                ),
                const SizedBox(width: 16),
                const Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Content Settings',
                        style: TextStyle(
                          color: AdminSystemSettingsPage._titleColor,
                          fontSize: 18,
                          fontWeight: FontWeight.w700,
                        ),
                      ),
                      SizedBox(height: 4),
                      Text(
                        'Configure content playback and display',
                        style: TextStyle(
                          color: AdminSystemSettingsPage._mutedColor,
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          const Divider(height: 1, color: AdminSystemSettingsPage._borderColor),
          Padding(
            padding: const EdgeInsets.all(24),
            child: Column(
              children: [
                _buildSettingToggle(
                  title: 'Auto-Play Videos',
                  subtitle: _autoPlayVideos
                      ? 'Videos start playing automatically'
                      : 'Users must manually start video playback',
                  icon: Icons.play_arrow_rounded,
                  value: _autoPlayVideos,
                  onChanged: (v) => setState(() => _autoPlayVideos = v),
                ),
                const SizedBox(height: 20),
                _buildSliderSetting(
                  title: 'Session Timeout',
                  subtitle:
                      'Inactive users will be logged out after $_sessionTimeoutMinutes minutes',
                  icon: Icons.timer_rounded,
                  value: _sessionTimeoutMinutes.toDouble(),
                  min: 15,
                  max: 240,
                  divisions: 15,
                  label: '$_sessionTimeoutMinutes min',
                  onChanged: (v) =>
                      setState(() => _sessionTimeoutMinutes = v.round()),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSystemStatusCard() {
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(
          color: _maintenanceMode
              ? Colors.orange.withValues(alpha: 0.5)
              : AdminSystemSettingsPage._borderColor,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.04),
            blurRadius: 16,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(24),
            child: Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        (_maintenanceMode
                                ? Colors.orange
                                : const Color(0xFFEF4444))
                            .withValues(alpha: 0.1),
                        (_maintenanceMode
                                ? Colors.orange
                                : const Color(0xFFEF4444))
                            .withValues(alpha: 0.05),
                      ],
                    ),
                    borderRadius: BorderRadius.circular(14),
                  ),
                  child: Icon(
                    _maintenanceMode
                        ? Icons.engineering_rounded
                        : Icons.power_settings_new_rounded,
                    color: _maintenanceMode
                        ? Colors.orange
                        : const Color(0xFFEF4444),
                    size: 22,
                  ),
                ),
                const SizedBox(width: 16),
                const Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'System Status',
                        style: TextStyle(
                          color: AdminSystemSettingsPage._titleColor,
                          fontSize: 18,
                          fontWeight: FontWeight.w700,
                        ),
                      ),
                      SizedBox(height: 4),
                      Text(
                        'Control system availability',
                        style: TextStyle(
                          color: AdminSystemSettingsPage._mutedColor,
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
                Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    color: _maintenanceMode
                        ? Colors.orange.withValues(alpha: 0.1)
                        : AdminSystemSettingsPage._successGreen
                            .withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(20),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Container(
                        width: 8,
                        height: 8,
                        decoration: BoxDecoration(
                          color: _maintenanceMode
                              ? Colors.orange
                              : AdminSystemSettingsPage._successGreen,
                          shape: BoxShape.circle,
                        ),
                      ),
                      const SizedBox(width: 8),
                      Text(
                        _maintenanceMode ? 'Maintenance' : 'Online',
                        style: TextStyle(
                          color: _maintenanceMode
                              ? Colors.orange
                              : AdminSystemSettingsPage._successGreen,
                          fontSize: 13,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          const Divider(height: 1, color: AdminSystemSettingsPage._borderColor),
          Padding(
            padding: const EdgeInsets.all(24),
            child: _buildSettingToggle(
              title: 'Maintenance Mode',
              subtitle: _maintenanceMode
                  ? 'Platform is in maintenance mode. Only admins can access.'
                  : 'Platform is operational and accessible to all users.',
              icon: Icons.build_circle_rounded,
              value: _maintenanceMode,
              onChanged: (v) => setState(() => _maintenanceMode = v),
              activeColor: Colors.orange,
            ),
          ),
          if (_maintenanceMode)
            Container(
              margin: const EdgeInsets.fromLTRB(24, 0, 24, 24),
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.orange.withValues(alpha: 0.08),
                borderRadius: BorderRadius.circular(12),
                border: Border.all(color: Colors.orange.withValues(alpha: 0.2)),
              ),
              child: const Row(
                children: [
                  Icon(Icons.warning_amber_rounded,
                      color: Colors.orange, size: 20),
                  SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      'When enabled, only administrators can access the platform. Regular users will see a maintenance message.',
                      style: TextStyle(
                        color: Color(0xFF92400E),
                        fontSize: 13,
                      ),
                    ),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildLabeledTextField({
    required String label,
    required TextEditingController controller,
    required String hint,
    required IconData icon,
    TextInputType keyboardType = TextInputType.text,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(icon, color: AdminSystemSettingsPage._titleColor, size: 18),
            const SizedBox(width: 8),
            Text(
              label,
              style: const TextStyle(
                color: AdminSystemSettingsPage._titleColor,
                fontSize: 14,
                fontWeight: FontWeight.w600,
              ),
            ),
          ],
        ),
        const SizedBox(height: 10),
        TextField(
          controller: controller,
          keyboardType: keyboardType,
          decoration: InputDecoration(
            hintText: hint,
            hintStyle: TextStyle(
              color: AdminSystemSettingsPage._mutedColor.withValues(alpha: 0.6),
            ),
            filled: true,
            fillColor: const Color(0xFFF9FAFB),
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide:
                  const BorderSide(color: AdminSystemSettingsPage._borderColor),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: const BorderSide(
                color: AdminSystemSettingsPage._accentBlue,
                width: 1.5,
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildSettingToggle({
    required String title,
    required String subtitle,
    required IconData icon,
    required bool value,
    required ValueChanged<bool> onChanged,
    Color? activeColor,
  }) {
    final effectiveActiveColor =
        activeColor ?? AdminSystemSettingsPage._successGreen;
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: value
            ? effectiveActiveColor.withValues(alpha: 0.05)
            : const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(14),
        border: Border.all(
          color: value
              ? effectiveActiveColor.withValues(alpha: 0.2)
              : AdminSystemSettingsPage._borderColor,
        ),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(10),
            decoration: BoxDecoration(
              color: value
                  ? effectiveActiveColor.withValues(alpha: 0.12)
                  : Colors.white,
              borderRadius: BorderRadius.circular(10),
            ),
            child: Icon(
              icon,
              color: value
                  ? effectiveActiveColor
                  : AdminSystemSettingsPage._mutedColor,
              size: 20,
            ),
          ),
          const SizedBox(width: 14),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: const TextStyle(
                    color: AdminSystemSettingsPage._titleColor,
                    fontSize: 15,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 3),
                Text(
                  subtitle,
                  style: const TextStyle(
                    color: AdminSystemSettingsPage._mutedColor,
                    fontSize: 13,
                  ),
                ),
              ],
            ),
          ),
          Switch.adaptive(
            value: value,
            onChanged: onChanged,
            activeColor: Colors.white,
            activeTrackColor: effectiveActiveColor,
            inactiveThumbColor: const Color(0xFFE5E7EB),
            inactiveTrackColor: const Color(0xFFF3F4F6),
          ),
        ],
      ),
    );
  }

  Widget _buildDropdownSetting({
    required String title,
    required String subtitle,
    required IconData icon,
    required String value,
    required List<String> options,
    required ValueChanged<String?> onChanged,
  }) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: AdminSystemSettingsPage._borderColor),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(10),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(10),
            ),
            child: Icon(
              icon,
              color: AdminSystemSettingsPage._mutedColor,
              size: 20,
            ),
          ),
          const SizedBox(width: 14),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: const TextStyle(
                    color: AdminSystemSettingsPage._titleColor,
                    fontSize: 15,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 3),
                Text(
                  subtitle,
                  style: const TextStyle(
                    color: AdminSystemSettingsPage._mutedColor,
                    fontSize: 13,
                  ),
                ),
              ],
            ),
          ),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 12),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(10),
              border: Border.all(color: AdminSystemSettingsPage._borderColor),
            ),
            child: DropdownButtonHideUnderline(
              child: DropdownButton<String>(
                value: value,
                icon: const Icon(Icons.keyboard_arrow_down_rounded, size: 20),
                style: const TextStyle(
                  color: AdminSystemSettingsPage._titleColor,
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
                items: options
                    .map((opt) => DropdownMenuItem(
                          value: opt,
                          child: Text(opt),
                        ))
                    .toList(),
                onChanged: onChanged,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSliderSetting({
    required String title,
    required String subtitle,
    required IconData icon,
    required double value,
    required double min,
    required double max,
    required int divisions,
    required String label,
    required ValueChanged<double> onChanged,
  }) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: const Color(0xFFF9FAFB),
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: AdminSystemSettingsPage._borderColor),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Container(
                padding: const EdgeInsets.all(10),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Icon(
                  icon,
                  color: AdminSystemSettingsPage._mutedColor,
                  size: 20,
                ),
              ),
              const SizedBox(width: 14),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: const TextStyle(
                        color: AdminSystemSettingsPage._titleColor,
                        fontSize: 15,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 3),
                    Text(
                      subtitle,
                      style: const TextStyle(
                        color: AdminSystemSettingsPage._mutedColor,
                        fontSize: 13,
                      ),
                    ),
                  ],
                ),
              ),
              Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                decoration: BoxDecoration(
                  color: AdminSystemSettingsPage._accentBlue
                      .withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  label,
                  style: const TextStyle(
                    color: AdminSystemSettingsPage._accentBlue,
                    fontSize: 13,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          SliderTheme(
            data: SliderThemeData(
              activeTrackColor: AdminSystemSettingsPage._accentBlue,
              inactiveTrackColor: AdminSystemSettingsPage._borderColor,
              thumbColor: AdminSystemSettingsPage._accentBlue,
              overlayColor:
                  AdminSystemSettingsPage._accentBlue.withValues(alpha: 0.1),
              trackHeight: 6,
              thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 10),
            ),
            child: Slider(
              value: value,
              min: min,
              max: max,
              divisions: divisions,
              onChanged: onChanged,
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  '${min.round()} min',
                  style: const TextStyle(
                    color: AdminSystemSettingsPage._mutedColor,
                    fontSize: 11,
                  ),
                ),
                Text(
                  '${max.round()} min',
                  style: const TextStyle(
                    color: AdminSystemSettingsPage._mutedColor,
                    fontSize: 11,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildGeneralSaveButton() {
    return SizedBox(
      width: double.infinity,
      height: 54,
      child: ElevatedButton(
        onPressed: _isSavingGeneral ? null : _saveGeneralSettings,
        style: ElevatedButton.styleFrom(
          backgroundColor: AdminSystemSettingsPage._accentBlue,
          foregroundColor: Colors.white,
          elevation: 0,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.w700),
        ),
        child: _isSavingGeneral
            ? const SizedBox(
                width: 24,
                height: 24,
                child: CircularProgressIndicator(
                  strokeWidth: 2.5,
                  valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                ),
              )
            : const Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.save_rounded, size: 20, color: Colors.white),
                  SizedBox(width: 10),
                  Text('Save General Settings'),
                ],
              ),
      ),
    );
  }
}

class _AdminSettingsTabButton extends StatelessWidget {
  const _AdminSettingsTabButton({
    required this.label,
    required this.icon,
    this.isActive = false,
    this.onTap,
  });

  final String label;
  final IconData icon;
  final bool isActive;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final Color background = isActive ? Colors.white : Colors.transparent;
    final Color contentColor = isActive
        ? AdminSystemSettingsPage._titleColor
        : AdminSystemSettingsPage._mutedColor;

    return Material(
      color: Colors.transparent,
      child: InkWell(
        borderRadius: BorderRadius.circular(16),
        onTap: onTap,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
          decoration: BoxDecoration(
            color: background,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(icon, color: contentColor, size: 18),
              const SizedBox(width: 10),
              Text(
                label,
                style: TextStyle(
                  color: contentColor,
                  fontSize: 15,
                  fontWeight: isActive ? FontWeight.w700 : FontWeight.w600,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _ColorChip extends StatelessWidget {
  const _ColorChip({
    required this.color,
    required this.label,
    required this.isSelected,
    required this.onTap,
    this.showBorder = false,
  });

  final Color color;
  final String label;
  final bool isSelected;
  final VoidCallback onTap;
  final bool showBorder;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      borderRadius: BorderRadius.circular(12),
      onTap: onTap,
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
        decoration: BoxDecoration(
          color: isSelected ? color.withValues(alpha: 0.15) : Colors.white,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: isSelected ? color : AdminSystemSettingsPage._borderColor,
            width: isSelected ? 2 : 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 22,
              height: 22,
              decoration: BoxDecoration(
                color: color,
                borderRadius: BorderRadius.circular(6),
                border: showBorder
                    ? Border.all(color: Colors.grey.withValues(alpha: 0.3))
                    : null,
                boxShadow: [
                  BoxShadow(
                    color: color.withValues(alpha: 0.3),
                    blurRadius: 4,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: isSelected
                  ? Icon(
                      Icons.check_rounded,
                      size: 14,
                      color: showBorder ? Colors.grey[700] : Colors.white,
                    )
                  : null,
            ),
            const SizedBox(width: 10),
            Text(
              label,
              style: TextStyle(
                color: isSelected ? color : AdminSystemSettingsPage._mutedColor,
                fontSize: 13,
                fontWeight: isSelected ? FontWeight.w700 : FontWeight.w500,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _EditMemberDialog extends StatefulWidget {
  final _AdminMemberRowData data;
  final String initialFirstName;
  final String initialLastName;
  final VoidCallback onMemberUpdated;
  final List<Map<String, String>> availableAgencies;

  const _EditMemberDialog({
    required this.data,
    required this.initialFirstName,
    required this.initialLastName,
    required this.onMemberUpdated,
    this.availableAgencies = const [],
  });

  @override
  State<_EditMemberDialog> createState() => _EditMemberDialogState();
}

class _EditMemberDialogState extends State<_EditMemberDialog> {
  late TextEditingController firstNameController;
  late TextEditingController lastNameController;
  String? selectedRole;
  String? selectedAgency;
  String? previousAgencyId;
  List<Map<String, String>> agencies = [];
  bool loadingAgencies = true;
  bool isSaving = false;

  @override
  void initState() {
    super.initState();
    firstNameController = TextEditingController(text: widget.initialFirstName);
    lastNameController = TextEditingController(text: widget.initialLastName);
    selectedRole = widget.data.role;
    _loadData();
  }

  @override
  void dispose() {
    firstNameController.dispose();
    lastNameController.dispose();
    super.dispose();
  }

  Future<void> _loadData() async {
    debugPrint('üèÅ _EditMemberDialogState: _loadData STARTED for ${widget.data.name}');
    
    // Load current user data to get the most up-to-date values
    try {
      debugPrint('‚è≥ Fetching user doc for ${widget.data.userId}...');
      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(widget.data.userId)
          .get();
      debugPrint('‚úÖ User doc fetched. Exists: ${userDoc.exists}');
      
      if (userDoc.exists && mounted) {
        final userData = userDoc.data()!;
        debugPrint('üìÑ User Data: $userData');
        
        // Overwrite with fresh data from DB if available
        if (userData['firstName'] != null) {
          firstNameController.text = userData['firstName'] as String;
        }
        if (userData['lastName'] != null) {
          lastNameController.text = userData['lastName'] as String;
        }

        // Get current agency
        final agencyField = userData['agency'];
        debugPrint('üè¢ Raw Agency Field: $agencyField');
        
        if (agencyField is DocumentReference) {
          selectedAgency = agencyField.id;
          debugPrint('üè¢ Resolved Agency via Ref: $selectedAgency');
        } else if (agencyField is String && agencyField.isNotEmpty) {
          selectedAgency = agencyField;
           debugPrint('üè¢ Resolved Agency via String: $selectedAgency');
        }
      }
    } catch (e) {
      debugPrint('‚ùå Error loading user data: $e');
    }

    // Load agencies
    try {
      // Optimization: Use cached agencies if available
      if (widget.availableAgencies.isNotEmpty) {
        debugPrint('üöÄ Using cached agencies (${widget.availableAgencies.length})');
        setState(() {
          agencies = List.from(widget.availableAgencies); 
          // Logic to reconcile selectedAgency if it was loaded as a Name string
          if (selectedAgency != null) {
            final matchingAgency = agencies.firstWhere(
                (a) => a['id'] == selectedAgency || a['name'] == selectedAgency,
                orElse: () => <String, String>{});
            if (matchingAgency.isNotEmpty) {
              selectedAgency = matchingAgency['id'];
              debugPrint('‚úÖ Reconciled to ID (Cache): $selectedAgency');
            }
          }
           previousAgencyId = selectedAgency;
        });
        // We can safely finish here for agencies part
        return; 
      }

      debugPrint('‚è≥ Fetching agencies collection (Cache missed)...');
      // Optimization: Limit fields or cache if needed, but for now just log it
      final snapshot =
          await FirebaseFirestore.instance.collection('agencies').get();
      debugPrint('‚úÖ Agencies fetched. Count: ${snapshot.docs.length}');
      
      if (!mounted) {
         debugPrint('‚ö†Ô∏è Widget unmounted after fetching agencies. Aborting.');
         return;
      }
      
      final loadedAgencies = snapshot.docs.map((doc) {
        final docData = doc.data();
        return {
          'id': doc.id,
          'name': (docData['agency_name'] ??
              docData['name'] ??
              'Unknown Agency') as String,
        };
      }).toList();
      loadedAgencies.sort((a, b) => (a['name'] ?? '').compareTo(b['name'] ?? ''));
      
      setState(() {
        agencies = loadedAgencies;
        // Don't set loadingAgencies = false here, do it in finally block
        
        // Logic to reconcile selectedAgency if it was loaded as a Name string
        if (selectedAgency != null) {
          debugPrint('üîç Reconciling selectedAgency: "$selectedAgency"');
          final matchingAgency = agencies.firstWhere(
              (a) => a['id'] == selectedAgency || a['name'] == selectedAgency,
              orElse: () => <String, String>{});
          if (matchingAgency.isNotEmpty) {
            selectedAgency = matchingAgency['id'];
             debugPrint('‚úÖ Reconciled to ID: $selectedAgency');
          } else {
             debugPrint('‚ö†Ô∏è Could not match "$selectedAgency" to any known agency.');
          }
        }
        // Store the resolved agency ID as the previous agency for later comparison
        previousAgencyId = selectedAgency;
      });
    } catch (e) {
      debugPrint('‚ùå Error loading agencies: $e');
    } finally {
      if (mounted) {
         debugPrint('üèÅ _loadData FINISHED. Setting loadingAgencies = false.');
        setState(() {
          loadingAgencies = false;
        });
      }
    }
  }

  Future<void> _saveMember() async {
      if (isSaving) return;
      setState(() => isSaving = true);
      
      try {
        final updateData = {
          'firstName': firstNameController.text.trim(),
          'lastName': lastNameController.text.trim(),

          'role': selectedRole,
          'agency': selectedAgency != null && selectedAgency!.isNotEmpty
              ? FirebaseFirestore.instance.collection('agencies').doc(selectedAgency)
              : null,
          if (selectedAgency == null || selectedAgency!.isEmpty) 
             'agency': FieldValue.delete(),
        };

        final fName = firstNameController.text.trim();
        final lName = lastNameController.text.trim();
        final newDisplayName = '$fName $lName'.trim();
        updateData['firstName'] = fName;
        updateData['lastName'] = lName;
        updateData['display_name'] = newDisplayName;
        updateData['displayName'] = newDisplayName;
        updateData['updatedAt'] = FieldValue.serverTimestamp();

        // Handle Agency Name String storage for legacy support
         if (selectedRole != 'Admin' && selectedAgency != null && selectedAgency!.isNotEmpty) {
             final agencyObj = agencies.firstWhere(
                 (element) => element['id'] == selectedAgency,
                 orElse: () => {'name': 'Unknown Agency'});
             updateData['agency'] = agencyObj['name']; // Store name as string too if needed or standard
             // Actually, the new standard seems to likely be string name or doc ref.
             // Based on previous code, we were storing name string in 'agency' field sometimes?
             // Let's stick to the previous code's logic:
             // "updateData['agency'] = agencyObj['name'];" was in the loop.
             // But wait, the previous code also had:
             // "'agency': selectedAgency != null ... ? Reference : null"
             // Let's ensure we are consistent.
             // Re-reading Step 1850 logic:
             // It set updateData['agency'] = agencyObj['name']; IF not admin.
             // Just to be safe and consistent with the deleted code, I will use the NAME string if that's what the app expects, 
             // OR simpler: The app seems to use `agency` field as string name in some places and ref in others.
             // The deleted code at 12666 explicitly set it to NAME string.
             updateData['agency'] = agencyObj['name'];
        } else {
             updateData['agency'] = null;
        }


        await FirebaseFirestore.instance
            .collection('users')
            .doc(widget.data.userId)
            .update(updateData);

        // Update agency members arrays if agency assignment changed
        if (mounted) {
           final memberRef = FirebaseFirestore.instance
              .collection('users')
              .doc(widget.data.userId);
          
          String? newAgencyId;
          if (selectedRole != 'Admin' && selectedAgency != null && selectedAgency!.isNotEmpty) {
            newAgencyId = selectedAgency;
          }

          if (newAgencyId != previousAgencyId) {
             // 1. Remove from old agency's array
             if (previousAgencyId != null) {
               try {
                 await FirebaseFirestore.instance
                     .collection('agencies')
                     .doc(previousAgencyId)
                     .update({
                   'members': FieldValue.arrayRemove([memberRef]),
                 });
               } catch (e) {
                 debugPrint('Error removing member from old agency: $e');
               }
             }

             // 2. Add to new agency's array
             if (newAgencyId != null) {
               try {
                 await FirebaseFirestore.instance
                     .collection('agencies')
                     .doc(newAgencyId)
                     .update({
                   'members': FieldValue.arrayUnion([memberRef]),
                 });
               } catch (e) {
                 debugPrint('Error adding member to new agency: $e');
               }
             }
          }
         
          if (mounted) {
            Navigator.of(context).pop();
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Member updated successfully!'),
                backgroundColor: Color(0xFF22C55E),
              ),
            );
            widget.onMemberUpdated();
          }
        }
      } catch (e) {
        debugPrint('Error updating member: $e');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
             SnackBar(content: Text('Error updating member: $e')),
          );
        }
      } finally {
        if (mounted) setState(() => isSaving = false);
      }
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          child: Container(
            width: 480,
            padding: const EdgeInsets.all(24),
            child: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                   Row(
                    children: [
                       const Expanded(
                        child: Text(
                          'Edit Member',
                          style: TextStyle(
                            fontSize: 20,
                            fontWeight: FontWeight.w700,
                            color: Color(0xFF1F2937),
                          ),
                        ),
                      ),
                      IconButton(
                        icon: const Icon(Icons.close, color: Color(0xFF6B7280)),
                        onPressed: () => Navigator.of(context).pop(),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Update information for ${widget.data.name}',
                    style:
                        const TextStyle(fontSize: 14, color: Color(0xFF6B7280)),
                  ),
                  if (loadingAgencies && (agencies.isEmpty && previousAgencyId == null))
                     const Padding(
                       padding: EdgeInsets.symmetric(vertical: 20),
                       child: Center(child: CircularProgressIndicator()),
                     )
                  else ...[
                  const SizedBox(height: 24),
                  Row(
                    children: [
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Text('First Name',
                                style: TextStyle(
                                    fontSize: 13, fontWeight: FontWeight.w600)),
                            const SizedBox(height: 6),
                            TextField(
                              controller: firstNameController,
                              decoration: InputDecoration(
                                hintText: 'First name',
                                border: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(8)),
                                contentPadding: const EdgeInsets.symmetric(
                                    horizontal: 12, vertical: 12),
                              ),
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Text('Last Name',
                                style: TextStyle(
                                    fontSize: 13, fontWeight: FontWeight.w600)),
                            const SizedBox(height: 6),
                            TextField(
                              controller: lastNameController,
                              decoration: InputDecoration(
                                hintText: 'Last name',
                                border: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(8)),
                                contentPadding: const EdgeInsets.symmetric(
                                    horizontal: 12, vertical: 12),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 16),
                  const Text('Role',
                      style:
                          TextStyle(fontSize: 13, fontWeight: FontWeight.w600)),
                  const SizedBox(height: 6),
                  DropdownButtonFormField<String>(
                    value: selectedRole,
                    decoration: InputDecoration(
                      border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8)),
                      contentPadding: const EdgeInsets.symmetric(
                          horizontal: 12, vertical: 12),
                    ),
                    items: const [
                      DropdownMenuItem(value: 'Admin', child: Text('Admin')),
                      DropdownMenuItem(value: 'Coach', child: Text('Coach')),
                      DropdownMenuItem(value: 'Member', child: Text('Member')),
                    ],
                    onChanged: (value) => setState(() => selectedRole = value),
                  ),
                  const SizedBox(height: 16),
                  // Only show Agency dropdown if role is NOT Admin
                  // Assuming Admins don't belong to a specific agency or can see all
                  if (selectedRole != 'Admin') ...[
                    const Text('Agency',
                        style: TextStyle(
                            fontSize: 13, fontWeight: FontWeight.w600)),
                    const SizedBox(height: 6),
                    loadingAgencies
                        ? Container(
                            height: 48,
                            alignment: Alignment.centerLeft,
                            padding: const EdgeInsets.symmetric(horizontal: 12),
                            decoration: BoxDecoration(
                              border:
                                  Border.all(color: const Color(0xFFE5E7EB)),
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: const Text('Loading agencies...',
                                style: TextStyle(color: Color(0xFF9CA3AF))),
                          )
                        : DropdownButtonFormField<String>(
                            value: agencies
                                    .any((a) => a['id'] == selectedAgency)
                                ? selectedAgency
                                : null,
                            decoration: InputDecoration(
                              hintText: 'Select agency',
                              border: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(8)),
                              contentPadding: const EdgeInsets.symmetric(
                                  horizontal: 12, vertical: 12),
                            ),
                            items: agencies.map((agency) {
                              return DropdownMenuItem(
                                value: agency['id'],
                                child: Text(agency['name']!),
                              );
                            }).toList(),
                            onChanged: (value) =>
                                setState(() => selectedAgency = value),
                          ),
                  ],
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(),
                        child: const Text('Cancel',
                            style: TextStyle(color: Color(0xFF6B7280))),
                      ),
                      const SizedBox(width: 12),
                      SizedBox(
                        height: 40,
                        child: ElevatedButton(
                          style: ElevatedButton.styleFrom(
                            backgroundColor: const Color(0xFF2563EB),
                            shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(8)),
                            padding: const EdgeInsets.symmetric(horizontal: 20),
                          ),
                          onPressed: isSaving ? null : _saveMember,
                          child: isSaving
                              ? const SizedBox(
                                  width: 20,
                                  height: 20,
                                  child: CircularProgressIndicator(
                                      strokeWidth: 2, color: Colors.white))
                              : const Text('Save Changes',
                                  style: TextStyle(
                                      fontWeight: FontWeight.w600,
                                      color: Colors.white)),
                        ),
                      ),
                    ],
                  ),
                ],
              ],
            ),
            ),
          ),
        );
  }
}
